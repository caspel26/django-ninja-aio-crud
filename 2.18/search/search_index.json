{"config":{"lang":["en"],"separator":"[\\\\s\\\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> Powerful async CRUD framework built on top of Django Ninja. Automatic REST APIs with auth, filtering, pagination, and serialization. </p> <p> </p> <p>Get Started  View on GitHub </p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li> <p> Fully Async</p> <p>Built for Django's async ORM from the ground up</p> </li> <li> <p> Automatic CRUD</p> <p>Generate complete REST APIs with minimal code</p> </li> <li> <p> ModelSerializer</p> <p>Define schemas directly on your Django models</p> </li> <li> <p> Class-Based Views</p> <p>Clean, organized view architecture with APIView &amp; APIViewSet</p> </li> <li> <p> JWT Authentication</p> <p>Built-in async JWT bearer authentication</p> </li> <li> <p> Relationship Support</p> <p>Automatic nested serialization for FK, M2M, and reverse relations</p> </li> <li> <p> Auto Documentation</p> <p>OpenAPI / Swagger UI out of the box</p> </li> <li> <p> Schema Validators</p> <p>Pydantic <code>@field_validator</code> and <code>@model_validator</code> on serializers</p> </li> <li> <p> Pagination</p> <p>Built-in async pagination support</p> </li> <li> <p> Performance</p> <p>Using <code>orjson</code> for fast JSON serialization</p> </li> </ul>"},{"location":"#why-django-ninja-aio-crud","title":"Why Django Ninja Aio CRUD?","text":"<p>Traditional Django REST development requires separate serializer classes, manual CRUD view implementation, repetitive boilerplate code, and complex relationship handling. Django Ninja Aio CRUD eliminates this complexity:</p> Traditional ApproachDjango Ninja Aio CRUD Python<pre><code># schema.py\nclass UserSchemaOut(ModelSchema)\n    class Meta:\n    model = User\n    fields = ['id', 'username', 'email']\n\nclass UserSchemaIn(ModelSchema):\n    class Meta:\n        model = User\n        fields = ['username', 'email', 'password']\n\n# views.py\n@api.get(\"/users\", response={200: list[UserSchemaOut]})\nasync def list_users(request):\n    return [user async for user in User.objects.select_related().all()]\n\n@api.post(\"/users/\", response={201: UserSchemaOut})\nasync def create_user(request, data: UserSchemaIn):\n    user = await User.objects.select_related().acreate(**data.model_dump())\n    return 201, user\n\n\n# ... more views for retrieve, update, delete\n</code></pre> Python<pre><code># models.py\nclass User(ModelSerializer):\n    username = models.CharField(max_length=150)\n    email = models.EmailField()\n    password = models.CharField(max_length=128)\n\n    class ReadSerializer:\n        fields = [\"id\", \"username\", \"email\"]\n\n    class CreateSerializer:\n        fields = [\"username\", \"email\", \"password\"]\n\n    class UpdateSerializer:\n        optionals = [(\"email\", str)]\n\n# views.py\n@api.viewset(User)\nclass UserViewSet(APIViewSet):\n    pass\n\n# Done! List, Create, Retrieve, Update, Delete endpoints ready\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li> <p> Serializer (Meta-driven)</p> <p>Dynamic schemas for existing Django models without inheriting ModelSerializer</p> <p> Learn more</p> </li> <li> <p> Models</p> <p>Schema generation, serialization, and async CRUD utilities</p> <p> ModelSerializer \u00b7  ModelUtil</p> </li> <li> <p> Validators</p> <p>Pydantic <code>@field_validator</code> and <code>@model_validator</code> on serializers</p> <p> Validators</p> </li> <li> <p> Views</p> <p>Simple custom views and complete CRUD operations</p> <p> APIView \u00b7  APIViewSet</p> </li> <li> <p> Advanced Topics</p> <p>JWT auth, custom auth, and pagination behavior</p> <p> Authentication \u00b7  Pagination</p> </li> </ul>"},{"location":"#start-with-serializer","title":"Start with Serializer","text":"<p>Use Meta-driven Serializer first if you already have Django models and want immediate CRUD without changing bases:</p> Python<pre><code>from ninja_aio.models import serializers\nfrom . import models\n\nclass BookSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Book\n        schema_in = serializers.SchemaModelConfig(fields=[\"title\", \"published\"])\n        schema_out = serializers.SchemaModelConfig(fields=[\"id\", \"title\", \"published\"])\n        schema_update = serializers.SchemaModelConfig(optionals=[(\"title\", str), (\"published\", bool)])\n</code></pre> <p>Attach to a ViewSet:</p> Python<pre><code>from ninja_aio.views import APIViewSet\nfrom ninja_aio import NinjaAIO\n\napi = NinjaAIO()\n\n@api.viewset(models.Book)\nclass BookViewSet(APIViewSet):\n    serializer_class = BookSerializer\n</code></pre>"},{"location":"#query-optimization-and-schemas","title":"Query Optimization and Schemas","text":"<ul> <li>Declare query optimizations on models via <code>class QuerySet</code> (read, queryset_request, extras).</li> <li>Use <code>QueryUtil</code> to apply scope-based <code>select_related</code> / <code>prefetch_related</code>.</li> <li>Standard query schemas:</li> <li><code>ObjectsQuerySchema(filters=..., select_related=..., prefetch_related=...)</code></li> <li><code>ObjectQuerySchema(getters=..., select_related=..., prefetch_related=...)</code></li> <li><code>QuerySchema(filters=... | getters=...)</code></li> </ul> <p>ViewSets internally use these to build optimized querysets in list/retrieve and serialize via <code>list_read_s</code> and <code>read_s</code>.</p> Query optimization example Python<pre><code>items = await ModelUtil(Article).list_read_s(\n    Article.generate_read_s(),\n    request,\n    query_data=ObjectsQuerySchema(filters={\"category\": 3}),\n    is_for_read=True,\n)\n</code></pre>"},{"location":"#example-complete-blog-api","title":"Example: Complete Blog API","text":"<p>Here's a real-world example with relationships:</p> Full blog API code (click to expand) Python<pre><code># models.py\nfrom django.db import models\nfrom ninja_aio.models import ModelSerializer\n\n\nclass Author(ModelSerializer):\n    name = models.CharField(max_length=200)\n    email = models.EmailField(unique=True)\n    bio = models.TextField(blank=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"email\", \"bio\", \"articles\"]\n\n    class CreateSerializer:\n        fields = [\"name\", \"email\"]\n        optionals = [(\"bio\", str)]\n\n\nclass Category(ModelSerializer):\n    name = models.CharField(max_length=100)\n    slug = models.SlugField(unique=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"slug\"]\n\n    class CreateSerializer:\n        fields = [\"name\", \"slug\"]\n\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    slug = models.SlugField(unique=True)\n    content = models.TextField()\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"articles\")\n    category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True)\n    tags = models.ManyToManyField('Tag', related_name=\"articles\")\n    is_published = models.BooleanField(default=False)\n    views = models.IntegerField(default=0)\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    class ReadSerializer:\n        fields = [\n            \"id\", \"title\", \"slug\", \"content\",\n            \"author\", \"category\", \"tags\",\n            \"is_published\", \"views\", \"created_at\"\n        ]\n\n    class CreateSerializer:\n        fields = [\"title\", \"slug\", \"content\", \"author\", \"category\"]\n        customs = [(\"notify_subscribers\", bool, True)]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"title\", str),\n            (\"content\", str),\n            (\"is_published\", bool),\n        ]\n\n    async def custom_actions(self, payload: dict):\n        if payload.get(\"notify_subscribers\"):\n            # Send notifications\n            await notify_new_article(self)\n\n\nclass Tag(ModelSerializer):\n    name = models.CharField(max_length=50, unique=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\"]\n\n\n# views.py\nfrom ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom .models import Author, Category, Article, Tag\n\napi = NinjaAIO(title=\"Blog API\", version=\"1.0.0\")\n\n\n@api.viewset(Author)\nclass AuthorViewSet(APIViewSet):\n    pass\n\n\n@api.viewset(Category)\nclass CategoryViewSet(APIViewSet):\n    pass\n\n\n@api.viewset(Article)\nclass ArticleViewSet(APIViewSet):\n    query_params = {\n        \"is_published\": (bool, None),\n        \"category\": (int, None),\n        \"author\": (int, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        if filters.get(\"is_published\") is not None:\n            queryset = queryset.filter(is_published=filters[\"is_published\"])\n        if filters.get(\"category\"):\n            queryset = queryset.filter(category_id=filters[\"category\"])\n        if filters.get(\"author\"):\n            queryset = queryset.filter(author_id=filters[\"author\"])\n        return queryset\n\n\n@api.viewset(Tag)\nclass TagViewSet(APIViewSet):\n    pass\n</code></pre> <p>This creates a complete blog API with 4 models with relationships, automatic nested serialization, query filtering, custom actions, and full CRUD operations for all models.</p>"},{"location":"#schema-validators","title":"Schema Validators","text":"<p>Add Pydantic <code>@field_validator</code> and <code>@model_validator</code> directly on serializer classes for input validation. The framework collects validators and attaches them to the generated Pydantic schemas automatically.</p> ModelSerializerSerializer (Meta-driven) <p>Declare validators on inner serializer classes (<code>CreateSerializer</code>, <code>UpdateSerializer</code>, <code>ReadSerializer</code>, <code>DetailSerializer</code>):</p> Python<pre><code>from django.db import models\nfrom pydantic import field_validator, model_validator\nfrom ninja_aio.models import ModelSerializer\n\nclass Book(ModelSerializer):\n    title = models.CharField(max_length=120)\n    description = models.TextField(blank=True)\n\n    class CreateSerializer:\n        fields = [\"title\", \"description\"]\n\n        @field_validator(\"title\")\n        @classmethod\n        def validate_title_min_length(cls, v):\n            if len(v) &lt; 3:\n                raise ValueError(\"Title must be at least 3 characters\")\n            return v\n\n    class UpdateSerializer:\n        optionals = [(\"title\", str), (\"description\", str)]\n\n        @field_validator(\"title\")\n        @classmethod\n        def validate_title_not_empty(cls, v):\n            if v is not None and len(v.strip()) == 0:\n                raise ValueError(\"Title cannot be blank\")\n            return v\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"description\"]\n\n        @model_validator(mode=\"after\")\n        def enrich_output(self):\n            # Transform or enrich the output schema\n            return self\n</code></pre> <p>Use dedicated <code>{Type}Validators</code> inner classes (<code>CreateValidators</code>, <code>UpdateValidators</code>, <code>ReadValidators</code>, <code>DetailValidators</code>):</p> Python<pre><code>from pydantic import field_validator, model_validator\nfrom ninja_aio.models import serializers\nfrom . import models\n\nclass BookSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Book\n        schema_in = serializers.SchemaModelConfig(fields=[\"title\", \"description\"])\n        schema_out = serializers.SchemaModelConfig(fields=[\"id\", \"title\", \"description\"])\n        schema_update = serializers.SchemaModelConfig(\n            optionals=[(\"title\", str), (\"description\", str)]\n        )\n\n    class CreateValidators:\n        @field_validator(\"title\")\n        @classmethod\n        def validate_title_min_length(cls, v):\n            if len(v) &lt; 3:\n                raise ValueError(\"Title must be at least 3 characters\")\n            return v\n\n    class UpdateValidators:\n        @field_validator(\"title\")\n        @classmethod\n        def validate_title_not_empty(cls, v):\n            if v is not None and len(v.strip()) == 0:\n                raise ValueError(\"Title cannot be blank\")\n            return v\n\n    class ReadValidators:\n        @model_validator(mode=\"after\")\n        def enrich_output(self):\n            return self\n</code></pre> <p>Validator class mapping:</p> Schema type ModelSerializer Serializer (Meta-driven) Create <code>CreateSerializer</code> <code>CreateValidators</code> Update <code>UpdateSerializer</code> <code>UpdateValidators</code> Read <code>ReadSerializer</code> <code>ReadValidators</code> Detail <code>DetailSerializer</code> <code>DetailValidators</code>"},{"location":"#key-concepts","title":"Key Concepts","text":"<ul> <li> <p> ModelSerializer</p> <p>Central to Django Ninja Aio CRUD \u2014 define schemas directly on models:</p> Python<pre><code>class User(ModelSerializer):\n    username = models.CharField(max_length=150)\n\n    class ReadSerializer:\n        fields = [\"id\", \"username\"]\n\n    class CreateSerializer:\n        fields = [\"username\"]\n\n    class UpdateSerializer:\n        optionals = [(\"username\", str)]\n</code></pre> </li> <li> <p> Serializer (Meta-driven)</p> <p>For vanilla Django models \u2014 dynamic serialization without changing the base class:</p> Python<pre><code>class BookSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Book\n        schema_in = serializers.SchemaModelConfig(\n            fields=[\"title\", \"published\"]\n        )\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"published\"]\n        )\n</code></pre> </li> <li> <p> APIViewSet</p> <p>Generates complete CRUD endpoints automatically:</p> Python<pre><code>@api.viewset(User)\nclass UserViewSet(APIViewSet):\n    pass\n    # List, Create, Retrieve, Update, Delete\n</code></pre> </li> <li> <p> Custom Views</p> <p>Extend with custom endpoints:</p> Python<pre><code>@api.viewset(User)\nclass UserViewSet(APIViewSet):\n    @api_post(\"/{pk}/activate\")\n    async def activate(self, request, pk: int):\n        user = await User.objects.aget(pk=pk)\n        user.is_active = True\n        await user.asave()\n        return {\"message\": \"User activated\"}\n</code></pre> </li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"#support","title":"Support","text":"<p>If you find Django Ninja Aio CRUD useful, consider supporting the project:</p> <p></p>"},{"location":"#links","title":"Links","text":"<ul> <li>Documentation: https://django-ninja-aio.com</li> <li>GitHub: https://github.com/caspel26/django-ninja-aio-crud</li> <li>PyPI: https://pypi.org/project/django-ninja-aio-crud/</li> <li>Django Ninja: https://django-ninja.dev/</li> <li>Example repository: https://github.com/caspel26/ninja-aio-blog-example</li> </ul> <p>Built with  using Django Ninja</p>"},{"location":"auth/","title":"JWT Authentication and AsyncJwtBearer","text":"<p>This page documents the JWT helpers and the <code>AsyncJwtBearer</code> class in <code>ninja_aio/auth.py</code>, including configuration, validation, and usage in Django Ninja.</p>"},{"location":"auth/#overview","title":"Overview","text":"<ul> <li> AsyncJwtBearer \u2014 Asynchronous HTTP Bearer auth that verifies JWTs, validates claims via a registry, and delegates user resolution to <code>auth_handler</code>.</li> <li> Helpers:</li> <li> <code>validate_key</code> \u2014 Ensures JWK keys are present and of the correct type.</li> <li> <code>validate_mandatory_claims</code> \u2014 Ensures <code>iss</code> and <code>aud</code> are present (from settings if not provided).</li> <li> <code>encode_jwt</code> \u2014 Signs a JWT with time-based claims (<code>iat</code>, <code>nbf</code>, <code>exp</code>) and mandatory <code>iss/aud</code>.</li> <li> <code>decode_jwt</code> \u2014 Verifies and decodes a JWT with a public key and allowed algorithms.</li> </ul>"},{"location":"auth/#configuration-without-settings","title":"Configuration without Settings","text":"<p>Settings are not required. Provide keys and claims explicitly:</p> <ul> <li>Pass <code>private_key</code> to <code>encode_jwt</code> and <code>public_key</code> to <code>decode_jwt</code>/<code>AsyncJwtBearer.jwt_public</code>.</li> <li>Include <code>iss</code> and <code>aud</code> directly in the <code>claims</code> you encode if you are not using settings.</li> </ul> <p>Example key usage without settings:</p> Python<pre><code># ...existing code...\nfrom joserfc import jwk\nfrom ninja_aio.auth import encode_jwt, decode_jwt\n\nprivate_key = jwk.RSAKey.import_key(open(\"priv.jwk\").read())\npublic_key = jwk.RSAKey.import_key(open(\"pub.jwk\").read())\n\ntoken = encode_jwt(\n    claims={\"sub\": \"123\", \"iss\": \"https://auth.example\", \"aud\": \"my-api\"},\n    duration=3600,\n    private_key=private_key,\n    algorithm=\"RS256\",\n)\n\ndecoded = decode_jwt(token=token, public_key=public_key, algorithms=[\"RS256\"])\n# ...existing code...\n</code></pre>"},{"location":"auth/#mandatory-claims","title":"Mandatory Claims","text":"<p>The library enforces <code>iss</code> and <code>aud</code> via <code>JWT_MANDATORY_CLAIMS</code>. If you do not use settings, include them in the payload you pass to <code>encode_jwt</code>.</p>"},{"location":"auth/#configuration-with-settings-optional","title":"Configuration with Settings (Optional)","text":"<p>You can centralize configuration in Django settings and omit explicit keys/claims:</p> <ul> <li><code>JWT_PRIVATE_KEY</code>: jwk.RSAKey or jwk.ECKey for signing</li> <li><code>JWT_PUBLIC_KEY</code>: jwk.RSAKey or jwk.ECKey for verification</li> <li><code>JWT_ISSUER</code>: issuer string</li> <li><code>JWT_AUDIENCE</code>: audience string</li> </ul> <p>When present:</p> <ul> <li><code>encode_jwt</code> reads <code>JWT_PRIVATE_KEY</code> if <code>private_key</code> is not passed, and fills <code>iss</code>/<code>aud</code> via <code>validate_mandatory_claims</code> if missing.</li> <li><code>decode_jwt</code> reads <code>JWT_PUBLIC_KEY</code> if <code>public_key</code> is not passed.</li> <li><code>AsyncJwtBearer</code> can read the public key from settings by assigning <code>jwt_public = settings.JWT_PUBLIC_KEY</code>.</li> </ul> Python<pre><code># settings.py (example)\nJWT_PRIVATE_KEY = jwk.RSAKey.import_key(open(\"priv.jwk\").read())\nJWT_PUBLIC_KEY = jwk.RSAKey.import_key(open(\"pub.jwk\").read())\nJWT_ISSUER = \"https://auth.example\"\nJWT_AUDIENCE = \"my-api\"\n</code></pre> <p>Usage without passing keys/claims explicitly:</p> Python<pre><code>from ninja_aio.auth import encode_jwt, decode_jwt\n# claims missing iss/aud will be completed from settings\ntoken = encode_jwt(claims={\"sub\": \"123\"}, duration=3600)\n\ndecoded = decode_jwt(token=token)  # uses settings.JWT_PUBLIC_KEY\n</code></pre> <p>AsyncJwtBearer wired to settings:</p> Python<pre><code>from django.conf import settings\nfrom ninja_aio.auth import AsyncJwtBearer\n\nclass SettingsBearer(AsyncJwtBearer):\n    jwt_public = settings.JWT_PUBLIC_KEY\n    claims = {\n        \"iss\": {\"value\": settings.JWT_ISSUER},\n        \"aud\": {\"value\": settings.JWT_AUDIENCE},\n        # Optionally require time-based claims:\n        # \"exp\": {\"essential\": True},\n        # \"nbf\": {\"essential\": True},\n    }\n\n    async def auth_handler(self, request):\n        sub = self.dcd.claims.get(\"sub\")\n        return {\"user_id\": sub}\n</code></pre>"},{"location":"auth/#asyncjwtbearer","title":"AsyncJwtBearer","text":""},{"location":"auth/#key-points","title":"Key Points","text":"<ul> <li><code>jwt_public</code>: Must be a JWK (RSA or EC) used to verify signatures.</li> <li><code>claims</code>: Dict passed to <code>jwt.JWTClaimsRegistry</code> defining validations (e.g., <code>iss</code>, <code>aud</code>, <code>exp</code>, <code>nbf</code>).</li> <li><code>algorithms</code>: Allowed algorithms (default <code>[\"RS256\"]</code>).</li> <li><code>dcd</code>: Set after successful decode; instance of <code>jwt.Token</code> containing <code>header</code> and <code>claims</code>.</li> <li><code>get_claims()</code>: Builds the claim registry from <code>claims</code>.</li> <li><code>validate_claims(claims)</code>: Validates decoded claims; raises <code>jose.errors.JoseError</code> on failure.</li> <li><code>auth_handler(request)</code>: Async hook to resolve application user given the decoded token (<code>self.dcd</code>).</li> <li><code>authenticate(request, token)</code>: Decodes, validates, and delegates to <code>auth_handler</code>. Returns user or <code>False</code>.</li> </ul>"},{"location":"auth/#example","title":"Example","text":"Python<pre><code>from joserfc import jwk\nfrom ninja import NinjaAPI\nfrom ninja_aio.auth import AsyncJwtBearer\n\nclass MyBearer(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(open(\"pub.jwk\").read())\n    claims = {\n        \"iss\": {\"value\": \"https://auth.example\"},\n        \"aud\": {\"value\": \"my-api\"},\n        # You can add time-based checks if needed:\n        # \"exp\": {\"essential\": True},\n        # \"nbf\": {\"essential\": True},\n    }\n\n    async def auth_handler(self, request):\n        sub = self.dcd.claims.get(\"sub\")\n        return {\"user_id\": sub}\n\napi = NinjaAPI()\n\n@api.get(\"/secure\", auth=MyBearer())\ndef secure_endpoint(request):\n    return {\"ok\": True}\n</code></pre>"},{"location":"auth/#claims-registry-helper","title":"Claims Registry Helper","text":"<p>You can construct and reuse a registry from your class-level <code>claims</code>:</p> Python<pre><code>registry = MyBearer.get_claims()\n# registry.validate(token_claims)  # raises JoseError on failure\n</code></pre>"},{"location":"auth/#encode_jwt","title":"encode_jwt","text":"<p>Signs a JWT with safe defaults:</p> <ul> <li>Adds <code>iat</code>, <code>nbf</code>, and <code>exp</code> using timezone-aware <code>timezone.now()</code>.</li> <li>Ensures <code>iss</code> and <code>aud</code> are present via <code>validate_mandatory_claims</code> (include them in <code>claims</code> if not using settings).</li> <li>Header includes <code>alg</code>, <code>typ=JWT</code>, and optional <code>kid</code>.</li> </ul> Python<pre><code>from joserfc import jwk\nfrom ninja_aio.auth import encode_jwt\n\nprivate_key = jwk.RSAKey.import_key(open(\"priv.jwk\").read())\n\nclaims = {\"sub\": \"123\", \"scope\": \"read\", \"iss\": \"https://auth.example\", \"aud\": \"my-api\"}\ntoken = encode_jwt(\n    claims=claims,\n    duration=3600,\n    private_key=private_key,\n    algorithm=\"RS256\",\n)\n</code></pre>"},{"location":"auth/#decode_jwt","title":"decode_jwt","text":"<p>Verifies and decodes a JWT with a public key and algorithm allow-list.</p> Python<pre><code>from joserfc import jwk\nfrom ninja_aio.auth import decode_jwt\n\npublic_key = jwk.RSAKey.import_key(open(\"pub.jwk\").read())\n\ndecoded = decode_jwt(\n    token=token,\n    public_key=public_key,\n    algorithms=[\"RS256\"],\n)\n\nclaims = decoded.claims\nsub = claims.get(\"sub\")\n</code></pre>"},{"location":"auth/#material-key-check-validate_key","title":":material-key-check: validate_key","text":"<p>If you do not use settings, pass keys directly. <code>validate_key</code> will raise <code>ValueError</code> only when neither an explicit key nor a configured setting is provided.</p> Python<pre><code>from ninja_aio.auth import validate_key\nfrom joserfc import jwk\n\npkey = validate_key(jwk.RSAKey.import_key(open(\"priv.jwk\").read()), \"JWT_PRIVATE_KEY\")\n</code></pre>"},{"location":"auth/#validate_mandatory_claims","title":"validate_mandatory_claims","text":"<p>Ensures <code>iss</code> and <code>aud</code> are present; if settings are not used, include them in your input claims.</p> Python<pre><code>from ninja_aio.auth import validate_mandatory_claims\n\nclaims = {\"sub\": \"123\", \"iss\": \"https://auth.example\", \"aud\": \"my-api\"}\nclaims = validate_mandatory_claims(claims)\n</code></pre>"},{"location":"auth/#error-handling","title":"Error Handling","text":"<ul> <li><code>authenticate</code> returns <code>False</code> on decode (<code>ValueError</code>) or claim validation failure (<code>JoseError</code>). Map this to 401/403 in your views as needed.</li> <li><code>validate_claims</code> raises <code>jose.errors.JoseError</code> for invalid claims.</li> <li><code>encode_jwt</code> and <code>decode_jwt</code> raise <code>ValueError</code> for missing/invalid keys or configuration.</li> </ul>"},{"location":"auth/#security-notes","title":"Security Notes","text":"<p>Security Best Practices</p> <ul> <li>Rotate keys and use <code>kid</code> headers to support key rotation.</li> <li>Validate critical claims (<code>exp</code>, <code>nbf</code>, <code>iss</code>, <code>aud</code>) via the registry.</li> <li>Do not log raw tokens or sensitive claims.</li> </ul>"},{"location":"auth/#see-also","title":"See Also","text":"<ul> <li> <p> API Authentication \u2014 Authentication levels and ViewSet integration</p> <p> API Authentication</p> </li> <li> <p> Tutorial: Authentication \u2014 Step-by-step auth setup guide</p> <p> Authentication Tutorial</p> </li> <li> <p> APIViewSet \u2014 Auto-generated CRUD with auth support</p> <p> APIViewSet</p> </li> </ul>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>We welcome contributions! Here's how you can help:</p> <ul> <li> <p> Report Bugs</p> <p>Open an issue on GitHub</p> </li> <li> <p> Suggest Features</p> <p>Share ideas in issues or discussions</p> </li> <li> <p> Submit PRs</p> <p>Improve code, tests, or docs</p> </li> <li> <p> Improve Docs</p> <p>Clarify, expand, or add examples</p> </li> <li> <p> Add Tests</p> <p>Increase coverage and reliability</p> </li> <li> <p> Review PRs</p> <p>Provide constructive feedback</p> </li> </ul>"},{"location":"contributing/#support-the-project","title":"Support the Project","text":"<p>If this project helps you, please give it a GitHub star to show support.</p>"},{"location":"contributing/#buy-me-a-coffee","title":"Buy Me a Coffee","text":"<p>Optional tip: Buy Me a Coffee.</p>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>PR Checklist</p> <ul> <li>Keep PRs focused and small</li> <li>Follow existing code style</li> <li>Add or update tests when relevant</li> <li>Update docs for user-facing changes</li> <li>Link related issue in the PR description</li> </ul>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"Bash<pre><code>git clone https://github.com/caspel26/django-ninja-aio-crud.git\ncd django-ninja-aio-crud\npython -m venv .venv\nsource .venv/bin/activate\npip install -r requirements.dev.txt\n</code></pre>"},{"location":"contributing/#issue-reports","title":"Issue Reports","text":"<p>Please include</p> <ul> <li>Python/Django versions</li> <li>Steps to reproduce</li> <li>Expected vs actual behavior</li> <li>Tracebacks or logs (if any)</li> </ul> <p>Thank you for helping improve the project.</p>"},{"location":"release_notes/","title":"Release Notes","text":"Select versionv2.18.0  \u2014  Feb 01, 2026v2.18.0LatestFeb 01, 2026v2.17.0Jan 28, 2026v2.16.2Jan 27, 2026v2.16.1Jan 27, 2026v2.15.0Jan 22, 2026v2.14.0Jan 22, 2026v2.13.0Jan 21, 2026v2.12.3Jan 21, 2026v2.12.2Jan 21, 2026v2.12.1Jan 21, 2026v2.12.0Jan 21, 2026v2.11.2Jan 19, 2026v2.11.1Jan 19, 2026v2.11.0Jan 19, 2026v2.10.1Jan 16, 2026v2.10.0Jan 16, 2026v2.9.0Jan 14, 2026v2.8.0Jan 14, 2026v2.7.0Jan 13, 2026v2.6.1Jan 12, 2026v2.5.0Jan 12, 2026v2.4.0Jan 09, 2026v2.3.2Jan 08, 2026v2.3.1Jan 07, 2026v2.3.0Jan 04, 2026v2.2.0Jan 03, 2026v2.1.0Jan 02, 2026v2.0.0Dec 16, 2025v2.0.0-rc1Dec 07, 2025v2.0.0-rc2Dec 12, 2025v2.0.0-rc3Dec 12, 2025v2.0.0-rc4Dec 12, 2025v2.0.0-rc5Dec 12, 2025v2.0.0-rc6Dec 12, 2025v2.0.0-rc7Dec 16, 2025v1.0.5Dec 07, 2025v1.0.4Nov 03, 2025v1.0.3Nov 03, 2025v1.0.2Nov 01, 2025v1.0.1Oct 30, 2025v1.0.0Oct 28, 2025v0.11.4Oct 28, 2025v0.11.3Oct 28, 2025v0.11.1Oct 28, 2025v0.11.0Oct 26, 2025v0.10.3Sep 23, 2025v0.10.2Sep 18, 2025v0.10.1Sep 18, 2025v0.10.0Sep 15, 20250.9.2Aug 25, 2025v0.9.1Aug 25, 2025v0.9.0Jul 18, 2025v0.8.4Jun 20, 2025v0.8.3Jun 18, 2025v0.8.2Jun 18, 2025v0.8.1Jun 18, 2025v0.8.0May 15, 2025v0.7.8Mar 21, 2025v0.7.7Mar 05, 2025v0.7.6Feb 24, 2025v0.7.5Feb 22, 2025v0.7.4Feb 20, 2025v0.7.3Feb 19, 2025v0.7.2Jan 30, 2025v0.7.1Jan 29, 2025v0.7.0Jan 29, 2025v0.6.4Jan 22, 2025v0.6.3Jan 22, 2025v0.6.2Jan 19, 2025v0.6.1Jan 13, 2025v0.6.0Jan 12, 2025v0.5.0Jan 09, 2025v0.4.0Jan 08, 2025v0.3.1Nov 07, 2024v0.3.0Oct 10, 2024v0.2.2Oct 03, 2024v0.2.1Oct 02, 2024v0.2.0Oct 01, 2024v0.1.4Sep 29, 2024v0.1.3Sep 28, 2024v0.1.2Sep 26, 2024v0.1.1Sep 26, 2024 v2.18.0 LatestFeb 01, 2026GitHub Release \u00b7 Diff v2.17.0Jan 28, 2026GitHub Release \u00b7 Diff v2.16.2Jan 27, 2026GitHub Release \u00b7 Diff v2.16.1Jan 27, 2026GitHub Release \u00b7 Diff v2.15.0Jan 22, 2026GitHub Release \u00b7 Diff v2.14.0Jan 22, 2026GitHub Release \u00b7 Diff v2.13.0Jan 21, 2026GitHub Release \u00b7 Diff v2.12.3Jan 21, 2026GitHub Release \u00b7 Diff v2.12.2Jan 21, 2026GitHub Release \u00b7 Diff v2.12.1Jan 21, 2026GitHub Release \u00b7 Diff v2.12.0Jan 21, 2026GitHub Release \u00b7 Diff v2.11.2Jan 19, 2026GitHub Release \u00b7 Diff v2.11.1Jan 19, 2026GitHub Release \u00b7 Diff v2.11.0Jan 19, 2026GitHub Release \u00b7 Diff v2.10.1Jan 16, 2026GitHub Release \u00b7 Diff v2.10.0Jan 16, 2026GitHub Release \u00b7 Diff v2.9.0Jan 14, 2026GitHub Release \u00b7 Diff v2.8.0Jan 14, 2026GitHub Release \u00b7 Diff v2.7.0Jan 13, 2026GitHub Release \u00b7 Diff v2.6.1Jan 12, 2026GitHub Release \u00b7 Diff v2.5.0Jan 12, 2026GitHub Release \u00b7 Diff v2.4.0Jan 09, 2026GitHub Release \u00b7 Diff v2.3.2Jan 08, 2026GitHub Release \u00b7 Diff v2.3.1Jan 07, 2026GitHub Release \u00b7 Diff v2.3.0Jan 04, 2026GitHub Release \u00b7 Diff v2.2.0Jan 03, 2026GitHub Release \u00b7 Diff v2.1.0Jan 02, 2026GitHub Release \u00b7 Diff v2.0.0Dec 16, 2025GitHub Release \u00b7 Diff v2.0.0-rc1Dec 07, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v2.0.0-rc2Dec 12, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v2.0.0-rc3Dec 12, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v2.0.0-rc4Dec 12, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v2.0.0-rc5Dec 12, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v2.0.0-rc6Dec 12, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v2.0.0-rc7Dec 16, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v1.0.5Dec 07, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v1.0.4Nov 03, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v1.0.3Nov 03, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v1.0.2Nov 01, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v1.0.1Oct 30, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v1.0.0Oct 28, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.11.4Oct 28, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.11.3Oct 28, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.11.1Oct 28, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.11.0Oct 26, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.10.3Sep 23, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.10.2Sep 18, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.10.1Sep 18, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.10.0Sep 15, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff 0.9.2Aug 25, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.9.1Aug 25, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.9.0Jul 18, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.8.4Jun 20, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.8.3Jun 18, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.8.2Jun 18, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.8.1Jun 18, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.8.0May 15, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.7.8Mar 21, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.7.7Mar 05, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.7.6Feb 24, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.7.5Feb 22, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.7.4Feb 20, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.7.3Feb 19, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.7.2Jan 30, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.7.1Jan 29, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.7.0Jan 29, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.6.4Jan 22, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.6.3Jan 22, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.6.2Jan 19, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.6.1Jan 13, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.6.0Jan 12, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.5.0Jan 09, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.4.0Jan 08, 2025<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.3.1Nov 07, 2024<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.3.0Oct 10, 2024<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.2.2Oct 03, 2024<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.2.1Oct 02, 2024<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.2.0Oct 01, 2024<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.1.4Sep 29, 2024<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.1.3Sep 28, 2024<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.1.2Sep 26, 2024<p>No release notes for this version.</p>GitHub Release \u00b7 Diff v0.1.1Sep 26, 2024<p>No release notes for this version.</p>GitHub Release \u00b7 Diff"},{"location":"release_notes/#release-notes","title":"\ud83d\udccb Release Notes","text":""},{"location":"release_notes/#v2180-2026-02-01","title":"\ud83c\udff7\ufe0f [v2.18.0] - 2026-02-01","text":""},{"location":"release_notes/#new-features","title":"\u2728 New Features","text":""},{"location":"release_notes/#validators-on-serializers","title":"\ud83d\udee1\ufe0f Validators on Serializers","text":"<p><code>ninja_aio/models/serializers.py</code></p> <p>Pydantic <code>@field_validator</code> and <code>@model_validator</code> can now be declared directly on serializer configuration classes. The framework automatically collects <code>PydanticDescriptorProxy</code> instances and creates a subclass of the generated schema with the validators attached.</p> <p>Supported on both serializer patterns:</p> Pattern Where to declare validators <code>ModelSerializer</code> Inner classes: <code>CreateSerializer</code>, <code>ReadSerializer</code>, <code>UpdateSerializer</code>, <code>DetailSerializer</code> <code>Serializer</code> (Meta-driven) Dedicated inner classes: <code>CreateValidators</code>, <code>ReadValidators</code>, <code>UpdateValidators</code>, <code>DetailValidators</code> <p>\ud83d\udd00 Different validation rules can be applied per operation (e.g., stricter rules on create, lenient on update).</p> <p>ModelSerializer example:</p> <pre><code>from django.db import models\nfrom pydantic import field_validator, model_validator\nfrom ninja_aio.models import ModelSerializer\n\nclass Book(ModelSerializer):\n    title = models.CharField(max_length=120)\n    description = models.TextField(blank=True)\n\n    class CreateSerializer:\n        fields = [\"title\", \"description\"]\n\n        @field_validator(\"title\")\n        @classmethod\n        def validate_title_min_length(cls, v):\n            if len(v) &lt; 3:\n                raise ValueError(\"Title must be at least 3 characters\")\n            return v\n\n    class UpdateSerializer:\n        optionals = [(\"title\", str), (\"description\", str)]\n\n        @field_validator(\"title\")\n        @classmethod\n        def validate_title_not_empty(cls, v):\n            if v is not None and len(v.strip()) == 0:\n                raise ValueError(\"Title cannot be blank\")\n            return v\n</code></pre> <p>Serializer (Meta-driven) example:</p> <pre><code>from pydantic import field_validator\nfrom ninja_aio.models import serializers\n\nclass BookSerializer(serializers.Serializer):\n    class Meta:\n        model = Book\n        schema_in = serializers.SchemaModelConfig(fields=[\"title\", \"description\"])\n        schema_out = serializers.SchemaModelConfig(fields=[\"id\", \"title\", \"description\"])\n\n    class CreateValidators:\n        @field_validator(\"title\")\n        @classmethod\n        def validate_title_min_length(cls, v):\n            if len(v) &lt; 3:\n                raise ValueError(\"Title must be at least 3 characters\")\n            return v\n</code></pre>"},{"location":"release_notes/#new-core-methods-on-baseserializer","title":"\ud83e\udde9 New Core Methods on <code>BaseSerializer</code>","text":"<p><code>ninja_aio/models/serializers.py</code></p> Method Description <code>_collect_validators(source_class)</code> \ud83d\udd0d Scans a class for <code>PydanticDescriptorProxy</code> instances created by <code>@field_validator</code> / <code>@model_validator</code> decorators. Returns a dict mapping attribute names to validator proxies. <code>_apply_validators(schema, validators)</code> \ud83d\udd17 Creates a subclass of the generated schema with validators attached. Pydantic discovers validators during class creation. <code>_get_validators(schema_type)</code> \ud83d\uddfa\ufe0f Abstract method for subclasses to map schema types (<code>In</code>, <code>Patch</code>, <code>Out</code>, <code>Detail</code>, <code>Related</code>) to their validator source classes."},{"location":"release_notes/#new-_parse_payload-method-on-serializer","title":"\ud83c\udd95 New <code>_parse_payload()</code> Method on Serializer","text":"<p><code>ninja_aio/models/serializers.py</code></p> <p><code>Serializer._parse_payload(payload)</code> accepts both <code>dict</code> and <code>Schema</code> instances, automatically calling <code>model_dump()</code> on Schema inputs. This enables passing validated Pydantic schemas directly to <code>create()</code> and <code>update()</code>.</p>"},{"location":"release_notes/#new-tutorial-define-your-serializer","title":"\ud83d\udcd6 New Tutorial: \"Define Your Serializer\"","text":"<p><code>docs/tutorial/serializer.md</code></p> <p>Comprehensive tutorial page for the Meta-driven <code>Serializer</code> approach as an alternative to Step 1 (ModelSerializer). Covers:</p> <ul> <li>\ud83d\udcd0 Schema definition with <code>SchemaModelConfig</code></li> <li>\ud83d\udd17 Relationships via <code>relations_serializers</code></li> <li>\u2699\ufe0f Custom and computed fields</li> <li>\ud83d\ude80 Query optimizations with <code>QuerySet</code></li> <li>\ud83d\udd04 Lifecycle hooks</li> <li>\ud83d\udd0c Connecting to <code>APIViewSet</code></li> </ul>"},{"location":"release_notes/#new-validators-documentation-page","title":"\ud83d\udcda New Validators Documentation Page","text":"<p><code>docs/api/models/validators.md</code></p> <p>Full dedicated documentation page covering:</p> <ul> <li>\ud83c\udfd7\ufe0f <code>ModelSerializer</code> and <code>Serializer</code> approaches</li> <li>\u2705 Supported validator types and modes</li> <li>\ud83d\udd00 Different validators per operation</li> <li>\u2699\ufe0f Internal mechanics</li> <li>\u26a0\ufe0f Error handling (422 responses)</li> <li>\ud83d\udca1 Complete examples</li> </ul>"},{"location":"release_notes/#improvements","title":"\ud83d\udd27 Improvements","text":""},{"location":"release_notes/#schema-generation-now-applies-validators","title":"\u26a1 Schema Generation Now Applies Validators","text":"<p><code>ninja_aio/models/serializers.py</code></p> <p><code>_generate_model_schema()</code> now calls <code>_get_validators()</code> for the requested schema type and <code>_apply_validators()</code> on the resulting schema. Applied consistently across all schema types: <code>Out</code>, <code>Detail</code>, <code>Related</code>, <code>In</code>, and <code>Patch</code>.</p>"},{"location":"release_notes/#create-and-update-accept-schema-objects","title":"\ud83d\udce6 <code>create()</code> and <code>update()</code> Accept Schema Objects","text":"<p><code>ninja_aio/models/serializers.py</code></p> <p><code>Serializer.create()</code> and <code>Serializer.update()</code> payload parameter type changed from <code>dict[str, Any]</code> to <code>dict[str, Any] | Schema</code>, using the new <code>_parse_payload()</code> method to handle both inputs transparently.</p>"},{"location":"release_notes/#updated-type-annotations","title":"\ud83c\udff7\ufe0f Updated Type Annotations","text":"<p><code>ninja_aio/models/serializers.py</code></p> <ul> <li><code>ModelSerializer</code> inner classes now accept <code>tuple[str, Any]</code> in addition to <code>tuple[str, Any, Any]</code> for both <code>fields</code> and <code>customs</code> attributes.</li> <li><code>SchemaModelConfig.customs</code> type annotation updated to <code>List[tuple[str, Any, Any] | tuple[str, Any]]</code>.</li> </ul>"},{"location":"release_notes/#comprehensive-docstrings","title":"\ud83d\udcdd Comprehensive Docstrings","text":"<p><code>ninja_aio/models/serializers.py</code></p> <p>Added detailed NumPy-style docstrings with <code>Parameters</code>, <code>Returns</code>, and <code>Raises</code> sections to virtually all methods in <code>BaseSerializer</code>, <code>ModelSerializer</code>, and <code>Serializer</code> (30+ methods).</p>"},{"location":"release_notes/#documentation-overhaul","title":"\ud83c\udfa8 Documentation Overhaul","text":""},{"location":"release_notes/#complete-site-redesign","title":"\ud83d\udc8e Complete Site Redesign","text":"<p>All documentation pages updated with Material for MkDocs icons, grid cards, section dividers, and modern formatting:</p> <ul> <li>\ud83c\udfe0 Landing page \u2014 Hero section, CTA buttons, grid cards for features, tabbed code comparison, Schema Validators section, key concepts in card layout</li> <li>\ud83d\udcd6 Tutorial pages \u2014 Hero banners with step indicators, learning objectives, prerequisites boxes, summary checklists</li> <li>\ud83d\udcd1 API reference pages \u2014 Material icons on headings, section dividers, \"See Also\" replaced with grid cards</li> <li>\ud83c\udfa8 Custom CSS \u2014 New styles for hero sections, card grids, tutorial components, and release notes UI</li> <li>\u2699\ufe0f MkDocs theme \u2014 Added template overrides, announcement bar, emoji extension, <code>md_in_html</code>, new navigation features</li> </ul>"},{"location":"release_notes/#readme-redesign","title":"\ud83d\uddbc\ufe0f README Redesign","text":"<p><code>README.md</code></p> <ul> <li>\ud83c\udfaf Centered HTML layout: logo, title, subtitle, and badge row</li> <li>\ud83d\udcca Features bullet list replaced with formatted table</li> <li>\ud83c\udd70\ufe0f\ud83c\udd71\ufe0f Quick Start restructured into \"Option A\" and \"Option B\" sections</li> <li>\ud83d\udee1\ufe0f New \"Schema Validators\" section with examples and mapping table</li> <li>\ud83d\udd04 \"Lifecycle Hooks\" bullet list replaced with table</li> <li>\ud83e\uddf9 Redundant sections removed, \"Buy me a coffee\" uses styled badge</li> </ul>"},{"location":"release_notes/#mkdocs-navigation-updates","title":"\ud83d\uddc2\ufe0f MkDocs Navigation Updates","text":"<p><code>mkdocs.yml</code></p> <ul> <li>\u2795 Added <code>tutorial/serializer.md</code> \u2014 \"Alternative: Define Your Serializer\"</li> <li>\u2795 Added <code>api/models/validators.md</code> \u2014 \"Validators\"</li> <li>\u2795 Added <code>api/renderers/orjson_renderer.md</code> \u2014 \"Renderers\"</li> </ul>"},{"location":"release_notes/#release-notes-page-redesign","title":"\ud83d\udd04 Release Notes Page Redesign","text":"<p><code>main.py</code></p> <p>Replaced table-based release notes layout with an interactive dropdown version selector and card-based display with human-readable date formatting.</p>"},{"location":"release_notes/#tests","title":"\ud83e\uddea Tests","text":"<p><code>tests/test_serializers.py</code>, <code>tests/test_app/models.py</code>, <code>tests/test_app/serializers.py</code></p>"},{"location":"release_notes/#validatorsonserializerstestcase-14-tests","title":"<code>ValidatorsOnSerializersTestCase</code> \u2014 14 tests","text":"<p>\ud83c\udfd7\ufe0f ModelSerializer validators:</p> Test Verifies <code>test_model_serializer_field_validator_rejects_invalid</code> \u274c <code>@field_validator</code> on <code>CreateSerializer</code> rejects input below min length <code>test_model_serializer_field_validator_accepts_valid</code> \u2705 <code>@field_validator</code> on <code>CreateSerializer</code> accepts valid input <code>test_model_serializer_update_validator_rejects_blank</code> \u274c <code>@field_validator</code> on <code>UpdateSerializer</code> rejects blank name <code>test_model_serializer_update_validator_accepts_valid</code> \u2705 <code>@field_validator</code> on <code>UpdateSerializer</code> accepts valid input <code>test_model_serializer_read_model_validator</code> \u2705 <code>@model_validator</code> on <code>ReadSerializer</code> is applied to output schema <code>test_model_serializer_no_validators_returns_plain_schema</code> \u2705 Serializers without validators still work normally <p>\ud83d\uddfa\ufe0f Meta-driven Serializer validators:</p> Test Verifies <code>test_meta_serializer_field_validator_rejects_invalid</code> \u274c <code>CreateValidators</code> <code>@field_validator</code> rejects invalid input <code>test_meta_serializer_field_validator_accepts_valid</code> \u2705 <code>CreateValidators</code> <code>@field_validator</code> accepts valid input <code>test_meta_serializer_update_validator_rejects_blank</code> \u274c <code>UpdateValidators</code> <code>@field_validator</code> rejects blank name <code>test_meta_serializer_read_model_validator</code> \u2705 <code>ReadValidators</code> <code>@model_validator</code> is applied to output schema <p>\ud83d\udd27 Utility method tests:</p> Test Verifies <code>test_collect_validators_returns_empty_for_none</code> \ud83d\udd0d <code>_collect_validators(None)</code> returns <code>{}</code> <code>test_collect_validators_returns_empty_for_no_validators</code> \ud83d\udd0d <code>_collect_validators</code> returns <code>{}</code> for class without validators <code>test_apply_validators_returns_none_for_none_schema</code> \ud83d\udd0d <code>_apply_validators(None, ...)</code> returns <code>None</code> <code>test_apply_validators_returns_schema_for_empty_validators</code> \ud83d\udd0d <code>_apply_validators(schema, {})</code> returns original schema <p>\ud83d\udce6 New test fixtures:</p> File Addition <code>tests/test_app/models.py</code> <code>TestModelWithValidators</code> \u2014 model with validators on <code>CreateSerializer</code>, <code>UpdateSerializer</code>, <code>ReadSerializer</code> <code>tests/test_app/serializers.py</code> <code>TestModelWithValidatorsMetaSerializer</code> \u2014 serializer with <code>CreateValidators</code>, <code>UpdateValidators</code>, <code>ReadValidators</code>"},{"location":"release_notes/#new-files","title":"\ud83d\udcc1 New Files","text":"File Description <code>CLAUDE.md</code> \ud83d\udccb Project instructions: overview, structure, tests, code style, architecture notes <code>CHANGELOG.md</code> \ud83d\udcdd Latest release notes"},{"location":"release_notes/#summary","title":"\ud83c\udfaf Summary","text":"<p>This release introduces Pydantic validators on serializers, allowing <code>@field_validator</code> and <code>@model_validator</code> to be declared directly on serializer configuration classes. The framework automatically collects and applies these validators to generated schemas. Additionally, the entire documentation site has been redesigned with Material for MkDocs components.</p> <p>\ud83c\udf1f Key benefits:</p> <ul> <li>\ud83d\udee1\ufe0f Schema-level validation \u2014 Enforce input constraints beyond Django model fields, running before data touches the database</li> <li>\ud83d\udd00 Per-operation validation \u2014 Apply different validation rules per CRUD operation (create vs. update vs. read)</li> <li>\ud83c\udfd7\ufe0f Both serializer patterns \u2014 Works with <code>ModelSerializer</code> (inner classes) and <code>Serializer</code> (<code>{Type}Validators</code> classes)</li> <li>\u267b\ufe0f Backwards compatible \u2014 Existing serializers without validators continue to work unchanged</li> <li>\ud83c\udfa8 Documentation redesign \u2014 Modern Material for MkDocs layout with grid cards, hero sections, and interactive release notes</li> </ul>"},{"location":"release_notes/#release-notes","title":"Release Notes","text":""},{"location":"release_notes/#v2170-2026-01-28","title":"[v2.17.0] - 2026-01-28","text":""},{"location":"release_notes/#new-features","title":"\u2728 New Features","text":"<ul> <li>Inline Custom Fields in <code>fields</code> List [<code>ninja_aio/models/serializers.py</code>]:</li> <li>Custom fields can now be defined directly in the <code>fields</code> list as tuples, providing a more concise syntax.</li> <li>Supports both 2-tuple <code>(name, type)</code> for required fields and 3-tuple <code>(name, type, default)</code> for optional fields.</li> <li>Works with both <code>ModelSerializer</code> (inner classes) and <code>Serializer</code> (Meta-driven) approaches.</li> <li>Applies to all serializer types: <code>CreateSerializer</code>, <code>ReadSerializer</code>, <code>DetailSerializer</code>, <code>UpdateSerializer</code>, and <code>SchemaModelConfig</code>.</li> </ul> <p>Usage example (ModelSerializer):   ```python   from ninja_aio.models import ModelSerializer</p> <p>class Article(ModelSerializer):       title = models.CharField(max_length=200)       content = models.TextField()</p> <pre><code>  class ReadSerializer:\n      fields = [\n          \"id\",\n          \"title\",\n          (\"word_count\", int, 0),        # 3-tuple: optional with default\n          (\"is_featured\", bool),          # 2-tuple: required field\n      ]\n</code></pre> <p>```</p> <p>Usage example (Serializer):   ```python   from ninja_aio.models import serializers</p> <p>class ArticleSerializer(serializers.Serializer):       class Meta:           model = Article           schema_out = serializers.SchemaModelConfig(               fields=[\"id\", \"title\", (\"reading_time\", int, 0)]           )   ```</p> <ul> <li>New <code>get_inline_customs()</code> Helper Method [<code>ninja_aio/models/serializers.py</code>]:</li> <li>Added <code>BaseSerializer.get_inline_customs(s_type)</code> method to extract and normalize inline custom tuples from the <code>fields</code> list.</li> <li>Returns a list of normalized 3-tuples <code>(name, type, default)</code>, converting 2-tuples by adding <code>...</code> (Ellipsis) as the default.</li> </ul>"},{"location":"release_notes/#improvements","title":"\ud83d\udd27 Improvements","text":"<ul> <li>Refactored <code>get_fields()</code> Method [<code>ninja_aio/models/serializers.py</code>]:</li> <li><code>get_fields()</code> now returns only string field names, excluding inline custom tuples.</li> <li> <p>Clearer separation of concerns between model fields and custom fields.</p> </li> <li> <p>Improved <code>get_related_schema_data()</code> Method [<code>ninja_aio/models/serializers.py</code>]:</p> </li> <li>Fixed handling of custom fields that don't exist as model attributes.</li> <li> <p>Custom fields (both explicit and inline) are now always included in related schemas since they are computed/synthetic.</p> </li> <li> <p>Updated <code>SchemaModelConfig</code> Type Annotations [<code>ninja_aio/models/serializers.py</code>]:</p> </li> <li>The <code>fields</code> attribute now accepts <code>List[str | tuple[str, Any, Any] | tuple[str, Any]]</code> to support inline customs.</li> <li> <p>Updated docstring to document the new tuple formats.</p> </li> <li> <p>Cleaner Schema Generation [<code>ninja_aio/models/serializers.py</code>]:</p> </li> <li><code>get_schema_out_data()</code> and <code>_generate_model_schema()</code> now use the new <code>get_inline_customs()</code> helper, reducing code duplication.</li> </ul>"},{"location":"release_notes/#tests","title":"\ud83e\uddea Tests","text":"<ul> <li>New Inline Customs Test Cases [<code>tests/test_serializers.py</code>]:</li> <li> <p>Added <code>InlineCustomsSerializerTestCase</code> test class with 11 tests for Meta-driven Serializer:</p> <ul> <li><code>test_serializer_read_schema_with_inline_customs_3_tuple</code>: Verifies 3-tuple inline customs work in read schema.</li> <li><code>test_serializer_read_schema_with_inline_customs_2_tuple</code>: Verifies 2-tuple inline customs work in read schema.</li> <li><code>test_serializer_create_schema_with_inline_customs</code>: Verifies inline customs in create schema.</li> <li><code>test_serializer_update_schema_with_inline_customs</code>: Verifies inline customs in update schema.</li> <li><code>test_serializer_inline_customs_combined_with_explicit_customs</code>: Verifies inline and explicit customs coexist.</li> <li><code>test_serializer_get_fields_excludes_inline_customs</code>: Verifies <code>get_fields()</code> returns only strings.</li> <li><code>test_serializer_get_inline_customs_returns_only_tuples</code>: Verifies <code>get_inline_customs()</code> returns normalized tuples.</li> <li><code>test_serializer_detail_schema_with_inline_customs</code>: Verifies inline customs in detail schema.</li> <li><code>test_serializer_related_schema_with_inline_customs</code>: Verifies inline customs in related schema.</li> <li><code>test_inline_customs_only_schema</code>: Verifies schema with only inline customs (no regular fields).</li> </ul> </li> <li> <p>Added <code>InlineCustomsModelSerializerTestCase</code> test class with 4 tests for ModelSerializer:</p> <ul> <li><code>test_model_serializer_read_schema_with_inline_customs</code>: Verifies inline customs in ReadSerializer.</li> <li><code>test_model_serializer_create_schema_with_inline_customs</code>: Verifies inline customs in CreateSerializer.</li> <li><code>test_model_serializer_get_inline_customs</code>: Verifies <code>get_inline_customs()</code> for ModelSerializer.</li> <li><code>test_model_serializer_get_fields_excludes_inline_customs</code>: Verifies <code>get_fields()</code> excludes inline customs.</li> </ul> </li> <li> <p>New Test Model [<code>tests/test_app/models.py</code>]:</p> </li> <li>Added <code>TestModelSerializerInlineCustoms</code> model with inline customs in both <code>ReadSerializer</code> and <code>CreateSerializer</code>.</li> </ul>"},{"location":"release_notes/#documentation","title":"\ud83d\udcda Documentation","text":"<ul> <li>Updated Serializer Documentation [<code>docs/api/models/serializers.md</code>]:</li> <li>Added new \"Inline Custom Fields\" section with usage examples.</li> <li>Updated <code>SchemaModelConfig</code> fields description to mention inline custom tuples.</li> <li> <p>Added explanation of 2-tuple and 3-tuple formats.</p> </li> <li> <p>Updated ModelSerializer Documentation [<code>docs/api/models/model_serializer.md</code>]:</p> </li> <li>Updated all serializer attribute tables to show <code>list[str | tuple]</code> type for <code>fields</code>.</li> <li>Added \"Inline Custom Fields\" subsection in CreateSerializer with usage example.</li> <li>Updated ReadSerializer, DetailSerializer, and UpdateSerializer tables.</li> </ul>"},{"location":"release_notes/#summary","title":"\ud83d\udccb Summary","text":"<p>This minor release introduces inline custom field support, allowing custom/computed fields to be defined directly in the <code>fields</code> list as tuples. This provides a more concise syntax for simple custom fields while maintaining full backwards compatibility with the separate <code>customs</code> list approach.</p>"},{"location":"release_notes/#key-benefits","title":"Key Benefits","text":"<ul> <li>Concise syntax: Define simple custom fields inline without a separate <code>customs</code> list</li> <li>Flexibility: Mix regular fields and custom tuples in the same list</li> <li>Backwards compatible: Existing code using <code>customs</code> list continues to work unchanged</li> </ul>"},{"location":"release_notes/#files-changed","title":"Files Changed","text":"File Changes <code>ninja_aio/models/serializers.py</code> Added <code>get_inline_customs()</code> method, updated <code>get_fields()</code>, <code>get_schema_out_data()</code>, <code>_generate_model_schema()</code>, <code>get_related_schema_data()</code>, and <code>SchemaModelConfig</code> <code>tests/test_serializers.py</code> Added 15 new tests across 2 test classes <code>tests/test_app/models.py</code> Added <code>TestModelSerializerInlineCustoms</code> test model <code>docs/api/models/serializers.md</code> Added inline custom fields documentation with examples <code>docs/api/models/model_serializer.md</code> Updated all serializer attribute tables and added inline customs section"},{"location":"release_notes/#release-notes","title":"Release Notes","text":""},{"location":"release_notes/#v2162-2026-01-27","title":"[v2.16.2] - 2026-01-27","text":""},{"location":"release_notes/#bug-fixes","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>Fixed Schema Generation with Only Custom Fields [<code>ninja_aio/models/serializers.py</code>]:</li> <li>Fixed an issue in <code>_generate_model_schema()</code> where defining only <code>customs</code> and/or <code>optionals</code> (without explicit <code>fields</code> or <code>excludes</code>) would incorrectly include all model fields in the generated schema.</li> <li>When only custom fields are defined, the schema now correctly excludes all concrete model fields, returning a schema with only the specified custom fields.</li> <li>This fix applies to both <code>Serializer</code> (Meta-driven) and <code>ModelSerializer</code> create/update schema generation.</li> </ul> <p>Before (broken behavior):   ```python   class MySerializer(Serializer):       class Meta:           model = MyModel           schema_in = SchemaModelConfig(               customs=[(\"custom_input\", str, ...)]           )</p> <p># Generated schema incorrectly included ALL model fields + custom_input   ```</p> <p>After (fixed behavior):   ```python   class MySerializer(Serializer):       class Meta:           model = MyModel           schema_in = SchemaModelConfig(               customs=[(\"custom_input\", str, ...)]           )</p> <p># Generated schema now correctly includes ONLY custom_input   ```</p>"},{"location":"release_notes/#improvements","title":"\ud83d\udd27 Improvements","text":"<ul> <li>Union Type Support in SchemaModelConfig [<code>ninja_aio/models/serializers.py</code>]:</li> <li>Updated <code>optionals</code> and <code>customs</code> field type hints in <code>SchemaModelConfig</code> to accept <code>Any</code> instead of <code>type</code>.</li> <li>This allows using Union types and other complex type annotations in schema configurations.</li> </ul> <p>Usage example:   ```python   from typing import Union</p> <p>schema_in = SchemaModelConfig(       optionals=[(\"status\", str | None)],       customs=[           (\"data\", Union[str, int], None),           (\"items\", list[int], []),       ],   )   ```</p>"},{"location":"release_notes/#tests","title":"\ud83e\uddea Tests","text":"<ul> <li>New Custom Fields Schema Tests [<code>tests/test_serializers.py</code>]:</li> <li>Added <code>CustomsOnlySchemaTestCase</code> test class with 7 new tests:<ul> <li><code>test_serializer_create_schema_with_only_customs</code>: Verifies create schema with only customs excludes model fields.</li> <li><code>test_serializer_update_schema_with_only_customs</code>: Verifies update schema with only customs excludes model fields.</li> <li><code>test_serializer_create_schema_with_customs_and_optionals</code>: Verifies customs + optionals includes only those fields.</li> <li><code>test_serializer_with_fields_still_works</code>: Confirms explicit fields behavior is preserved.</li> <li><code>test_serializer_with_only_excludes_and_customs</code>: Documents behavior when excludes defined without fields.</li> <li><code>test_serializer_empty_schema_returns_none</code>: Verifies empty schema returns None.</li> <li><code>test_serializer_multiple_customs_no_model_fields</code>: Verifies multiple customs work without model fields.</li> </ul> </li> </ul>"},{"location":"release_notes/#summary","title":"\ud83d\udccb Summary","text":"<p>This patch release fixes a bug where schemas defined with only custom fields would incorrectly include all model fields, and adds support for Union types in <code>SchemaModelConfig</code> field definitions.</p>"},{"location":"release_notes/#files-changed","title":"Files Changed","text":"File Changes <code>ninja_aio/models/serializers.py</code> Fixed <code>_generate_model_schema()</code> to exclude all model fields when only customs are defined; updated <code>SchemaModelConfig</code> type hints to allow Union types <code>tests/test_serializers.py</code> Added 7 new tests in <code>CustomsOnlySchemaTestCase</code> <code>ninja_aio/__init__.py</code> Bumped version to 2.16.2"},{"location":"release_notes/#v2160-2026-01-26","title":"[v2.16.0] - 2026-01-26","text":""},{"location":"release_notes/#new-features","title":"\u2728 New Features","text":"<ul> <li>Custom Decorators for M2M Relation Endpoints [<code>ninja_aio/schemas/helpers.py</code>, <code>ninja_aio/helpers/api.py</code>]:</li> <li>Added <code>get_decorators</code> field to <code>M2MRelationSchema</code> for applying custom decorators to GET (list related objects) endpoints.</li> <li>Added <code>post_decorators</code> field to <code>M2MRelationSchema</code> for applying custom decorators to POST (add/remove) endpoints.</li> <li>Decorators are unpacked and applied via <code>decorate_view()</code> alongside existing decorators like <code>unique_view</code> and <code>paginate</code>.</li> <li>Enables use cases such as rate limiting, caching, custom authentication, logging, or any other decorator-based middleware on M2M endpoints.</li> </ul> <p>Usage example:   ```python   from ninja_aio.schemas import M2MRelationSchema</p> <p>M2MRelationSchema(       model=RelatedModel,       related_name=\"related_items\",       get_decorators=[cache_decorator, log_decorator],       post_decorators=[rate_limit_decorator],   )   ```</p>"},{"location":"release_notes/#improvements_1","title":"\ud83d\udd27 Improvements","text":"<ul> <li>Refactored Manage Relation View Registration [<code>ninja_aio/helpers/api.py</code>]:</li> <li>Updated <code>_register_manage_relation_view()</code> to use <code>decorate_view()</code> wrapper instead of direct <code>@unique_view</code> decorator.</li> <li>Ensures consistent decorator application pattern between GET and POST endpoints.</li> <li> <p>Allows decorator spreading via <code>*decorators</code> for extensibility.</p> </li> <li> <p>Improved Type Hints [<code>ninja_aio/schemas/helpers.py</code>]:</p> </li> <li>Added <code>Callable</code> import from typing module.</li> <li>Updated <code>get_decorators</code> and <code>post_decorators</code> type hints to <code>Optional[List[Callable]]</code> for better IDE support and type checking.</li> </ul>"},{"location":"release_notes/#tests_1","title":"\ud83e\uddea Tests","text":"<ul> <li>New Decorator Integration Tests [<code>tests/helpers/test_many_to_many_api.py</code>]:</li> <li>Added <code>M2MRelationSchemaDecoratorsTestCase</code> test class with integration tests:<ul> <li><code>test_get_decorator_is_applied</code>: Verifies GET decorators are invoked on list endpoint calls.</li> <li><code>test_post_decorator_is_applied</code>: Verifies POST decorators are invoked on add/remove endpoint calls.</li> <li><code>test_decorators_independent</code>: Confirms GET and POST decorators operate independently.</li> </ul> </li> <li> <p>Added <code>TestM2MWithDecoratorsViewSet</code> test viewset demonstrating decorator usage.</p> </li> <li> <p>New Decorator Schema Validation Tests [<code>tests/helpers/test_many_to_many_api.py</code>]:</p> </li> <li>Added <code>M2MRelationSchemaDecoratorsFieldTestCase</code> test class with schema field tests:<ul> <li><code>test_decorators_default_to_empty_list</code>: Validates default empty list behavior.</li> <li><code>test_decorators_accept_list_of_callables</code>: Validates callable list acceptance.</li> <li><code>test_decorators_can_be_none</code>: Validates explicit <code>None</code> assignment.</li> </ul> </li> </ul>"},{"location":"release_notes/#documentation","title":"\ud83d\udcda Documentation","text":"<ul> <li>Updated APIViewSet Documentation [<code>docs/api/views/api_view_set.md</code>]:</li> <li>Added <code>get_decorators</code> and <code>post_decorators</code> to M2MRelationSchema attributes list.</li> <li>Added comprehensive example showing custom decorator usage with M2M relations (cache and rate limiting patterns).</li> <li> <p>Added note explaining decorator application order and interaction with built-in decorators.</p> </li> <li> <p>Updated Decorators Documentation [<code>docs/api/views/decorators.md</code>]:</p> </li> <li>Added new \"M2MRelationSchema decorators\" section.</li> <li> <p>Included usage example and cross-reference to APIViewSet M2M Relations documentation.</p> </li> <li> <p>Split Quick Start into Two Guides:</p> </li> <li>[<code>docs/getting_started/quick_start.md</code>]: Dedicated to <code>ModelSerializer</code> approach with embedded serializer configuration.</li> <li>[<code>docs/getting_started/quick_start_serializer.md</code>]: New guide for <code>Serializer</code> approach with plain Django models, including examples for relationships, query optimization, and lifecycle hooks.</li> </ul>"},{"location":"release_notes/#summary_1","title":"\ud83d\udccb Summary","text":"<p>This minor release introduces custom decorator support for Many-to-Many relation endpoints. Users can now apply custom decorators independently to GET and POST M2M endpoints via the new <code>get_decorators</code> and <code>post_decorators</code> fields in <code>M2MRelationSchema</code>. This enables flexible middleware patterns such as caching, rate limiting, and custom logging on relation endpoints.</p>"},{"location":"release_notes/#files-changed_1","title":"Files Changed","text":"File Changes <code>ninja_aio/schemas/helpers.py</code> Added <code>get_decorators</code> and <code>post_decorators</code> fields with <code>Callable</code> type hints <code>ninja_aio/helpers/api.py</code> Updated view registration to accept and apply custom decorators <code>tests/helpers/test_many_to_many_api.py</code> Added 6 new tests across 2 test classes <code>docs/api/views/api_view_set.md</code> Documented M2M decorator fields with usage examples <code>docs/api/views/decorators.md</code> Added M2MRelationSchema decorators section <code>docs/getting_started/quick_start.md</code> Dedicated to ModelSerializer approach <code>docs/getting_started/quick_start_serializer.md</code> New guide for Serializer approach with plain Django models <code>mkdocs.yml</code> Updated navigation with two Quick Start guides"},{"location":"release_notes/#release-notes","title":"Release Notes","text":""},{"location":"release_notes/#v2161-2026-01-27","title":"[v2.16.1] - 2026-01-27","text":""},{"location":"release_notes/#bug-fixes","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>Fixed Schema Generation with Only Custom Fields [<code>ninja_aio/models/serializers.py</code>]:</li> <li>Fixed an issue in <code>_generate_model_schema()</code> where defining only <code>customs</code> and/or <code>optionals</code> (without explicit <code>fields</code> or <code>excludes</code>) would incorrectly include all model fields in the generated schema.</li> <li>When only custom fields are defined, the schema now correctly excludes all concrete model fields, returning a schema with only the specified custom fields.</li> <li>This fix applies to both <code>Serializer</code> (Meta-driven) and <code>ModelSerializer</code> create/update schema generation.</li> </ul> <p>Before (broken behavior):   ```python   class MySerializer(Serializer):       class Meta:           model = MyModel           schema_in = SchemaModelConfig(               customs=[(\"custom_input\", str, ...)]           )</p> <p># Generated schema incorrectly included ALL model fields + custom_input   ```</p> <p>After (fixed behavior):   ```python   class MySerializer(Serializer):       class Meta:           model = MyModel           schema_in = SchemaModelConfig(               customs=[(\"custom_input\", str, ...)]           )</p> <p># Generated schema now correctly includes ONLY custom_input   ```</p>"},{"location":"release_notes/#tests","title":"\ud83e\uddea Tests","text":"<ul> <li>New Custom Fields Schema Tests [<code>tests/test_serializers.py</code>]:</li> <li>Added <code>CustomsOnlySchemaTestCase</code> test class with 7 new tests:<ul> <li><code>test_serializer_create_schema_with_only_customs</code>: Verifies create schema with only customs excludes model fields.</li> <li><code>test_serializer_update_schema_with_only_customs</code>: Verifies update schema with only customs excludes model fields.</li> <li><code>test_serializer_create_schema_with_customs_and_optionals</code>: Verifies customs + optionals includes only those fields.</li> <li><code>test_serializer_with_fields_still_works</code>: Confirms explicit fields behavior is preserved.</li> <li><code>test_serializer_with_only_excludes_and_customs</code>: Documents behavior when excludes defined without fields.</li> <li><code>test_serializer_empty_schema_returns_none</code>: Verifies empty schema returns None.</li> <li><code>test_serializer_multiple_customs_no_model_fields</code>: Verifies multiple customs work without model fields.</li> </ul> </li> </ul>"},{"location":"release_notes/#summary","title":"\ud83d\udccb Summary","text":"<p>This patch release fixes a bug where schemas defined with only custom fields would incorrectly include all model fields. The fix ensures that when only <code>customs</code> are specified (without <code>fields</code> or <code>excludes</code>), the generated schema contains only the custom fields as intended.</p>"},{"location":"release_notes/#files-changed","title":"Files Changed","text":"File Changes <code>ninja_aio/models/serializers.py</code> Fixed <code>_generate_model_schema()</code> to exclude all model fields when only customs are defined <code>tests/test_serializers.py</code> Added 7 new tests in <code>CustomsOnlySchemaTestCase</code> <code>ninja_aio/__init__.py</code> Bumped version to 2.16.1"},{"location":"release_notes/#v2160-2026-01-26","title":"[v2.16.0] - 2026-01-26","text":""},{"location":"release_notes/#new-features","title":"\u2728 New Features","text":"<ul> <li>Custom Decorators for M2M Relation Endpoints [<code>ninja_aio/schemas/helpers.py</code>, <code>ninja_aio/helpers/api.py</code>]:</li> <li>Added <code>get_decorators</code> field to <code>M2MRelationSchema</code> for applying custom decorators to GET (list related objects) endpoints.</li> <li>Added <code>post_decorators</code> field to <code>M2MRelationSchema</code> for applying custom decorators to POST (add/remove) endpoints.</li> <li>Decorators are unpacked and applied via <code>decorate_view()</code> alongside existing decorators like <code>unique_view</code> and <code>paginate</code>.</li> <li>Enables use cases such as rate limiting, caching, custom authentication, logging, or any other decorator-based middleware on M2M endpoints.</li> </ul> <p>Usage example:   ```python   from ninja_aio.schemas import M2MRelationSchema</p> <p>M2MRelationSchema(       model=RelatedModel,       related_name=\"related_items\",       get_decorators=[cache_decorator, log_decorator],       post_decorators=[rate_limit_decorator],   )   ```</p>"},{"location":"release_notes/#improvements","title":"\ud83d\udd27 Improvements","text":"<ul> <li>Refactored Manage Relation View Registration [<code>ninja_aio/helpers/api.py</code>]:</li> <li>Updated <code>_register_manage_relation_view()</code> to use <code>decorate_view()</code> wrapper instead of direct <code>@unique_view</code> decorator.</li> <li>Ensures consistent decorator application pattern between GET and POST endpoints.</li> <li> <p>Allows decorator spreading via <code>*decorators</code> for extensibility.</p> </li> <li> <p>Improved Type Hints [<code>ninja_aio/schemas/helpers.py</code>]:</p> </li> <li>Added <code>Callable</code> import from typing module.</li> <li>Updated <code>get_decorators</code> and <code>post_decorators</code> type hints to <code>Optional[List[Callable]]</code> for better IDE support and type checking.</li> </ul>"},{"location":"release_notes/#tests_1","title":"\ud83e\uddea Tests","text":"<ul> <li>New Decorator Integration Tests [<code>tests/helpers/test_many_to_many_api.py</code>]:</li> <li>Added <code>M2MRelationSchemaDecoratorsTestCase</code> test class with integration tests:<ul> <li><code>test_get_decorator_is_applied</code>: Verifies GET decorators are invoked on list endpoint calls.</li> <li><code>test_post_decorator_is_applied</code>: Verifies POST decorators are invoked on add/remove endpoint calls.</li> <li><code>test_decorators_independent</code>: Confirms GET and POST decorators operate independently.</li> </ul> </li> <li> <p>Added <code>TestM2MWithDecoratorsViewSet</code> test viewset demonstrating decorator usage.</p> </li> <li> <p>New Decorator Schema Validation Tests [<code>tests/helpers/test_many_to_many_api.py</code>]:</p> </li> <li>Added <code>M2MRelationSchemaDecoratorsFieldTestCase</code> test class with schema field tests:<ul> <li><code>test_decorators_default_to_empty_list</code>: Validates default empty list behavior.</li> <li><code>test_decorators_accept_list_of_callables</code>: Validates callable list acceptance.</li> <li><code>test_decorators_can_be_none</code>: Validates explicit <code>None</code> assignment.</li> </ul> </li> </ul>"},{"location":"release_notes/#documentation","title":"\ud83d\udcda Documentation","text":"<ul> <li>Updated APIViewSet Documentation [<code>docs/api/views/api_view_set.md</code>]:</li> <li>Added <code>get_decorators</code> and <code>post_decorators</code> to M2MRelationSchema attributes list.</li> <li>Added comprehensive example showing custom decorator usage with M2M relations (cache and rate limiting patterns).</li> <li> <p>Added note explaining decorator application order and interaction with built-in decorators.</p> </li> <li> <p>Updated Decorators Documentation [<code>docs/api/views/decorators.md</code>]:</p> </li> <li>Added new \"M2MRelationSchema decorators\" section.</li> <li> <p>Included usage example and cross-reference to APIViewSet M2M Relations documentation.</p> </li> <li> <p>Split Quick Start into Two Guides:</p> </li> <li>[<code>docs/getting_started/quick_start.md</code>]: Dedicated to <code>ModelSerializer</code> approach with embedded serializer configuration.</li> <li>[<code>docs/getting_started/quick_start_serializer.md</code>]: New guide for <code>Serializer</code> approach with plain Django models, including examples for relationships, query optimization, and lifecycle hooks.</li> </ul>"},{"location":"release_notes/#summary_1","title":"\ud83d\udccb Summary","text":"<p>This minor release introduces custom decorator support for Many-to-Many relation endpoints. Users can now apply custom decorators independently to GET and POST M2M endpoints via the new <code>get_decorators</code> and <code>post_decorators</code> fields in <code>M2MRelationSchema</code>. This enables flexible middleware patterns such as caching, rate limiting, and custom logging on relation endpoints.</p>"},{"location":"release_notes/#files-changed_1","title":"Files Changed","text":"File Changes <code>ninja_aio/schemas/helpers.py</code> Added <code>get_decorators</code> and <code>post_decorators</code> fields with <code>Callable</code> type hints <code>ninja_aio/helpers/api.py</code> Updated view registration to accept and apply custom decorators <code>tests/helpers/test_many_to_many_api.py</code> Added 6 new tests across 2 test classes <code>docs/api/views/api_view_set.md</code> Documented M2M decorator fields with usage examples <code>docs/api/views/decorators.md</code> Added M2MRelationSchema decorators section <code>docs/getting_started/quick_start.md</code> Dedicated to ModelSerializer approach <code>docs/getting_started/quick_start_serializer.md</code> New guide for Serializer approach with plain Django models <code>mkdocs.yml</code> Updated navigation with two Quick Start guides"},{"location":"release_notes/#release-notes","title":"Release Notes","text":""},{"location":"release_notes/#v2150-2026-01-22","title":"[v2.15.0] - 2026-01-22","text":""},{"location":"release_notes/#new-features","title":"New Features","text":"<ul> <li>Dynamic PK Type Detection for <code>relations_as_id</code> [<code>ninja_aio/models/serializers.py</code>]:</li> <li>The <code>PkFromModel</code> type now automatically detects and uses the related model's primary key type.</li> <li>Supports <code>int</code> (default), <code>UUID</code>, <code>str</code> (CharField), and any other Django primary key type.</li> <li>Schema generation now correctly annotates relation fields with the appropriate PK type.</li> </ul>"},{"location":"release_notes/#improvements","title":"Improvements","text":"<ul> <li><code>PkFromModel</code> Subscriptable Type [<code>ninja_aio/models/serializers.py</code>]:</li> <li>New <code>PkFromModel[type]</code> syntax allows explicit PK type specification.</li> <li>Examples: <code>PkFromModel[int]</code>, <code>PkFromModel[UUID]</code>, <code>PkFromModel[str]</code>.</li> <li>Falls back to <code>int</code> when used without subscription (backwards compatible).</li> <li>Uses <code>BeforeValidator</code> to extract <code>pk</code> attribute during Pydantic serialization.</li> </ul>"},{"location":"release_notes/#tests","title":"Tests","text":"<ul> <li>Comprehensive Test Coverage for Different PK Types [<code>tests/test_serializers.py</code>]:</li> <li>Added <code>RelationsAsIdUUIDModelSerializerTestCase</code> (6 tests) - Schema generation tests for UUID PKs</li> <li>Added <code>RelationsAsIdUUIDIntegrationTestCase</code> (7 tests) - Integration tests with UUID PK data</li> <li>Added <code>RelationsAsIdStringPKModelSerializerTestCase</code> (6 tests) - Schema generation tests for string PKs</li> <li>Added <code>RelationsAsIdStringPKIntegrationTestCase</code> (7 tests) - Integration tests with string PK data</li> <li> <p>Coverage includes all relation types: Forward FK, Reverse FK, Forward O2O, Reverse O2O, Forward M2M, Reverse M2M</p> </li> <li> <p>New Test Models with Different PK Types [<code>tests/test_app/models.py</code>]:</p> </li> <li>UUID PK models: <code>AuthorUUID</code>, <code>BookUUID</code>, <code>ProfileUUID</code>, <code>UserUUID</code>, <code>TagUUID</code>, <code>ArticleUUID</code></li> <li>String PK models: <code>AuthorStringPK</code>, <code>BookStringPK</code>, <code>ProfileStringPK</code>, <code>UserStringPK</code>, <code>TagStringPK</code>, <code>ArticleStringPK</code></li> </ul>"},{"location":"release_notes/#documentation","title":"Documentation","text":"<ul> <li>ModelSerializer Documentation [<code>docs/api/models/model_serializer.md</code>]:</li> <li>Updated <code>relations_as_id</code> table to show <code>PK_TYPE</code> instead of hardcoded <code>int</code>.</li> <li>Added note explaining automatic PK type detection.</li> <li> <p>Added UUID primary key example with code and JSON output.</p> </li> <li> <p>Serializer Documentation [<code>docs/api/models/serializers.md</code>]:</p> </li> <li>Updated <code>relations_as_id</code> table to show <code>PK_TYPE</code> instead of hardcoded <code>int</code>.</li> <li>Added note explaining automatic PK type detection.</li> <li>Added UUID primary key example with code and JSON output.</li> </ul>"},{"location":"release_notes/#usage-example","title":"Usage Example","text":""},{"location":"release_notes/#uuid-primary-key-with-relations_as_id","title":"UUID Primary Key with <code>relations_as_id</code>","text":"<pre><code>import uuid\nfrom django.db import models\nfrom ninja_aio.models import ModelSerializer\n\nclass Author(ModelSerializer):\n    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\n    name = models.CharField(max_length=200)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"books\"]\n        relations_as_id = [\"books\"]  # Reverse FK as list of UUIDs\n\nclass Book(ModelSerializer):\n    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\n    title = models.CharField(max_length=200)\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"books\")\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"author\"]\n        relations_as_id = [\"author\"]  # Forward FK as UUID\n</code></pre> <p>Output (Author with UUID PK):</p> <pre><code>{\n  \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"name\": \"J.K. Rowling\",\n  \"books\": [\n    \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\",\n    \"6ba7b811-9dad-11d1-80b4-00c04fd430c8\"\n  ]\n}\n</code></pre> <p>Output (Book with UUID PK):</p> <pre><code>{\n  \"id\": \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\",\n  \"title\": \"Harry Potter\",\n  \"author\": \"550e8400-e29b-41d4-a716-446655440000\"\n}\n</code></pre>"},{"location":"release_notes/#string-primary-key-with-relations_as_id","title":"String Primary Key with <code>relations_as_id</code>","text":"<pre><code>from django.db import models\nfrom ninja_aio.models import ModelSerializer\n\nclass Author(ModelSerializer):\n    id = models.CharField(primary_key=True, max_length=50)\n    name = models.CharField(max_length=200)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"books\"]\n        relations_as_id = [\"books\"]\n\nclass Book(ModelSerializer):\n    id = models.CharField(primary_key=True, max_length=50)\n    title = models.CharField(max_length=200)\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"books\")\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"author\"]\n        relations_as_id = [\"author\"]\n</code></pre> <p>Output (Author with String PK):</p> <pre><code>{\n  \"id\": \"author-001\",\n  \"name\": \"J.K. Rowling\",\n  \"books\": [\"book-001\", \"book-002\", \"book-003\"]\n}\n</code></pre> <p>Output (Book with String PK):</p> <pre><code>{\n  \"id\": \"book-001\",\n  \"title\": \"Harry Potter\",\n  \"author\": \"author-001\"\n}\n</code></pre>"},{"location":"release_notes/#release-notes","title":"Release Notes","text":""},{"location":"release_notes/#v2140-2026-01-22","title":"[v2.14.0] - 2026-01-22","text":""},{"location":"release_notes/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Forward Relations in <code>relations_as_id</code> Now Work Correctly [<code>ninja_aio/models/serializers.py</code>]:</li> <li>Fixed issue where forward FK and O2O relations listed in <code>relations_as_id</code> were serialized as <code>null</code> instead of the related object's ID.</li> <li>Root Cause: Previously used <code>validation_alias</code> which only affects input parsing, not output serialization.</li> <li>Solution: Now uses <code>PkFromModel</code> with <code>BeforeValidator</code> to extract the primary key during serialization, consistent with reverse relations.</li> <li>Affects: Forward ForeignKey, Forward OneToOneField.</li> </ul>"},{"location":"release_notes/#improvements","title":"\ud83d\udd27 Improvements","text":"<ul> <li>Optimized <code>relations_as_id</code> Processing [<code>ninja_aio/models/serializers.py</code>]:</li> <li><code>_get_relations_as_id()</code> is now called once in <code>get_schema_out_data()</code> and passed through to child methods, eliminating redundant method calls during schema generation.</li> <li> <p><code>_build_schema_reverse_rel()</code>, <code>_build_schema_forward_rel()</code>, and <code>_process_field()</code> now accept <code>relations_as_id</code> as a parameter instead of fetching it independently.</p> </li> <li> <p>Enhanced Method Documentation [<code>ninja_aio/models/serializers.py</code>]:</p> </li> <li>Added comprehensive docstrings with parameter descriptions to:<ul> <li><code>_build_schema_reverse_rel()</code> - Documents descriptor types and return values</li> <li><code>_build_schema_forward_rel()</code> - Documents forward relation handling logic</li> <li><code>_process_field()</code> - Documents field classification process</li> <li><code>get_schema_out_data()</code> - Documents schema component collection</li> </ul> </li> </ul>"},{"location":"release_notes/#tests","title":"\ud83e\uddea Tests","text":"<ul> <li>Comprehensive Test Coverage for <code>relations_as_id</code> [<code>tests/test_serializers.py</code>]:</li> <li>Added <code>RelationsAsIdModelSerializerTestCase</code> (6 tests) - Schema generation tests for ModelSerializer</li> <li>Added <code>RelationsAsIdSerializerTestCase</code> (6 tests) - Schema generation tests for Meta-driven Serializer</li> <li>Added <code>RelationsAsIdIntegrationTestCase</code> (7 tests) - Integration tests with actual data serialization</li> <li>Coverage includes all relation types: Forward FK, Reverse FK, Forward O2O, Reverse O2O, Forward M2M, Reverse M2M</li> <li> <p>Tests null value handling for nullable forward relations</p> </li> <li> <p>New Test Models [<code>tests/test_app/models.py</code>]:</p> </li> <li><code>AuthorAsId</code>, <code>BookAsId</code> - FK relation testing</li> <li><code>ProfileAsId</code>, <code>UserAsId</code> - O2O relation testing</li> <li> <p><code>TagAsId</code>, <code>ArticleAsId</code> - M2M relation testing</p> </li> <li> <p>New Test Serializers [<code>tests/test_app/serializers.py</code>]:</p> </li> <li><code>BookAsIdMetaSerializer</code>, <code>AuthorAsIdMetaSerializer</code> - FK with Meta-driven Serializer</li> <li><code>UserAsIdMetaSerializer</code>, <code>ProfileAsIdMetaSerializer</code> - O2O with Meta-driven Serializer</li> <li><code>ArticleAsIdMetaSerializer</code>, <code>TagAsIdMetaSerializer</code> - M2M with Meta-driven Serializer</li> </ul>"},{"location":"release_notes/#documentation","title":"\ud83d\udcd6 Documentation","text":"<ul> <li>ModelSerializer Documentation [<code>docs/api/models/model_serializer.md</code>]:</li> <li>Added <code>relations_as_id</code> attribute to <code>ReadSerializer</code> attributes table.</li> <li> <p>Added new \"Relations as ID\" section with:</p> <ul> <li>Use cases (payload size, circular serialization, performance, API design)</li> <li>Supported relations table with output types</li> <li>FK, O2O, and M2M examples with JSON output</li> <li>Query optimization note for <code>select_related</code>/<code>prefetch_related</code></li> </ul> </li> <li> <p>Serializer Documentation [<code>docs/api/models/serializers.md</code>]:</p> </li> <li>Added <code>relations_as_id</code> to Meta configuration options.</li> <li>Added new \"Relations as ID\" section with:<ul> <li>Complete examples for FK, O2O, and M2M relations</li> <li>Guide for combining <code>relations_as_id</code> with <code>relations_serializers</code></li> <li>Query optimization recommendations</li> </ul> </li> </ul>"},{"location":"release_notes/#usage-example","title":"\ud83d\udca1 Usage Example","text":""},{"location":"release_notes/#modelserializer-with-relations_as_id","title":"ModelSerializer with <code>relations_as_id</code>","text":"<pre><code>from ninja_aio.models import ModelSerializer\nfrom django.db import models\n\nclass Author(ModelSerializer):\n    name = models.CharField(max_length=200)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"books\"]\n        relations_as_id = [\"books\"]  # Reverse FK as list of IDs\n\nclass Book(ModelSerializer):\n    title = models.CharField(max_length=200)\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"books\")\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"author\"]\n        relations_as_id = [\"author\"]  # Forward FK as ID\n</code></pre> <p>Output (Author):</p> <pre><code>{\n  \"id\": 1,\n  \"name\": \"J.K. Rowling\",\n  \"books\": [1, 2, 3]\n}\n</code></pre> <p>Output (Book):</p> <pre><code>{\n  \"id\": 1,\n  \"title\": \"Harry Potter\",\n  \"author\": 1\n}\n</code></pre>"},{"location":"release_notes/#meta-driven-serializer-with-relations_as_id","title":"Meta-driven Serializer with <code>relations_as_id</code>","text":"<pre><code>from ninja_aio.models import serializers\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = Article\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"author\", \"tags\"]\n        )\n        relations_serializers = {\n            \"author\": AuthorSerializer,  # Nested object\n        }\n        relations_as_id = [\"tags\"]  # M2M as list of IDs\n\n    class QuerySet:\n        read = ModelQuerySetSchema(\n            select_related=[\"author\"],\n            prefetch_related=[\"tags\"],\n        )\n</code></pre> <p>Output:</p> <pre><code>{\n  \"id\": 1,\n  \"title\": \"Getting Started with Django\",\n  \"author\": {\"id\": 1, \"name\": \"John Doe\"},\n  \"tags\": [1, 2, 5]\n}\n</code></pre>"},{"location":"release_notes/#release-notes","title":"Release Notes","text":""},{"location":"release_notes/#v2130-2026-01-21","title":"[v2.13.0] - 2026-01-21","text":""},{"location":"release_notes/#added","title":"\u2728 Added","text":"<ul> <li><code>verbose_name_plural</code> Attribute for M2MRelationSchema [<code>ninja_aio/schemas/helpers.py</code>]:</li> <li>New optional <code>verbose_name_plural</code> field allows customizing the human-readable plural name for M2M relation endpoints.</li> <li>When provided, used in endpoint summaries and descriptions (e.g., <code>\"Get Article Tags\"</code>, <code>\"Add or Remove Article Tags\"</code>).</li> <li>Falls back to <code>model._meta.verbose_name_plural.capitalize()</code> when not specified.</li> </ul>"},{"location":"release_notes/#improvements","title":"\ud83d\udd27 Improvements","text":"<ul> <li>Refactored M2M Endpoint Summary Generation [<code>ninja_aio/helpers/api.py</code>]:</li> <li><code>_register_get_relation_view()</code> now accepts <code>verbose_name_plural</code> parameter instead of computing it internally.</li> <li><code>_register_manage_relation_view()</code> simplified by removing <code>rel_util</code> parameter; now receives <code>verbose_name_plural</code> directly.</li> <li><code>_build_views()</code> centralizes verbose name resolution with fallback logic.</li> <li> <p>Cleaner separation of concerns: verbose name is resolved once and passed to both GET and POST registration methods.</p> </li> <li> <p>Simplified Warning Logic for Missing Relation Serializers [<code>ninja_aio/models/serializers.py</code>]:</p> </li> <li><code>_warn_missing_relation_serializer()</code> now uses simpler boolean logic.</li> <li>Warnings emit when model is not a <code>ModelSerializer</code> and <code>NINJA_AIO_RAISE_SERIALIZATION_WARNINGS</code> is <code>True</code> (default).</li> <li>Removed dependency on <code>NINJA_AIO_TESTING</code> setting for warning control.</li> </ul>"},{"location":"release_notes/#documentation","title":"\ud83d\udcd6 Documentation","text":"<ul> <li>Updated M2MRelationSchema Documentation [<code>docs/api/views/api_view_set.md</code>]:</li> <li>Added <code>verbose_name_plural</code> to the list of M2MRelationSchema attributes.</li> <li>Added usage example demonstrating custom verbose names for M2M endpoints.</li> </ul>"},{"location":"release_notes/#usage-example","title":"\ud83d\udca1 Usage Example","text":""},{"location":"release_notes/#custom-verbose-names-for-m2m-endpoints","title":"Custom Verbose Names for M2M Endpoints","text":"<pre><code>from ninja_aio.views import APIViewSet\nfrom ninja_aio.schemas.helpers import M2MRelationSchema\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    m2m_relations = [\n        M2MRelationSchema(\n            model=Tag,\n            related_name=\"tags\",\n            verbose_name_plural=\"Article Tags\",  # Custom name\n            add=True,\n            remove=True,\n            get=True,\n        ),\n        M2MRelationSchema(\n            model=Category,\n            related_name=\"categories\",\n            # Uses default: \"Categories\" (from model._meta.verbose_name_plural)\n            get=True,\n        ),\n    ]\n</code></pre> <p>Generated Endpoint Summaries: - <code>GET /articles/{pk}/tags</code> \u2192 Summary: \"Get Article Tags\" - <code>POST /articles/{pk}/tags/</code> \u2192 Summary: \"Add or Remove Article Tags\" - <code>GET /articles/{pk}/categories</code> \u2192 Summary: \"Get Categories\"</p>"},{"location":"release_notes/#release-notes","title":"Release Notes","text":""},{"location":"release_notes/#v2123-2026-01-21","title":"[v2.12.3] - 2026-01-21","text":""},{"location":"release_notes/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Warning Logic for Missing Relation Serializers [<code>ninja_aio/models/serializers.py</code>]:</li> <li>Fixed boolean logic in <code>_warn_missing_relation_serializer</code> method.</li> </ul>"},{"location":"release_notes/#release-notes","title":"Release Notes","text":""},{"location":"release_notes/#v2122-2026-01-21","title":"[v2.12.2] - 2026-01-21","text":""},{"location":"release_notes/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Warning Logic for Missing Relation Serializers [<code>ninja_aio/models/serializers.py</code>]:</li> <li>Fixed boolean logic in <code>_warn_missing_relation_serializer</code> method.</li> <li>Warnings now correctly emit when: (not ModelSerializer AND not testing) OR force warnings enabled.</li> <li>Previously, warnings were incorrectly suppressed for non-ModelSerializer relations even when <code>NINJA_AIO_RAISE_SERIALIZATION_WARNINGS=True</code>.</li> </ul>"},{"location":"release_notes/#release-notes","title":"Release Notes","text":""},{"location":"release_notes/#v2121-2026-01-21","title":"[v2.12.1] - 2026-01-21","text":""},{"location":"release_notes/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>QueryUtil DETAIL Scope Fallback [<code>ninja_aio/helpers/query.py</code>]:</li> <li><code>detail_config</code> now correctly falls back to <code>read_config</code> for <code>select_related</code> and <code>prefetch_related</code> when not explicitly configured.</li> <li>Ensures consistent queryset optimization behavior between READ and DETAIL scopes.</li> </ul>"},{"location":"release_notes/#improvements","title":"\ud83d\udd27 Improvements","text":"<ul> <li>Refactored Fallback Logic [<code>ninja_aio/helpers/query.py</code>]:</li> <li>Moved DETAIL\u2192READ fallback from <code>apply_queryset_optimizations()</code> to <code>__init__()</code>.</li> <li>Fallback is now resolved once at construction time, improving clarity and preventing runtime mutation.</li> <li>Uses <code>.copy()</code> to ensure <code>detail_config</code> lists are independent from <code>read_config</code>.</li> </ul>"},{"location":"release_notes/#tests","title":"\ud83e\uddea Tests","text":"<ul> <li>New Test Cases for QueryUtil DETAIL Fallback [<code>tests/test_query_util.py</code>]:</li> <li><code>test_detail_scope_fallback_to_read_select_related</code>: Verifies DETAIL scope uses READ's <code>select_related</code> when not configured.</li> <li><code>test_detail_scope_fallback_to_read_prefetch_related</code>: Verifies DETAIL scope uses READ's <code>prefetch_related</code> when not configured.</li> <li><code>test_detail_config_initialized_with_read_fallback</code>: Confirms fallback is applied during initialization.</li> <li><code>test_detail_config_independent_copy</code>: Ensures <code>detail_config</code> lists are copies, not references (prevents mutation bugs).</li> </ul>"},{"location":"release_notes/#release-notes","title":"Release Notes","text":""},{"location":"release_notes/#v2120-2026-01-21","title":"[v2.12.0] - 2026-01-21","text":""},{"location":"release_notes/#added","title":"\u2728 Added","text":"<ul> <li>Per-Field-Type Detail Fallback for ModelSerializer [<code>ninja_aio/models/serializers.py</code>]:</li> <li><code>DetailSerializer</code> now falls back to <code>ReadSerializer</code> for each field type (<code>fields</code>, <code>customs</code>, <code>optionals</code>, <code>excludes</code>) independently when not explicitly configured.</li> <li> <p>Allows partial overrides: define only <code>DetailSerializer.fields</code> while inheriting <code>customs</code>, <code>optionals</code>, and <code>excludes</code> from <code>ReadSerializer</code>.</p> </li> <li> <p>Schema-Level Detail Fallback for Serializer [<code>ninja_aio/models/serializers.py</code>]:</p> </li> <li>When <code>schema_detail</code> is not defined, <code>Serializer</code> now correctly falls back to <code>schema_out</code> for all field configurations.</li> <li> <p>Enables seamless list/detail endpoint differentiation without duplicating configuration.</p> </li> <li> <p>New Setting: <code>NINJA_AIO_RAISE_SERIALIZATION_WARNINGS</code> [<code>ninja_aio/models/serializers.py</code>]:</p> </li> <li>New Django setting to control serialization warning behavior during testing.</li> <li>When <code>True</code> (with <code>NINJA_AIO_TESTING=True</code>), warnings for missing relation serializers are raised instead of suppressed.</li> </ul>"},{"location":"release_notes/#improvements","title":"\ud83d\udd27 Improvements","text":"<ul> <li>Refactored Fallback Logic [<code>ninja_aio/models/serializers.py</code>]:</li> <li>Moved detail\u2192read fallback from <code>BaseSerializer.get_fields()</code> to <code>_get_fields()</code> in both <code>ModelSerializer</code> and <code>Serializer</code>.</li> <li><code>ModelSerializer._get_fields()</code>: Falls back per-field-type (if <code>DetailSerializer.customs</code> is empty, uses <code>ReadSerializer.customs</code>).</li> <li> <p><code>Serializer._get_fields()</code>: Falls back at schema level (if <code>schema_detail</code> is <code>None</code>, uses <code>schema_out</code>).</p> </li> <li> <p>Warning Control Enhancement [<code>ninja_aio/models/serializers.py</code>]:</p> </li> <li>Updated <code>_warn_missing_relation_serializer()</code> to respect both <code>NINJA_AIO_TESTING</code> and new <code>NINJA_AIO_RAISE_SERIALIZATION_WARNINGS</code> settings.</li> </ul>"},{"location":"release_notes/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Serializer Detail Fallback Typo [<code>ninja_aio/models/serializers.py</code>]:</li> <li>Fixed <code>Serializer._get_fields()</code> where detail fallback was incorrectly referencing <code>\"read\"</code> instead of <code>\"out\"</code> schema key.</li> </ul>"},{"location":"release_notes/#tests","title":"\ud83e\uddea Tests","text":"<ul> <li>New Test Cases for Serializer Detail Fallback [<code>tests/test_serializers.py</code>]:</li> <li><code>test_detail_fallback_customs_from_read</code>: Verifies customs inheritance when <code>schema_detail</code> is not defined.</li> <li><code>test_detail_fallback_optionals_from_read</code>: Verifies optionals inheritance.</li> <li><code>test_detail_fallback_excludes_from_read</code>: Verifies excludes inheritance.</li> <li> <p><code>test_detail_does_not_inherit_when_defined</code>: Confirms no inheritance when <code>schema_detail</code> is explicitly defined.</p> </li> <li> <p>New Test Cases for ModelSerializer Detail Fallback [<code>tests/test_serializers.py</code>]:</p> </li> <li><code>test_model_serializer_detail_fallback_fields</code>: Verifies fields fallback to <code>ReadSerializer</code>.</li> <li><code>test_model_serializer_detail_fallback_customs</code>: Verifies customs fallback per-field-type.</li> <li><code>test_model_serializer_detail_fallback_optionals</code>: Verifies optionals fallback per-field-type.</li> <li><code>test_model_serializer_detail_fallback_excludes</code>: Verifies excludes fallback per-field-type.</li> <li><code>test_model_serializer_detail_inherits_per_field_type</code>: Confirms per-field-type inheritance behavior.</li> <li> <p><code>test_model_serializer_with_detail_generates_different_schemas</code>: End-to-end schema generation test.</p> </li> <li> <p>New Test Models [<code>tests/test_app/models.py</code>]:</p> </li> <li><code>TestModelSerializerWithReadCustoms</code>: Model with customs on <code>ReadSerializer</code> only.</li> <li><code>TestModelSerializerWithReadOptionals</code>: Model with optionals on <code>ReadSerializer</code> only.</li> <li><code>TestModelSerializerWithReadExcludes</code>: Model with excludes on <code>ReadSerializer</code> only.</li> <li><code>TestModelSerializerWithBothSerializers</code>: Model with both <code>ReadSerializer</code> and <code>DetailSerializer</code> configured.</li> </ul>"},{"location":"release_notes/#usage-example","title":"\ud83d\udca1 Usage Example","text":""},{"location":"release_notes/#modelserializer-per-field-type-fallback","title":"ModelSerializer (Per-Field-Type Fallback)","text":"<pre><code>from ninja_aio.models import ModelSerializer\nfrom django.db import models\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    author_notes = models.TextField(blank=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\"]\n        customs = [(\"word_count\", int, lambda obj: len(obj.content.split()))]\n\n    class DetailSerializer:\n        # Only override fields - customs inherited from ReadSerializer\n        fields = [\"id\", \"title\", \"content\", \"author_notes\"]\n</code></pre> <p>Behavior: - <code>generate_read_s()</code> \u2192 <code>{\"id\", \"title\", \"word_count\"}</code> - <code>generate_detail_s()</code> \u2192 <code>{\"id\", \"title\", \"content\", \"author_notes\", \"word_count\"}</code> (customs inherited)</p>"},{"location":"release_notes/#serializer-schema-level-fallback","title":"Serializer (Schema-Level Fallback)","text":"<pre><code>from ninja_aio.models import serializers\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = Article\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\"],\n            customs=[(\"word_count\", int, 0)],\n        )\n        # No schema_detail - falls back to schema_out entirely\n</code></pre> <p>Behavior: - <code>generate_read_s()</code> \u2192 <code>{\"id\", \"title\", \"word_count\"}</code> - <code>generate_detail_s()</code> \u2192 <code>{\"id\", \"title\", \"word_count\"}</code> (same as read)</p>"},{"location":"release_notes/#v2112","title":"v2.11.2","text":""},{"location":"release_notes/#fixed","title":"Fixed","text":"<ul> <li>Fixed binary field serialization in <code>_bump_object_from_schema</code> - removed <code>mode=\"json\"</code> from <code>model_dump()</code> to prevent UTF-8 decode errors when retrieving binary data. Binary fields are now properly handled by <code>ORJSONRenderer</code> which converts them to base64.</li> </ul>"},{"location":"release_notes/#release-notes","title":"Release Notes","text":""},{"location":"release_notes/#v2111-2026-01-19","title":"[v2.11.1] - 2026-01-19","text":""},{"location":"release_notes/#bug-fixes","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>ORJSONRenderer HttpResponse Passthrough [<code>ninja_aio/renders.py</code>]:</li> <li>Fixed <code>ORJSONRenderer.render()</code> to detect and return <code>HttpResponseBase</code> instances directly without JSON serialization.</li> <li>Previously, returning an <code>HttpResponse</code> with a custom content type (e.g., PEM files, binary downloads) would fail because the renderer attempted to serialize it as JSON.</li> <li>Now supports returning <code>HttpResponse</code>, <code>StreamingHttpResponse</code>, and any other <code>HttpResponseBase</code> subclass.</li> </ul>"},{"location":"release_notes/#documentation","title":"\ud83d\udcd6 Documentation","text":"<ul> <li>ORJSON Renderer Documentation [<code>docs/api/renderers/orjson_renderer.md</code>]:</li> <li>Reorganized documentation with proper section headings.</li> <li>Added new HttpResponse Passthrough section explaining the feature.</li> <li>Includes usage examples for <code>HttpResponse</code> and <code>StreamingHttpResponse</code>.</li> <li>Documents the correct pattern for returning custom responses with non-JSON content types.</li> </ul>"},{"location":"release_notes/#tests","title":"\ud83e\uddea Tests","text":"<ul> <li>New Test Cases [<code>tests/core/test_renderer_parser.py</code>]:</li> <li><code>test_renderer_http_response_passthrough</code>: Verifies <code>HttpResponse</code> objects pass through unchanged with correct content and headers.</li> <li><code>test_renderer_streaming_http_response_passthrough</code>: Verifies <code>StreamingHttpResponse</code> objects are also handled correctly.</li> </ul>"},{"location":"release_notes/#usage-example","title":"\ud83d\udca1 Usage Example","text":"<pre><code>from django.http import HttpResponse, StreamingHttpResponse\n\n# Return a PEM file\n@api.get(\"/public-key\")\ndef get_public_key(request):\n    return HttpResponse(\n        settings.JWT_PUBLIC_KEY.as_pem(),\n        content_type=\"application/x-pem-file\",\n        status=200,\n    )\n\n# Return a streaming response for large files\n@api.get(\"/download\")\ndef download_file(request):\n    return StreamingHttpResponse(\n        file_iterator(),\n        content_type=\"application/octet-stream\",\n    )\n</code></pre> <p>Note: Set the <code>status</code> parameter on the <code>HttpResponse</code> itself. Do not use tuple returns like <code>return 200, HttpResponse(...)</code>.</p>"},{"location":"release_notes/#release-notes","title":"Release Notes","text":""},{"location":"release_notes/#v2110-2026-01-19","title":"[v2.11.0] - 2026-01-19","text":""},{"location":"release_notes/#added","title":"\u2728 Added","text":"<ul> <li>MatchCaseFilterViewSetMixin [<code>ninja_aio/views/mixins.py</code>]:</li> <li>New mixin for conditional filtering based on boolean query parameters.</li> <li>Maps boolean API parameters (<code>?is_active=true</code>) to different Django ORM filter conditions for <code>True</code> and <code>False</code> cases.</li> <li>Supports both <code>filter()</code> (include) and <code>exclude()</code> operations via the <code>include</code> attribute.</li> <li> <p>Automatically registers query params from <code>filters_match_cases</code> configuration.</p> </li> <li> <p>New Filter Schemas [<code>ninja_aio/schemas/filters.py</code>]:</p> </li> <li><code>MatchCaseFilterSchema</code>: Configures match-case filters with <code>query_param</code> and <code>cases</code> attributes.</li> <li><code>MatchConditionFilterSchema</code>: Defines individual filter conditions with <code>query_filter</code> (dict) and <code>include</code> (bool).</li> <li><code>BooleanMatchFilterSchema</code>: Groups <code>true</code> and <code>false</code> case conditions.</li> <li><code>FilterSchema</code>: New base class for filter schemas with <code>filter_type</code> and <code>query_param</code> attributes.</li> </ul>"},{"location":"release_notes/#improvements","title":"\ud83d\udd27 Improvements","text":"<ul> <li>Unified Special Filter Detection [<code>ninja_aio/views/api.py</code>]:</li> <li>Added <code>APIViewSet._check_match_cases_filters(filter: str)</code> helper method.</li> <li> <p>Added <code>APIViewSet._is_special_filter(filter: str)</code> method combining relation and match-case filter detection.</p> </li> <li> <p>Filter Mixin Skip Logic [<code>ninja_aio/views/mixins.py</code>]:</p> </li> <li>Updated all filter mixins to use <code>_is_special_filter()</code> instead of <code>_check_relations_filters()</code>:<ul> <li><code>IcontainsFilterViewSetMixin</code></li> <li><code>BooleanFilterViewSetMixin</code></li> <li><code>NumericFilterViewSetMixin</code></li> <li><code>DateFilterViewSetMixin</code></li> </ul> </li> <li> <p>Ensures match-case filter params are not double-processed by type-based mixins.</p> </li> <li> <p>RelationFilterSchema Refactoring [<code>ninja_aio/schemas/filters.py</code>]:</p> </li> <li><code>RelationFilterSchema</code> now extends <code>FilterSchema</code> base class.</li> <li>Moved from <code>ninja_aio/schemas/api.py</code> to dedicated <code>ninja_aio/schemas/filters.py</code> module.</li> </ul>"},{"location":"release_notes/#documentation","title":"\ud83d\udcd6 Documentation","text":"<ul> <li>Mixins Documentation [<code>docs/api/views/mixins.md</code>]:</li> <li>Added comprehensive documentation for <code>MatchCaseFilterViewSetMixin</code>.</li> <li>Includes usage examples for simple status filtering and complex multi-condition filtering.</li> <li>Documents all schema requirements and configuration options.</li> </ul>"},{"location":"release_notes/#tests","title":"\ud83e\uddea Tests","text":"<ul> <li>New Test Cases [<code>tests/views/test_viewset.py</code>]:</li> <li><code>MatchCaseFilterViewSetMixinTestCase</code>: Tests include behavior with <code>True</code>/<code>False</code>/<code>None</code> values.</li> <li><code>MatchCaseFilterViewSetMixinExcludeTestCase</code>: Tests exclude behavior when <code>include=False</code>.</li> <li> <p>Tests cover query params registration and <code>filters_match_cases_fields</code> property.</p> </li> <li> <p>Test ViewSets [<code>tests/test_app/views.py</code>]:</p> </li> <li><code>TestModelSerializerMatchCaseFilterAPI</code>: Tests <code>is_approved</code> filter with include/exclude logic.</li> <li> <p><code>TestModelSerializerMatchCaseExcludeFilterAPI</code>: Tests <code>hide_pending</code> filter with inverse logic.</p> </li> <li> <p>Test Model Update [<code>tests/test_app/models.py</code>]:</p> </li> <li>Added <code>status</code> field to <code>TestModelSerializer</code> for match-case filter testing.</li> </ul>"},{"location":"release_notes/#usage-example","title":"\ud83d\udca1 Usage Example","text":"<pre><code>from ninja_aio.views.mixins import MatchCaseFilterViewSetMixin\nfrom ninja_aio.views.api import APIViewSet\nfrom ninja_aio.schemas import (\n    MatchCaseFilterSchema,\n    MatchConditionFilterSchema,\n    BooleanMatchFilterSchema,\n)\n\nclass OrderViewSet(MatchCaseFilterViewSetMixin, APIViewSet):\n    model = models.Order\n    api = api\n    filters_match_cases = [\n        MatchCaseFilterSchema(\n            query_param=\"is_completed\",\n            cases=BooleanMatchFilterSchema(\n                true=MatchConditionFilterSchema(\n                    query_filter={\"status\": \"completed\"},\n                ),\n                false=MatchConditionFilterSchema(\n                    query_filter={\"status\": \"completed\"},\n                    include=False,  # excludes completed orders\n                ),\n            ),\n        ),\n    ]\n</code></pre> <p>API Behavior: - <code>GET /orders?is_completed=true</code> \u2192 <code>queryset.filter(status=\"completed\")</code> - <code>GET /orders?is_completed=false</code> \u2192 <code>queryset.exclude(status=\"completed\")</code></p>"},{"location":"release_notes/#release-notes","title":"Release Notes","text":""},{"location":"release_notes/#v2101-2026-01-16","title":"[v2.10.1] - 2026-01-16","text":""},{"location":"release_notes/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Filter Mixin Conflict Resolution [file:2]:</li> <li>Added <code>APIViewSet._check_relations_filters(filter: str)</code> helper method to detect if a filter key belongs to <code>relations_filters</code>.</li> <li> <p>Added <code>RelationFilterViewSetMixin.relations_filters_fields</code> property that extracts all <code>query_param</code> names from configured <code>relations_filters</code>.</p> </li> <li> <p>Filter Handler Skip Logic [file:2]:</p> </li> <li>IcontainsFilterViewSetMixin: Now skips relation filter keys (<code>if isinstance(value, str) and not self._check_relations_filters(key)</code>).</li> <li>BooleanFilterViewSetMixin: Now skips relation filter keys when applying boolean filters.</li> <li>NumericFilterViewSetMixin: Now skips relation filter keys when applying numeric filters.</li> <li>DateFilterViewSetMixin: Now skips relation filter keys when applying date comparisons (<code>__lte</code>, etc.).</li> </ul> <p>Impact: Prevents double-processing of relation filters when combining <code>RelationFilterViewSetMixin</code> with other filter mixins. Relation filters are handled exclusively by <code>RelationFilterViewSetMixin.query_params_handler</code>, avoiding conflicts like: - String relation params (<code>?author_id=5</code>) being misinterpreted as <code>icontains</code> filters. - Numeric relation params being applied twice. - Boolean/date relation params triggering incorrect transformations.</p>"},{"location":"release_notes/#internal-changes","title":"\ud83d\udd27 Internal Changes","text":"<ul> <li>Mixin Inheritance Chain:</li> <li>Filter mixins (<code>IcontainsFilterViewSetMixin</code>, etc.) now respect <code>RelationFilterViewSetMixin</code> configuration via shared <code>_check_relations_filters()</code> method.</li> <li> <p>Ensures proper layering: base filters \u2192 relation filters (exclusive handling).</p> </li> <li> <p>Query Params Handler Flow:</p> </li> </ul>"},{"location":"release_notes/#release-notes","title":"Release Notes","text":""},{"location":"release_notes/#v2100-2026-01-16","title":"[v2.10.0] - 2026-01-16","text":""},{"location":"release_notes/#added","title":"\u2728 Added","text":"<ul> <li>Relation-Based Filtering Mixin:</li> <li>New <code>RelationFilterViewSetMixin</code> for filtering by related model fields via query parameters.</li> <li>New <code>RelationFilterSchema</code> for declarative mapping of <code>query_param</code> \u2192 Django ORM <code>query_filter</code> with typed <code>filter_type</code> tuples.</li> <li> <p>Automatic registration of <code>relations_filters</code> entries into <code>query_params</code> on subclasses.</p> </li> <li> <p>Schema &amp; Import Enhancements:</p> </li> <li>Exported <code>RelationFilterSchema</code> from <code>ninja_aio.schemas</code> and added to <code>__all__</code>.</li> <li>Added <code>RelationFilterSchema</code> import to <code>ninja_aio.views.mixins</code> and example usages in docs and test views.</li> </ul>"},{"location":"release_notes/#changed","title":"\ud83d\udee0 Changed","text":"<ul> <li>ModelUtil Relation Detection Fix:</li> <li>Corrected relation ordering in <code>ModelUtil.get_select_relateds()</code>:<ul> <li>Now detects <code>ForwardOneToOneDescriptor</code> before <code>ForwardManyToOneDescriptor</code> for building <code>select_related</code> lists.</li> </ul> </li> <li> <p>Ensures one-to-one relations are properly included in query optimizations.</p> </li> <li> <p>Documentation Updates:</p> </li> <li>Extended <code>docs/api/views/mixins.md</code> with a new section for <code>RelationFilterViewSetMixin</code>.</li> <li>Added examples showing how to configure <code>relations_filters</code> and resulting query behavior.</li> </ul>"},{"location":"release_notes/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>ModelUtil Primary Key Type Error Handling:</li> <li><code>ModelUtil.pk_field_type</code> now raises a clear <code>ConfigError</code> when encountering unknown primary key field types.</li> <li> <p>Error message explicitly reports unsupported field type and suggests missing mapping in <code>ninja.orm.fields.TYPES</code>.</p> </li> <li> <p>ModelUtil Configuration Edge Cases:</p> </li> <li> <p><code>ModelUtil</code> now raises <code>ConfigError</code> when instantiated with a <code>ModelSerializer</code> model and an explicit <code>serializer_class</code> at the same time, avoiding ambiguous configuration.</p> </li> <li> <p>ORJSON Renderer Primitive Handling:</p> </li> <li>ORJSON renderer now correctly handles non-dict payloads (strings, lists, primitives) without assuming <code>.items()</code> presence.</li> <li> <p>Added coverage for list and primitive responses to ensure consistent rendering behavior.</p> </li> <li> <p>Async JWT Auth Robustness:</p> </li> <li><code>AsyncJwtBearer.authenticate</code> now safely handles invalid or malformed tokens where <code>jwt.decode</code> raises <code>ValueError</code>, returning <code>False</code> instead of propagating the exception.</li> <li>Base <code>auth_handler</code> path verified to return <code>None</code> when not overridden, and mandatory claims validation now preserves pre-set <code>iss</code> and <code>aud</code> values.</li> </ul>"},{"location":"release_notes/#tests","title":"\ud83e\uddea Tests","text":"<ul> <li>New Test Suites for Edge Cases:</li> <li><code>ModelUtilConfigErrorTestCase</code> to validate <code>ConfigError</code> raising when mixing <code>ModelSerializer</code> model and <code>serializer_class</code>.</li> <li><code>ModelUtilPkFieldTypeTestCase</code> to ensure unknown PK types trigger <code>ConfigError</code> with informative message.</li> <li>`ModelUtilObjectsQueryDefaultTest</li> </ul>"},{"location":"release_notes/#release-notes","title":"Release Notes","text":""},{"location":"release_notes/#v290-2026-01-14","title":"[v2.9.0] - 2026-01-14","text":""},{"location":"release_notes/#added","title":"\u2728 Added","text":"<ul> <li>Detail-Specific Query Optimizations:</li> <li>New <code>QuerySet.detail</code> configuration for detail-specific <code>select_related</code> and <code>prefetch_related</code></li> <li>New <code>serializable_detail_fields</code> property on <code>ModelUtil</code> for accessing detail-specific fields</li> <li>New <code>_get_serializable_field_names()</code> helper method for DRY field retrieval</li> <li> <p>New <code>DETAIL</code> scope added to <code>QueryUtilBaseScopesSchema</code></p> </li> <li> <p>Fallback Mechanism for Detail Schema:</p> </li> <li><code>generate_detail_s()</code> now falls back to read schema when no <code>DetailSerializer</code> is defined</li> <li><code>get_fields(\"detail\")</code> falls back to read fields when no detail fields are declared</li> <li><code>_get_read_optimizations(\"detail\")</code> falls back to <code>QuerySet.read</code> when <code>QuerySet.detail</code> is not defined</li> </ul>"},{"location":"release_notes/#changed","title":"\ud83d\udee0 Changed","text":"<ul> <li>API Parameter Change: <code>is_for_read</code> \u2192 <code>is_for</code>:</li> <li>Renamed <code>is_for_read: bool</code> parameter to <code>is_for: Literal[\"read\", \"detail\"] | None</code> across all <code>ModelUtil</code> methods:<ul> <li><code>get_objects()</code></li> <li><code>get_object()</code></li> <li><code>read_s()</code></li> <li><code>list_read_s()</code></li> <li><code>_get_base_queryset()</code></li> <li><code>_apply_query_optimizations()</code></li> <li><code>_serialize_queryset()</code></li> <li><code>_serialize_single_object()</code></li> <li><code>_handle_query_mode()</code></li> <li><code>_read_s()</code></li> </ul> </li> <li> <p>This enables explicit control over which optimization strategy to use</p> </li> <li> <p>Query Optimization Methods Now Accept <code>is_for</code> Parameter:</p> </li> <li><code>get_select_relateds(is_for: Literal[\"read\", \"detail\"] = \"read\")</code></li> <li><code>get_reverse_relations(is_for: Literal[\"read\", \"detail\"] = \"read\")</code></li> <li> <p><code>_get_read_optimizations(is_for: Literal[\"read\", \"detail\"] = \"read\")</code></p> </li> <li> <p>APIViewSet Retrieve Endpoint:</p> </li> <li>Now uses <code>is_for=\"detail\"</code> when <code>schema_detail</code> is available</li> <li> <p>Falls back to <code>is_for=\"read\"</code> when no detail schema is configured</p> </li> <li> <p>Code Formatting Improvements:</p> </li> <li>Reformatted multi-line tuples in <code>_is_reverse_relation()</code></li> <li>Reformatted conditional in <code>_warn_missing_relation_serializer()</code></li> <li>Reformatted error message in <code>get_schema_out_data()</code></li> </ul>"},{"location":"release_notes/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Query Optimization Fallback Bug:</li> <li>Fixed <code>_get_read_optimizations()</code> to fall back to <code>read</code> config when <code>detail</code> config is not defined</li> <li>Previously returned empty <code>ModelQuerySetSchema()</code> when <code>QuerySet.detail</code> was missing, losing all optimizations</li> </ul>"},{"location":"release_notes/#documentation","title":"\ud83d\udcdd Documentation","text":"<ul> <li>ModelUtil Documentation (docs/api/models/model_util.md):</li> <li>Updated all method signatures from <code>is_for_read: bool</code> to <code>is_for: Literal[\"read\", \"detail\"] | None</code></li> <li>Added <code>QuerySet.detail</code> configuration example</li> <li>Added <code>serializable_detail_fields</code> property documentation</li> <li>Updated examples to show <code>is_for=\"read\"</code> and <code>is_for=\"detail\"</code> usage</li> <li> <p>Added fallback behavior notes for detail optimizations</p> </li> <li> <p>ModelSerializer Documentation (docs/api/models/model_serializer.md):</p> </li> <li>Added Fallback Behavior note in <code>DetailSerializer</code> section</li> <li>Updated <code>generate_detail_s()</code> comment to indicate fallback to read schema</li> <li> <p>Updated fields table to mention fallback behavior</p> </li> <li> <p>Serializer Documentation (docs/api/models/serializers.md):</p> </li> <li>Added <code>QuerySet.detail</code> configuration example</li> <li>Added explanation of how each QuerySet config is applied (<code>read</code>, <code>detail</code>, <code>queryset_request</code>, <code>extras</code>)</li> </ul>"},{"location":"release_notes/#tests","title":"\ud83e\uddea Tests","text":"<ul> <li>Updated Test Cases:</li> <li>Updated all <code>is_for_read=True</code> to <code>is_for=\"read\"</code> across test files</li> <li>Updated all <code>is_for_read=False</code> to <code>is_for=None</code> across test files</li> <li>Renamed <code>test_generate_detail_schema_returns_none_when_not_configured</code> to <code>test_generate_detail_schema_falls_back_to_read_when_not_configured</code></li> <li> <p>Updated <code>test_fallback_to_schema_out_when_no_detail</code> to <code>test_detail_schema_falls_back_to_read_schema</code></p> </li> <li> <p>New Test Cases:</p> </li> <li><code>DetailFieldsModelSerializer</code> - Test model with different read vs detail fields including a relation</li> <li><code>ModelUtilIsForDetailTestCase</code> - Tests for <code>is_for='detail'</code> parameter:<ul> <li><code>test_serializable_fields_returns_read_fields()</code></li> <li><code>test_serializable_detail_fields_returns_detail_fields()</code></li> <li><code>test_get_select_relateds_read_no_relations()</code></li> <li><code>test_get_select_relateds_detail_includes_relation()</code></li> <li><code>test_apply_query_optimizations_read_vs_detail()</code></li> <li><code>test_get_serializable_field_names_read()</code></li> <li><code>test_get_serializable_field_names_detail()</code></li> </ul> </li> <li><code>ReadOnlyQuerySetModelSerializer</code> - Test model with <code>QuerySet.read</code> but no <code>QuerySet.detail</code></li> <li><code>ModelUtilOptimizationFallbackTestCase</code> - Tests for optimization fallback behavior:<ul> <li><code>test_get_read_optimizations_read()</code></li> <li><code>test_get_read_optimizations_detail_falls_back_to_read()</code></li> <li><code>test_apply_query_optimizations_detail_uses_read_fallback()</code></li> </ul> </li> </ul>"},{"location":"release_notes/#internal-changes","title":"\ud83d\udd27 Internal Changes","text":"<ul> <li>BaseSerializer Changes:</li> <li>Added <code>detail = ModelQuerySetSchema()</code> to inner <code>QuerySet</code> class</li> <li> <p>Added fallback logic in <code>get_fields()</code> for detail type</p> </li> <li> <p>QueryUtilBaseScopesSchema Changes:</p> </li> <li> <p>Added <code>DETAIL: str = \"detail\"</code> scope constant</p> </li> <li> <p>QueryUtil Changes:</p> </li> <li>Added <code>detail_config</code> property for accessing detail query configuration</li> </ul>"},{"location":"release_notes/#use-cases-examples","title":"\ud83d\ude80 Use Cases &amp; Examples","text":""},{"location":"release_notes/#detail-specific-query-optimizations","title":"Detail-Specific Query Optimizations","text":"<pre><code>from ninja_aio.models import ModelSerializer\nfrom ninja_aio.schemas.helpers import ModelQuerySetSchema\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    summary = models.TextField()\n    content = models.TextField()\n    author = models.ForeignKey(User, on_delete=models.CASCADE)\n    tags = models.ManyToManyField(Tag)\n    comments = models.ManyToManyField(Comment)\n\n    class ReadSerializer:\n        # List view: minimal fields\n        fields = [\"id\", \"title\", \"summary\", \"author\"]\n\n    class DetailSerializer:\n        # Detail view: all fields including expensive relations\n        fields = [\"id\", \"title\", \"summary\", \"content\", \"author\", \"tags\", \"comments\"]\n\n    class QuerySet:\n        # Optimizations for list endpoint\n        read = ModelQuerySetSchema(\n            select_related=[\"author\"],\n            prefetch_related=[],\n        )\n        # Optimizations for retrieve endpoint (more aggressive prefetching)\n        detail = ModelQuerySetSchema(\n            select_related=[\"author\", \"author__profile\"],\n            prefetch_related=[\"tags\", \"comments\", \"comments__author\"],\n        )\n</code></pre> <p>Behavior: - <code>GET /articles/</code> uses <code>QuerySet.read</code> optimizations (light prefetching) - <code>GET /articles/{pk}</code> uses <code>QuerySet.detail</code> optimizations (full prefetching)</p>"},{"location":"release_notes/#fallback-behavior","title":"Fallback Behavior","text":"<pre><code>class Article(ModelSerializer):\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"content\"]\n\n    class QuerySet:\n        read = ModelQuerySetSchema(\n            select_related=[\"author\"],\n            prefetch_related=[\"tags\"],\n        )\n        # No detail config - will fall back to read!\n\n# Both list and retrieve use QuerySet.read optimizations\n# generate_detail_s() returns same schema as generate_read_s()\n</code></pre>"},{"location":"release_notes/#using-is_for-parameter-directly","title":"Using is_for Parameter Directly","text":"<pre><code>from ninja_aio.models import ModelUtil\n\nutil = ModelUtil(Article)\n\n# For list operations\nqs = await util.get_objects(request, is_for=\"read\")\n\n# For single object retrieval\nobj = await util.get_object(request, pk=1, is_for=\"detail\")\n\n# For serialization\ndata = await util.read_s(schema, request, instance=obj, is_for=\"detail\")\nitems = await util.list_read_s(schema, request, instances=qs, is_for=\"read\")\n</code></pre>"},{"location":"release_notes/#migration-guide","title":"\ud83d\udd0d Migration Guide","text":""},{"location":"release_notes/#breaking-change-is_for_read-is_for","title":"Breaking Change: <code>is_for_read</code> \u2192 <code>is_for</code>","text":"<p>If you call <code>ModelUtil</code> methods directly with <code>is_for_read</code>, update to use <code>is_for</code>:</p> <pre><code># Before (v2.8.0)\nawait util.get_objects(request, is_for_read=True)\nawait util.get_object(request, pk=1, is_for_read=True)\nawait util.read_s(schema, request, instance=obj, is_for_read=True)\n\n# After (v2.9.0)\nawait util.get_objects(request, is_for=\"read\")\nawait util.get_object(request, pk=1, is_for=\"detail\")\nawait util.read_s(schema, request, instance=obj, is_for=\"detail\")\n</code></pre> <p>Mapping: | Old Parameter | New Parameter | |---------------|---------------| | <code>is_for_read=True</code> | <code>is_for=\"read\"</code> (for list) or <code>is_for=\"detail\"</code> (for retrieve) | | <code>is_for_read=False</code> | <code>is_for=None</code> |</p>"},{"location":"release_notes/#adding-detail-specific-optimizations","title":"Adding Detail-Specific Optimizations","text":"<pre><code># Before (v2.8.0) - Same optimizations for list and retrieve\nclass QuerySet:\n    read = ModelQuerySetSchema(\n        select_related=[\"author\"],\n        prefetch_related=[\"tags\", \"comments\"],  # Always loaded!\n    )\n\n# After (v2.9.0) - Different optimizations per operation\nclass QuerySet:\n    read = ModelQuerySetSchema(\n        select_related=[\"author\"],\n        prefetch_related=[],  # Light for list\n    )\n    detail = ModelQuerySetSchema(\n        select_related=[\"author\", \"author__profile\"],\n        prefetch_related=[\"tags\", \"comments\"],  # Full for retrieve\n    )\n</code></pre>"},{"location":"release_notes/#performance-benefits","title":"\ud83d\udcca Performance Benefits","text":"Scenario Without Detail Config With Detail Config List 100 articles Prefetches tags + comments for all Only prefetches what's needed for list Retrieve single Uses list optimizations Uses detail-specific optimizations N+1 queries May occur if list over-fetches Optimized per endpoint Memory usage Higher (unnecessary prefetch) Optimized per operation"},{"location":"release_notes/#important-notes","title":"\u26a0\ufe0f Important Notes","text":"<ul> <li>Breaking Change: <code>is_for_read: bool</code> parameter renamed to <code>is_for: Literal[\"read\", \"detail\"] | None</code></li> <li>Fallback Behavior: All fallbacks are automatic - no configuration needed for backward compatibility</li> <li>QuerySet.detail: Optional - falls back to <code>QuerySet.read</code> if not defined</li> <li>DetailSerializer fields: Optional - falls back to <code>ReadSerializer</code> fields if not defined</li> <li>generate_detail_s(): Now always returns a schema (falls back to read schema)</li> </ul>"},{"location":"release_notes/#links","title":"\ud83d\udd17 Links","text":"<ul> <li>Documentation</li> <li>GitHub Repository</li> <li>Issue Tracker</li> <li>v2.8.0 Release Notes</li> </ul>"},{"location":"release_notes/#version-history","title":"Version History","text":"<p>For older versions, please refer to the GitHub releases page.</p>"},{"location":"release_notes/#release-notes","title":"Release Notes","text":""},{"location":"release_notes/#v280-2026-01-14","title":"[v2.8.0] - 2026-01-14","text":""},{"location":"release_notes/#added","title":"\u2728 Added","text":"<ul> <li>Detail Schema Support for Retrieve Endpoints:</li> <li>New <code>DetailSerializer</code> configuration class for <code>ModelSerializer</code></li> <li>New <code>schema_detail</code> configuration option for <code>Serializer</code> Meta class</li> <li>New <code>schema_detail</code> attribute on <code>APIViewSet</code> for custom detail schemas</li> <li>New <code>generate_detail_s()</code> method for generating detail schemas</li> <li>Retrieve endpoint (<code>GET /{base}/{pk}</code>) now uses <code>schema_detail</code> when available, falling back to <code>schema_out</code></li> <li> <p>Enables performance optimization: minimal fields for list views, full details for single object retrieval</p> </li> <li> <p><code>serializer_class</code> Support for M2MRelationSchema:</p> </li> <li><code>M2MRelationSchema</code> now accepts <code>serializer_class</code> parameter for plain Django models</li> <li>Auto-generates <code>related_schema</code> from the serializer when provided</li> <li>Alternative to manually providing <code>related_schema</code> for plain models</li> <li>Validation ensures <code>serializer_class</code> cannot be used when <code>model</code> is already a <code>ModelSerializer</code></li> </ul>"},{"location":"release_notes/#changed","title":"\ud83d\udee0 Changed","text":"<ul> <li>APIViewSet Schema Generation:</li> <li><code>get_schemas()</code> now returns a 4-tuple: <code>(schema_out, schema_detail, schema_in, schema_update)</code></li> <li>New <code>_get_retrieve_schema()</code> helper method for retrieve endpoint schema selection</li> <li> <p><code>retrieve_view()</code> updated to use detail schema when available</p> </li> <li> <p>Refactored <code>get_schema_out_data()</code> Function:</p> </li> <li>Extracted helper methods for better code organization:<ul> <li><code>_is_reverse_relation()</code> - Check if field is a reverse relation</li> <li><code>_is_forward_relation()</code> - Check if field is a forward relation</li> <li><code>_warn_missing_relation_serializer()</code> - Emit warning for missing serializer mappings</li> <li><code>_process_field()</code> - Process single field and determine classification</li> </ul> </li> <li>Renamed parameter <code>type</code> to <code>schema_type</code> to avoid shadowing built-in</li> <li>Renamed internal variable <code>rels</code> to <code>forward_rels</code> for clarity</li> <li> <p>Now accepts <code>schema_type: Literal[\"Out\", \"Detail\"]</code> parameter</p> </li> <li> <p>Performance Optimization in <code>_generate_union_schema()</code>:</p> </li> <li>Fixed double method call issue using walrus operator</li> <li> <p><code>generate_related_s()</code> now called once per serializer instead of twice</p> </li> <li> <p>Updated Type Definitions:</p> </li> <li><code>S_TYPES</code> now includes <code>\"detail\"</code>: <code>Literal[\"read\", \"detail\", \"create\", \"update\"]</code></li> <li><code>SCHEMA_TYPES</code> now includes <code>\"Detail\"</code>: <code>Literal[\"In\", \"Out\", \"Detail\", \"Patch\", \"Related\"]</code></li> </ul>"},{"location":"release_notes/#documentation","title":"\ud83d\udcdd Documentation","text":"<ul> <li>ModelSerializer Documentation (docs/api/models/model_serializer.md):</li> <li>New DetailSerializer section with complete documentation</li> <li>Updated schema generation table to include <code>generate_detail_s()</code></li> <li>Added example showing List vs Detail output differences</li> <li> <p>Updated \"Auto-Generated Schemas\" to show five schema types</p> </li> <li> <p>Serializer Documentation (docs/api/models/serializers.md):</p> </li> <li>Added <code>schema_detail</code> to Meta configuration options</li> <li>New \"Detail Schema for Retrieve Endpoint\" section</li> <li> <p>Updated schema generation examples to include <code>generate_detail_s()</code></p> </li> <li> <p>APIViewSet Documentation (docs/api/views/api_view_set.md):</p> </li> <li>Updated CRUD endpoints table to show retrieve uses <code>schema_detail</code></li> <li>Added <code>schema_detail</code> to Core Attributes table</li> <li>New \"Detail Schema for Retrieve Endpoint\" section with examples</li> <li>Updated automatic schema generation section</li> <li>Added <code>serializer_class</code> documentation for <code>M2MRelationSchema</code></li> <li>Added tabbed examples for <code>related_schema</code> vs <code>serializer_class</code> usage</li> </ul>"},{"location":"release_notes/#tests","title":"\ud83e\uddea Tests","text":"<ul> <li>New Detail Schema Test Cases:</li> <li> <p><code>DetailSerializerTestCase</code> in tests/test_serializers.py:</p> <ul> <li><code>test_generate_detail_schema_with_serializer()</code> - Basic detail schema generation</li> <li><code>test_generate_detail_schema_returns_none_when_not_configured()</code> - None when not configured</li> <li><code>test_detail_schema_with_relations()</code> - Relations in detail schema</li> <li><code>test_detail_schema_with_custom_fields()</code> - Custom fields support</li> <li><code>test_detail_schema_with_optionals()</code> - Optional fields support</li> </ul> </li> <li> <p><code>DetailSchemaModelSerializerTestCase</code> in tests/views/test_viewset.py:</p> <ul> <li><code>test_read_schema_has_minimal_fields()</code> - ReadSerializer has minimal fields</li> <li><code>test_detail_schema_has_extended_fields()</code> - DetailSerializer has extended fields</li> <li><code>test_get_retrieve_schema_returns_detail()</code> - Retrieve uses detail schema</li> <li><code>test_get_schemas_returns_four_tuple()</code> - get_schemas returns 4-tuple</li> </ul> </li> <li> <p><code>DetailSchemaSerializerTestCase</code> - Tests for Serializer class with schema_detail</p> </li> <li> <p><code>DetailSchemaFallbackTestCase</code> - Tests fallback to schema_out when no detail defined</p> </li> <li> <p>New M2M serializer_class Test Cases:</p> </li> <li><code>M2MRelationSchemaSerializerClassTestCase</code> - Tests M2M with serializer_class</li> <li> <p><code>M2MRelationSchemaValidationTestCase</code>:</p> <ul> <li><code>test_serializer_class_with_plain_model_succeeds()</code></li> <li><code>test_model_serializer_auto_generates_related_schema()</code></li> <li><code>test_serializer_class_with_model_serializer_raises_error()</code></li> <li><code>test_plain_model_without_serializer_class_or_related_schema_raises_error()</code></li> <li><code>test_explicit_related_schema_takes_precedence()</code></li> </ul> </li> <li> <p>New Test Model:</p> </li> <li><code>TestModelSerializerWithDetail</code> in tests/test_app/models.py</li> <li> <p>Demonstrates separate <code>ReadSerializer</code> and <code>DetailSerializer</code> configurations</p> </li> <li> <p>Updated Existing Tests:</p> </li> <li>All <code>schemas</code> property definitions updated to return 4-tuple format</li> <li><code>test_get_schemas</code> updated to expect 4 elements instead of 3</li> <li>Refactored <code>ManyToManyAPITestCase</code> into <code>Tests.BaseManyToManyAPITestCase</code> base class</li> </ul>"},{"location":"release_notes/#internal-changes","title":"\ud83d\udd27 Internal Changes","text":"<ul> <li>Schema Mapping Updates:</li> <li><code>_SCHEMA_META_MAP</code> now includes <code>\"detail\": \"DetailSerializer\"</code> for ModelSerializer</li> <li><code>_SERIALIZER_CONFIG_MAP</code> now includes <code>\"detail\": \"detail\"</code> for Serializer</li> <li> <p><code>_get_serializer_config()</code> updated to handle <code>\"detail\"</code> case</p> </li> <li> <p>ModelSerializer Changes:</p> </li> <li>New <code>DetailSerializer</code> inner class with <code>fields</code>, <code>customs</code>, <code>optionals</code>, <code>excludes</code> attributes</li> <li><code>_generate_model_schema()</code> updated to handle <code>\"Detail\"</code> schema type</li> <li> <p>Schema naming: <code>\"Out\"</code> \u2192 <code>{model}SchemaOut</code>, <code>\"Detail\"</code> \u2192 <code>{model}DetailSchemaOut</code></p> </li> <li> <p>Serializer.Meta Changes:</p> </li> <li>New <code>schema_detail: Optional[SchemaModelConfig]</code> attribute</li> <li> <p><code>model_dump()</code> now uses detail schema when available for single object serialization</p> </li> <li> <p>M2MRelationSchema Changes:</p> </li> <li>New <code>serializer_class: Optional[SerializerMeta]</code> field</li> <li><code>validate_related_schema()</code> validator updated to handle serializer_class</li> <li>ManyToManyAPI updated to pass serializer_class to ModelUtil</li> </ul>"},{"location":"release_notes/#use-cases-examples","title":"\ud83d\ude80 Use Cases &amp; Examples","text":""},{"location":"release_notes/#detail-schema-for-performance-optimization","title":"Detail Schema for Performance Optimization","text":"<pre><code>from ninja_aio.models import ModelSerializer\nfrom django.db import models\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    summary = models.TextField()\n    content = models.TextField()\n    author = models.ForeignKey(User, on_delete=models.CASCADE)\n    tags = models.ManyToManyField(Tag)\n    view_count = models.IntegerField(default=0)\n\n    class ReadSerializer:\n        # List view: minimal fields for performance\n        fields = [\"id\", \"title\", \"summary\", \"author\"]\n\n    class DetailSerializer:\n        # Detail view: all fields including expensive relations\n        fields = [\"id\", \"title\", \"summary\", \"content\", \"author\", \"tags\", \"view_count\"]\n        customs = [\n            (\"reading_time\", int, lambda obj: len(obj.content.split()) // 200),\n        ]\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    pass  # Schemas auto-generated from model\n</code></pre> <p>Endpoint Behavior: - <code>GET /articles/</code> returns <code>[{\"id\": 1, \"title\": \"...\", \"summary\": \"...\", \"author\": {...}}, ...]</code> - <code>GET /articles/1</code> returns <code>{\"id\": 1, \"title\": \"...\", \"summary\": \"...\", \"content\": \"...\", \"author\": {...}, \"tags\": [...], \"view_count\": 1234, \"reading_time\": 5}</code></p>"},{"location":"release_notes/#detail-schema-with-serializer-class","title":"Detail Schema with Serializer Class","text":"<pre><code>from ninja_aio.models import serializers\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Article\n        schema_out = serializers.SchemaModelConfig(\n            # List view: minimal fields\n            fields=[\"id\", \"title\", \"summary\"]\n        )\n        schema_detail = serializers.SchemaModelConfig(\n            # Detail view: all fields\n            fields=[\"id\", \"title\", \"summary\", \"content\", \"author\", \"tags\"],\n            customs=[(\"reading_time\", int, lambda obj: len(obj.content.split()) // 200)]\n        )\n\n@api.viewset(model=models.Article)\nclass ArticleViewSet(APIViewSet):\n    serializer_class = ArticleSerializer\n</code></pre>"},{"location":"release_notes/#m2m-with-serializer_class","title":"M2M with serializer_class","text":"<pre><code>from ninja_aio.models import serializers\nfrom ninja_aio.schemas import M2MRelationSchema\n\nclass TagSerializer(serializers.Serializer):\n    class Meta:\n        model = Tag\n        schema_out = serializers.SchemaModelConfig(fields=[\"id\", \"name\"])\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    m2m_relations = [\n        M2MRelationSchema(\n            model=Tag,                        # plain Django model\n            related_name=\"tags\",\n            serializer_class=TagSerializer,   # auto-generates related_schema\n            add=True,\n            remove=True,\n            get=True,\n        )\n    ]\n</code></pre>"},{"location":"release_notes/#migration-guide","title":"\ud83d\udd0d Migration Guide","text":""},{"location":"release_notes/#using-detail-schemas","title":"Using Detail Schemas","text":"<p>No migration required! Detail schema support is fully backward compatible:</p> <pre><code># Existing code continues to work (no DetailSerializer = uses schema_out for retrieve)\nclass Article(ModelSerializer):\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"content\"]  # Used for both list AND retrieve\n\n# New: Add DetailSerializer for different retrieve response\nclass Article(ModelSerializer):\n    class ReadSerializer:\n        fields = [\"id\", \"title\"]  # Used for list only\n\n    class DetailSerializer:\n        fields = [\"id\", \"title\", \"content\", \"author\", \"tags\"]  # Used for retrieve\n</code></pre>"},{"location":"release_notes/#using-serializer_class-in-m2mrelationschema","title":"Using serializer_class in M2MRelationSchema","text":"<pre><code># Before (v2.7.0) - Must provide related_schema manually\nM2MRelationSchema(\n    model=Tag,\n    related_name=\"tags\",\n    related_schema=TagOut,  # Must define this schema manually\n)\n\n# After (v2.8.0) - Can use serializer_class instead\nM2MRelationSchema(\n    model=Tag,\n    related_name=\"tags\",\n    serializer_class=TagSerializer,  # Auto-generates related_schema!\n)\n</code></pre>"},{"location":"release_notes/#updating-custom-viewset-subclasses","title":"Updating Custom ViewSet Subclasses","text":"<p>If you override <code>get_schemas()</code>, update to return 4-tuple:</p> <pre><code># Before (v2.7.0)\ndef get_schemas(self):\n    return (schema_out, schema_in, schema_update)\n\n# After (v2.8.0)\ndef get_schemas(self):\n    return (schema_out, schema_detail, schema_in, schema_update)\n</code></pre>"},{"location":"release_notes/#when-to-use-detail-schema","title":"\ud83c\udfaf When to Use Detail Schema","text":"<ul> <li>Performance Optimization: Return minimal fields in list views, full details in retrieve</li> <li>API Design: Clients get summaries in lists, full objects on individual requests</li> <li>Expensive Relations: Avoid loading M2M/reverse relations for list endpoints</li> <li>Computed Fields: Only compute expensive fields for single object retrieval</li> <li>Bandwidth Optimization: Reduce payload size for list responses</li> </ul>"},{"location":"release_notes/#performance-benefits","title":"\ud83d\udcca Performance Benefits","text":"Scenario Without Detail Schema With Detail Schema List 100 articles Returns 100 \u00d7 full content Returns 100 \u00d7 summary only Load M2M tags Loaded for all 100 items Only loaded for single retrieve Computed fields Calculated for all items Only calculated on retrieve Response size Large (full content) Optimized per endpoint"},{"location":"release_notes/#important-notes","title":"\u26a0\ufe0f Important Notes","text":"<ul> <li>Fallback Behavior: If <code>DetailSerializer</code>/<code>schema_detail</code> not defined, retrieve uses <code>schema_out</code></li> <li>Schema Generation: <code>generate_detail_s()</code> returns <code>None</code> if no detail config exists</li> <li>Backward Compatibility: All existing code works without changes</li> <li>4-Tuple Return: <code>get_schemas()</code> now returns 4 values instead of 3</li> <li>M2M Validation: Cannot use <code>serializer_class</code> with <code>ModelSerializer</code> models</li> </ul>"},{"location":"release_notes/#acknowledgments","title":"\ud83d\ude4f Acknowledgments","text":"<p>This release focuses on: - Enhanced API design flexibility with separate list/detail schemas - Performance optimization for list endpoints - Better M2M relation configuration options - Improved code organization and maintainability</p>"},{"location":"release_notes/#links","title":"\ud83d\udd17 Links","text":"<ul> <li>Documentation</li> <li>GitHub Repository</li> <li>Issue Tracker</li> <li>v2.7.0 Release Notes</li> </ul>"},{"location":"release_notes/#quick-start-with-detail-schema","title":"\ud83d\udce6 Quick Start with Detail Schema","text":"<pre><code>from ninja_aio.models import ModelSerializer\nfrom ninja_aio.views import APIViewSet\nfrom ninja_aio import NinjaAIO\nfrom django.db import models\n\napi = NinjaAIO(title=\"My API\")\n\n# Step 1: Define your model with ReadSerializer and DetailSerializer\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    summary = models.TextField()\n    content = models.TextField()\n    author = models.ForeignKey(User, on_delete=models.CASCADE)\n    tags = models.ManyToManyField(Tag)\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"summary\"]  # Minimal for list\n\n    class DetailSerializer:\n        fields = [\"id\", \"title\", \"summary\", \"content\", \"author\", \"tags\"]  # Full for retrieve\n\n# Step 2: Create your ViewSet (schemas auto-generated!)\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    pass\n\n# That's it! Your API now has optimized list and detail endpoints:\n# GET /articles/      \u2192 Returns list with minimal fields\n# GET /articles/{pk}  \u2192 Returns single article with all fields\n</code></pre>"},{"location":"release_notes/#version-history","title":"Version History","text":"<p>For older versions, please refer to the GitHub releases page.</p>"},{"location":"release_notes/#release-notes","title":"Release Notes","text":""},{"location":"release_notes/#v270-2026-01-13","title":"[v2.7.0] - 2026-01-13","text":""},{"location":"release_notes/#added","title":"\u2728 Added","text":"<ul> <li>Union Type Support for Polymorphic Relations:</li> <li><code>relations_serializers</code> now accepts <code>Union[SerializerA, SerializerB]</code> to handle polymorphic relationships</li> <li>Enables flexible handling of generic foreign keys, content types, and multi-model relations</li> <li>Direct class references: <code>Union[SerializerA, SerializerB]</code></li> <li>String references: <code>Union[\"SerializerA\", \"SerializerB\"]</code></li> <li>Mixed references: <code>Union[SerializerA, \"SerializerB\"]</code></li> <li>Absolute import paths: <code>Union[\"myapp.serializers.SerializerA\", SerializerB]</code></li> <li>Lazy resolution of union members supports forward/circular dependencies</li> <li> <p>Schema generator creates union of all possible schemas automatically</p> </li> <li> <p>Absolute Import Path Support for String References:</p> </li> <li>String references now support absolute import paths using dot notation</li> <li>Example: <code>\"myapp.serializers.UserSerializer\"</code> or <code>\"users.serializers.UserSerializer\"</code></li> <li>Enables cross-module serializer references without circular import issues</li> <li>Automatic module importing when needed (uses <code>importlib.import_module()</code>)</li> <li>Resolves lazily when schemas are generated</li> <li>Works seamlessly with Union types</li> </ul>"},{"location":"release_notes/#changed","title":"\ud83d\udee0 Changed","text":"<ul> <li>Enhanced Serializer Reference Resolution:</li> <li>Now handles Union types by recursively resolving each member</li> <li>Handles ForwardRef objects created by string type hints in unions (e.g., <code>Union[\"StringType\"]</code>)</li> <li> <p>Optimizes single-type unions by returning the single type directly</p> </li> <li> <p>Enhanced Relation Schema Generation:</p> </li> <li>Generates union schemas when serializer reference is a Union type</li> <li>Maintains full backward compatibility with single serializer references</li> <li> <p>Automatically filters out None schemas from union members</p> </li> <li> <p>Updated Type Hints:</p> </li> <li>All serializer methods updated to reflect Union support</li> <li>Better type safety for Union[Schema, ...] return values</li> <li>Clearer documentation of acceptable input types</li> </ul>"},{"location":"release_notes/#documentation","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Comprehensive Union Types Documentation in docs/api/models/serializers.md:</li> <li> <p>New \"Union Types for Polymorphic Relations\" section:</p> <ul> <li>Complete explanation of Union support with real-world examples</li> <li>Basic polymorphic example with Video and Image serializers</li> <li>All four Union type format variations documented with code samples</li> <li>Use cases: polymorphic relations, flexible APIs, gradual migrations, multi-tenant systems</li> <li>Complete polymorphic example using Django's GenericForeignKey</li> <li>BlogPost/Product/Event example showing complex multi-model relations</li> </ul> </li> <li> <p>New \"String Reference Formats\" section:</p> <ul> <li>Local class name format: <code>\"ArticleSerializer\"</code></li> <li>Absolute import path format: <code>\"myapp.serializers.ArticleSerializer\"</code></li> <li>Requirements and resolution behavior documented</li> <li>Cross-module references example with circular dependencies</li> </ul> </li> <li> <p>Enhanced Configuration Section:</p> <ul> <li><code>relations_serializers</code> parameter updated to document Union support</li> <li>Clear explanation: \"Serializer class, string reference, or Union of serializers\"</li> <li>Forward/circular dependencies and polymorphic relations highlighted</li> <li>Updated comparison table showing Union support feature</li> </ul> </li> <li> <p>Updated Key Features:</p> <ul> <li>Added Union types for polymorphic relations to key features list</li> <li>Updated notes to mention Union type lazy resolution</li> <li>Added note about schema generator creating unions</li> </ul> </li> <li> <p>Code Examples and Best Practices:</p> </li> <li>Video/Image comment example for basic polymorphic relations</li> <li>BlogPost/Product/Event example for complex GenericForeignKey usage</li> <li>Cross-module circular reference example (Article \u2194 User)</li> <li>All four Union format variations with syntax examples</li> </ul>"},{"location":"release_notes/#tests","title":"\ud83e\uddea Tests","text":"<ul> <li> <p>New Comprehensive Test Suite - <code>UnionSerializerTestCase</code> in tests/test_serializers.py</p> </li> <li> <p>Module-Level Test Serializers:</p> </li> <li><code>AltSerializer</code> - Alternative serializer with different field set (id, name)</li> <li><code>AltStringSerializer</code> - String reference test serializer (id, description)</li> <li><code>MixedAltSerializer</code> - Mixed reference test serializer (id, name, description)</li> <li><code>LocalTestSerializer</code> - Local reference test serializer (id only)</li> </ul>"},{"location":"release_notes/#internal-changes","title":"\ud83d\udd27 Internal Changes","text":"<ul> <li>Python 3.10+ Compatibility Fix:</li> <li>Union types created using <code>Union[tuple]</code> syntax for compatibility</li> <li>Replaced incompatible <code>reduce(or_, resolved_types)</code> pattern</li> <li>Works correctly across Python 3.10, 3.11, 3.12+</li> <li>No dependency on <code>functools.reduce</code> or <code>operator.or_</code></li> <li> <p>Uses Python's typing system to expand <code>Union[tuple]</code> automatically</p> </li> <li> <p>Code Organization:</p> </li> <li>Extracted string resolution logic into dedicated <code>_resolve_string_reference()</code> method</li> <li>Extracted union schema generation into dedicated <code>_generate_union_schema()</code> method</li> <li>Improved separation of concerns and code reusability</li> <li>Better error messages with full import paths in exceptions</li> </ul>"},{"location":"release_notes/#use-cases-examples","title":"\ud83d\ude80 Use Cases &amp; Examples","text":""},{"location":"release_notes/#basic-polymorphic-relations","title":"Basic Polymorphic Relations","text":"<pre><code>from typing import Union\nfrom ninja_aio.models import serializers\n\nclass VideoSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Video\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"duration\", \"url\"]\n        )\n\nclass ImageSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Image\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"width\", \"height\", \"url\"]\n        )\n\nclass CommentSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Comment\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"text\", \"content_object\"]\n        )\n        relations_serializers = {\n            \"content_object\": Union[VideoSerializer, ImageSerializer],\n        }\n</code></pre>"},{"location":"release_notes/#cross-module-references","title":"Cross-Module References","text":"<pre><code># myapp/serializers.py\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Article\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"author\"]\n        )\n        relations_serializers = {\n            \"author\": \"users.serializers.UserSerializer\",  # Absolute path\n        }\n\n# users/serializers.py\nclass UserSerializer(serializers.Serializer):\n    class Meta:\n        model = models.User\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"username\", \"articles\"]\n        )\n        relations_serializers = {\n            \"articles\": \"myapp.serializers.ArticleSerializer\",  # Circular ref!\n        }\n</code></pre>"},{"location":"release_notes/#generic-foreign-keys","title":"Generic Foreign Keys","text":"<pre><code>from django.contrib.contenttypes.fields import GenericForeignKey\nfrom typing import Union\n\nclass CommentSerializer(serializers.Serializer):\n    class Meta:\n        model = Comment\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"text\", \"created_at\", \"content_object\"]\n        )\n        relations_serializers = {\n            \"content_object\": Union[\n                BlogPostSerializer,\n                ProductSerializer,\n                EventSerializer\n            ],\n        }\n</code></pre>"},{"location":"release_notes/#migration-guide","title":"\ud83d\udd0d Migration Guide","text":""},{"location":"release_notes/#using-union-types","title":"Using Union Types","text":"<p>No migration needed! Union support is fully backward compatible:</p> <pre><code># Existing code continues to work\nclass MySerializer(serializers.Serializer):\n    class Meta:\n        model = MyModel\n        relations_serializers = {\n            \"author\": AuthorSerializer,  # \u2705 Still works\n        }\n\n# New Union syntax available\nclass MySerializer(serializers.Serializer):\n    class Meta:\n        model = MyModel\n        relations_serializers = {\n            \"content\": Union[VideoSerializer, ImageSerializer],  # \u2705 New!\n        }\n</code></pre>"},{"location":"release_notes/#using-absolute-import-paths","title":"Using Absolute Import Paths","text":"<p>Update string references to use absolute paths for cross-module references:</p> <pre><code># Before (v2.6.1) - Only local references worked\nrelations_serializers = {\n    \"author\": \"AuthorSerializer\",  # Must be in same module\n}\n\n# After (v2.7.0) - Absolute paths supported\nrelations_serializers = {\n    \"author\": \"users.serializers.AuthorSerializer\",  # \u2705 Cross-module!\n}\n</code></pre>"},{"location":"release_notes/#string-reference-formats","title":"String Reference Formats","text":"<p>Both formats are supported:</p> <pre><code>relations_serializers = {\n    # Local reference (same module)\n    \"field1\": \"LocalSerializer\",\n\n    # Absolute import path (any module)\n    \"field2\": \"myapp.serializers.RemoteSerializer\",\n\n    # Union with mixed formats\n    \"field3\": Union[\"LocalSerializer\", \"myapp.other.RemoteSerializer\"],\n}\n</code></pre>"},{"location":"release_notes/#when-to-use-union-types","title":"\ud83c\udfaf When to Use Union Types","text":"<ul> <li>Polymorphic Relations: Generic foreign keys, Django ContentType relations</li> <li>Flexible APIs: Different response formats based on runtime type</li> <li>Gradual Migrations: Transitioning between serializer implementations</li> <li>Multi-Tenant Systems: Different serialization per tenant</li> <li>Dynamic Content: CMS systems with multiple content types</li> <li>Activity Feeds: Mixed content types in single endpoint</li> </ul>"},{"location":"release_notes/#performance-notes","title":"\ud83d\udcca Performance Notes","text":"<ul> <li>Lazy Resolution: Union members resolved only when schemas generated (no startup overhead)</li> <li>Schema Caching: Generated schemas can be cached for better performance</li> <li>Memory Efficient: Only generates schemas for types actually used</li> <li>Import Optimization: Absolute paths only import modules when needed</li> </ul>"},{"location":"release_notes/#important-notes","title":"\u26a0\ufe0f Important Notes","text":"<ul> <li>String References: Resolve within same module by default; use absolute paths for cross-module</li> <li>Union Schema Generation: Creates union of all possible schemas from union members</li> <li>Backward Compatibility: All existing code continues to work without changes</li> <li>Python Version: Requires Python 3.10+ (Union syntax compatibility)</li> <li>Type Validation: Union types provide type hints but runtime validation depends on your model logic</li> </ul>"},{"location":"release_notes/#acknowledgments","title":"\ud83d\ude4f Acknowledgments","text":"<p>This release focuses on: - Enhanced flexibility for polymorphic relationships - Better support for complex project architectures - Improved developer experience with cross-module references - Python 3.10+ compatibility and modern typing features</p>"},{"location":"release_notes/#links","title":"\ud83d\udd17 Links","text":"<ul> <li>Documentation</li> <li>GitHub Repository</li> <li>Issue Tracker</li> <li>v2.6.1 Release Notes</li> </ul>"},{"location":"release_notes/#quick-start-with-union-types","title":"\ud83d\udce6 Quick Start with Union Types","text":"<pre><code>from typing import Union\nfrom ninja_aio.models import serializers\n\n# Step 1: Define your serializers\nclass VideoSerializer(serializers.Serializer):\n    class Meta:\n        model = Video\n        schema_out = serializers.SchemaModelConfig(fields=[\"id\", \"title\", \"url\"])\n\nclass ImageSerializer(serializers.Serializer):\n    class Meta:\n        model = Image\n        schema_out = serializers.SchemaModelConfig(fields=[\"id\", \"title\", \"url\"])\n\n# Step 2: Use Union in relations_serializers\nclass CommentSerializer(serializers.Serializer):\n    class Meta:\n        model = Comment\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"text\", \"content_object\"]\n        )\n        relations_serializers = {\n            \"content_object\": Union[VideoSerializer, ImageSerializer],\n        }\n\n# Step 3: Use with APIViewSet (automatic!)\n@api.viewset(model=Comment)\nclass CommentViewSet(APIViewSet):\n    serializer_class = CommentSerializer\n    # Union types work automatically!\n</code></pre>"},{"location":"release_notes/#version-history","title":"Version History","text":"<p>For older versions, please refer to the GitHub releases page.</p>"},{"location":"release_notes/#release-notes","title":"Release Notes","text":""},{"location":"release_notes/#v261-2026-01-12","title":"[v2.6.1] - 2026-01-12","text":""},{"location":"release_notes/#added","title":"\u2728 Added","text":"<ul> <li>String Reference Support for Relations:</li> <li><code>relations_serializers</code> now accepts string references (e.g., <code>\"ArticleSerializer\"</code>) in addition to class references</li> <li>Enables forward references and circular dependencies between serializers</li> <li> <p>Lazy resolution of serializer references when schemas are generated</p> </li> <li> <p>New Internal Methods:</p> </li> <li><code>BaseSerializer._resolve_serializer_reference()</code> - Resolves string or class serializer references</li> <li><code>BaseSerializer._resolve_relation_schema()</code> - Centralized relation schema resolution logic</li> </ul>"},{"location":"release_notes/#changed","title":"\ud83d\udee0 Changed","text":"<ul> <li>Schema Generation Lifecycle:</li> <li>Removed eager schema generation from <code>Serializer.__init_subclass__()</code></li> <li>Schemas are now generated on-demand via explicit calls to <code>generate_*()</code> methods</li> <li>Removed cached schema properties (<code>.schema_in</code>, <code>.schema_out</code>, <code>.schema_update</code>, <code>.schema_related</code>)</li> <li> <p>Breaking: Must use <code>generate_create_s()</code>, <code>generate_read_s()</code>, etc. instead of accessing properties</p> </li> <li> <p>Internal Refactoring:</p> </li> <li>Replaced <code>match/case</code> with <code>if/elif</code> statements in <code>_generate_model_schema()</code> for better readability</li> <li>Added configuration mapping dictionaries (<code>_SERIALIZER_CONFIG_MAP</code>) to simplify lookups</li> <li>Consolidated duplicate schema resolution logic in relation handling methods</li> <li> <p>Improved code organization with clearer comments and structure</p> </li> <li> <p>APIViewSet Integration:</p> </li> <li>Added <code>serializer</code> instance property initialized from <code>serializer_class()</code></li> <li>Better integration with on-demand schema generation</li> </ul>"},{"location":"release_notes/#documentation","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Updated Serializer Documentation:</li> <li>Added \"String References for Forward/Circular Dependencies\" section with examples</li> <li>Updated \"Schema Generation\" section to clarify on-demand generation</li> <li>Removed outdated references to eager schema generation</li> <li>Updated comparison table: \"Auto-binding\" \u2192 \"Schema generation\"</li> <li> <p>Enhanced configuration section with bold formatting and clearer descriptions</p> </li> <li> <p>Key Documentation Changes:</p> </li> <li>Emphasized that <code>generate_*()</code> methods must be called explicitly</li> <li>Documented string reference requirements (same module, lazy resolution)</li> <li>Added circular dependency example with <code>AuthorSerializer</code> \u2194 <code>ArticleSerializer</code></li> </ul>"},{"location":"release_notes/#breaking-changes-migration-notes","title":"\u26a0 Breaking Changes &amp; Migration Notes","text":""},{"location":"release_notes/#removed-schema-properties","title":"Removed Schema Properties","text":"<p>Schema properties have been removed from <code>Serializer</code> class. You must now explicitly call generation methods:</p> <pre><code># Before (v2.5.0) - NO LONGER WORKS\nArticleSerializer.schema_in       # \u274c AttributeError\nArticleSerializer.schema_out      # \u274c AttributeError\nArticleSerializer.schema_update   # \u274c AttributeError\nArticleSerializer.schema_related  # \u274c AttributeError\n\n# After (v2.6.0) - Explicit generation required\nArticleSerializer.generate_create_s()   # \u2705 Returns create schema\nArticleSerializer.generate_read_s()     # \u2705 Returns read schema\nArticleSerializer.generate_update_s()   # \u2705 Returns update schema\nArticleSerializer.generate_related_s()  # \u2705 Returns related schema\n</code></pre> <p>Note: This change typically doesn't affect user code since these methods are called internally by <code>APIViewSet</code>. Only relevant if you're calling these methods directly.</p>"},{"location":"release_notes/#migration-guide","title":"\ud83d\udd0d Migration Guide","text":""},{"location":"release_notes/#1-update-schema-access-in-custom-code","title":"1. Update Schema Access in Custom Code","text":"<p>If you're directly accessing schema properties, update to use generation methods:</p> <pre><code># Before (v2.5.0)\nclass ArticleViewSet(APIViewSet):\n    def get_schemas(self):\n        return {\n            \"in\": self.serializer_class.schema_in,      # \u274c No longer works\n            \"out\": self.serializer_class.schema_out,    # \u274c No longer works\n        }\n\n# After (v2.6.0)\nclass ArticleViewSet(APIViewSet):\n    def get_schemas(self):\n        return {\n            \"in\": self.serializer_class.generate_create_s(),   # \u2705 Explicit generation\n            \"out\": self.serializer_class.generate_read_s(),    # \u2705 Explicit generation\n        }\n</code></pre>"},{"location":"release_notes/#2-use-string-references-for-circular-dependencies","title":"2. Use String References for Circular Dependencies","text":"<p>Take advantage of string references to simplify circular dependencies:</p> <pre><code># Before (v2.5.0) - Workarounds needed for circular refs\nclass AuthorSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Author\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"name\", \"articles\"]\n        )\n        # Had to carefully order class definitions or use late binding\n\n# After (v2.6.0) - String references make it easy\nclass AuthorSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Author\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"name\", \"articles\"]\n        )\n        relations_serializers = {\n            \"articles\": \"ArticleSerializer\",  # \u2705 Forward reference\n        }\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Article\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"author\"]\n        )\n        relations_serializers = {\n            \"author\": \"AuthorSerializer\",  # \u2705 Circular reference works!\n        }\n</code></pre> <p>String Reference Requirements: - Must be the exact class name as a string - Serializer must be defined in the same module - Resolution happens lazily when <code>generate_*()</code> is called - Both forward and circular references are supported</p>"},{"location":"release_notes/#3-schema-generation-best-practices","title":"3. Schema Generation Best Practices","text":"<p>In APIViewSet (no changes needed):</p> <pre><code># APIViewSet handles schema generation automatically\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    serializer_class = ArticleSerializer\n    # No changes needed - works automatically\n</code></pre> <p>In Custom Code (call generate methods):</p> <pre><code># Explicit schema generation when needed\nfrom ninja import Router\n\nrouter = Router()\n\n@router.post(\"/articles/\", response=ArticleSerializer.generate_read_s())\nasync def create_article(request, payload: ArticleSerializer.generate_create_s()):\n    serializer = ArticleSerializer()\n    instance = await serializer.create(payload.model_dump())\n    return await serializer.model_dump(instance)\n</code></pre> <p>Caching Schemas (if needed for performance):</p> <pre><code># Cache schemas at module level if generating repeatedly\nARTICLE_CREATE_SCHEMA = ArticleSerializer.generate_create_s()\nARTICLE_READ_SCHEMA = ArticleSerializer.generate_read_s()\n\n@router.post(\"/articles/\", response=ARTICLE_READ_SCHEMA)\nasync def create_article(payload: ARTICLE_CREATE_SCHEMA):\n    # Use cached schemas\n    pass\n</code></pre>"},{"location":"release_notes/#4-complete-migration-example","title":"4. Complete Migration Example","text":"<p>Here's a complete before/after example:</p> <pre><code># Before (v2.5.0)\nfrom ninja_aio.models import serializers\nfrom ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\n\nclass AuthorSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Author\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"name\"]\n        )\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Article\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"author\"]\n        )\n        relations_serializers = {\n            \"author\": AuthorSerializer,  # Required class ordering\n        }\n\n# Access schemas (no longer works)\ncreate_schema = ArticleSerializer.schema_in      # \u274c\nread_schema = ArticleSerializer.schema_out       # \u274c\n\n# After (v2.6.0)\nfrom ninja_aio.models import serializers\nfrom ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\n\nclass AuthorSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Author\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"name\", \"articles\"]\n        )\n        relations_serializers = {\n            \"articles\": \"ArticleSerializer\",  # \u2705 String reference\n        }\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Article\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"author\"]\n        )\n        relations_serializers = {\n            \"author\": \"AuthorSerializer\",  # \u2705 Circular reference!\n        }\n\n# Explicit schema generation\ncreate_schema = ArticleSerializer.generate_create_s()  # \u2705\nread_schema = ArticleSerializer.generate_read_s()      # \u2705\n\n# Using with APIViewSet (no changes needed)\napi = NinjaAIO()\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    serializer_class = ArticleSerializer\n    # Automatically works with on-demand generation\n</code></pre>"},{"location":"release_notes/#bug-fixes","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>Fixed lazy resolution issues with forward and circular serializer references</li> <li>Improved error messages when string references cannot be resolved</li> <li>Corrected <code>model_dump()</code> and <code>models_dump()</code> to use explicit schema generation</li> <li>Fixed potential issues with <code>model_util</code> vs <code>util</code> attribute naming</li> </ul>"},{"location":"release_notes/#performance-improvements","title":"\ud83d\ude80 Performance Improvements","text":"<ul> <li>Reduced Initialization Overhead: Schemas only generated when actually needed</li> <li>Memory Efficiency: Unused schemas are never created</li> <li>Lazy Resolution: String references resolved on-demand, reducing startup time</li> <li>Faster Imports: Removed eager schema generation from module import time</li> </ul>"},{"location":"release_notes/#code-quality-improvements","title":"\ud83d\udcca Code Quality Improvements","text":"<ul> <li>Reduced Code Duplication:</li> <li>Extracted common relation resolution logic into <code>_resolve_relation_schema()</code></li> <li>Consolidated duplicate code in <code>_build_schema_reverse_rel()</code> and <code>_build_schema_forward_rel()</code></li> <li> <p>Reduced relation handling code by ~40 lines</p> </li> <li> <p>Improved Maintainability:</p> </li> <li>Replaced <code>match/case</code> with clearer <code>if/elif</code> statements</li> <li>Added configuration mapping dictionaries for cleaner lookups</li> <li>Better code organization with descriptive comments</li> <li> <p>Consistent use of <code>any()</code> for empty checks</p> </li> <li> <p>Better Readability:</p> </li> <li>Flattened nesting in <code>_generate_model_schema()</code></li> <li>Clearer separation between special cases and standard logic</li> <li>Improved docstrings and parameter descriptions</li> <li>More descriptive variable names</li> </ul>"},{"location":"release_notes/#acknowledgments","title":"\ud83d\ude4f Acknowledgments","text":"<p>This release focuses on: - Architectural improvements for forward/circular dependency support - Cleaner, more maintainable internal code structure - On-demand resource generation for better performance - Enhanced developer experience with string references</p>"},{"location":"release_notes/#notes","title":"\ud83d\udcdd Notes","text":"<ul> <li> <p>Schema Generation: While properties were removed, <code>APIViewSet</code> automatically calls <code>generate_*()</code> methods, so most applications won't need code changes</p> </li> <li> <p>Performance: On-demand generation typically improves startup time. If you need schemas multiple times, consider caching them at module level</p> </li> <li> <p>String References: Only resolve within the same module. For cross-module references, use direct class imports</p> </li> <li> <p>Backward Compatibility: Code using <code>APIViewSet</code> continues to work without changes. Direct schema property access will raise <code>AttributeError</code></p> </li> <li> <p>Internal Refactoring: This release includes significant internal refactoring for code quality without changing public APIs (except removal of schema properties)</p> </li> </ul>"},{"location":"release_notes/#links","title":"\ud83d\udd17 Links","text":"<ul> <li>Documentation</li> <li>GitHub Repository</li> <li>Issue Tracker</li> <li>v2.5.0 Release Notes</li> </ul>"},{"location":"release_notes/#upgrade-checklist","title":"\ud83d\udce6 Upgrade Checklist","text":"<p>Use this checklist when upgrading from v2.5.0 to v2.6.0:</p> <ul> <li>[ ] Search codebase for <code>.schema_in</code>, <code>.schema_out</code>, <code>.schema_update</code>, <code>.schema_related</code> property access</li> <li>[ ] Replace with <code>generate_create_s()</code>, <code>generate_read_s()</code>, <code>generate_update_s()</code>, <code>generate_related_s()</code> calls</li> <li>[ ] Update any circular serializer references to use string references</li> <li>[ ] Review custom <code>create()</code> and <code>update()</code> method implementations (if any)</li> <li>[ ] Test all CRUD endpoints to ensure proper functionality</li> <li>[ ] Update any schema caching logic to use explicit generation</li> <li>[ ] Review and update API documentation if it references old property access</li> </ul>"},{"location":"release_notes/#release-notes","title":"Release Notes","text":""},{"location":"release_notes/#v250-2026-01-12","title":"[v2.5.0] - 2026-01-12","text":""},{"location":"release_notes/#added","title":"\u2728 Added","text":"<ul> <li>APIViewSet Enhancements:</li> <li><code>model_verbose_name</code> and <code>model_verbose_name_plural</code> attributes for display name customization</li> <li> <p>Automatic transaction wrapping on create, update, and delete operations</p> </li> <li> <p>ModelUtil Query Methods:</p> </li> <li>New properties:<ul> <li><code>with_serializer</code> - Check if serializer_class is attached</li> <li><code>pk_field_type</code> - Python type corresponding to the primary key field</li> <li><code>model_name</code> - Django internal model name</li> </ul> </li> </ul>"},{"location":"release_notes/#changed","title":"\ud83d\udee0 Changed","text":"<ul> <li>APIViewSet:</li> <li>CRUD views now automatically decorated with <code>@aatomic</code> for transactional integrity</li> <li> <p>Enhanced <code>get_schemas()</code> method for unified schema generation from both ModelSerializer and Serializer</p> </li> <li> <p>ModelUtil:</p> </li> <li> <p>Query optimization merging logic improved to respect both model and serializer configurations</p> </li> <li> <p>Serializer Lifecycle Hooks:</p> </li> <li>All Serializer hooks now consistently receive <code>instance</code> parameter</li> <li>Inline execution of before/after save hooks integrated with <code>@aatomic</code> decorator</li> <li>Hook signatures standardized: <code>custom_actions(payload, instance)</code>, <code>post_create(instance)</code>, <code>before_save(instance)</code>, etc.</li> </ul>"},{"location":"release_notes/#documentation","title":"\ud83d\udcdd Documentation","text":"<ul> <li>New Documentation Pages:</li> <li>Transaction Management section in APIViewSet docs</li> <li>Extra Decorators section with examples and configuration</li> <li>Enhanced ModelUtil properties documentation</li> <li> <p>Query method parameter documentation with detailed examples</p> </li> <li> <p>Enhanced Content:</p> </li> <li>APIViewSet Core Attributes table updated with new fields</li> <li>Serializer lifecycle hooks section with complete signature examples</li> <li>ModelUtil method signatures with all parameters documented</li> <li>CRUD operation flows documented for Serializer pattern</li> </ul>"},{"location":"release_notes/#breaking-changes-migration-notes","title":"\u26a0 Breaking Changes &amp; Migration Notes","text":""},{"location":"release_notes/#transaction-behavior-new-default","title":"Transaction Behavior (New Default)","text":"<p>Create, update, and delete operations are now automatically wrapped in database transactions:</p> <pre><code># Automatic transaction wrapping (new in v2.5.0)\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    pass  # create/update/delete wrapped in @aatomic\n</code></pre> <p>Migration: If you were manually managing transactions in lifecycle hooks, you may encounter nested transaction issues. Remove manual transaction management:</p> <pre><code># Before (v2.4.0)\nasync def post_create(self, instance):\n    async with transaction.atomic():  # Remove this\n        await AuditLog.objects.acreate(...)\n\n# After (v2.5.0)\nasync def post_create(self, instance):\n    # Transaction already managed by @aatomic\n    await AuditLog.objects.acreate(...)\n</code></pre>"},{"location":"release_notes/#serializer-hook-signatures","title":"Serializer Hook Signatures","text":"<p>Added Serializer hooks signatures, they are standardized to always receive <code>instance</code>:</p> <pre><code># v2.5.0 - Standardized (always receive instance)\nclass MySerializer(Serializer):\n    async def custom_actions(self, payload, instance):\n        # instance parameter required\n        pass\n\n    async def post_create(self, instance):\n        # instance parameter required\n        pass\n\n    def before_save(self, instance):\n        # instance parameter required\n        pass\n\n    def after_save(self, instance):\n        # instance parameter required\n        pass\n\n    def on_delete(self, instance):\n        # instance parameter required\n        pass\n</code></pre>"},{"location":"release_notes/#migration-guide","title":"\ud83d\udd0d Migration Guide","text":""},{"location":"release_notes/#1-updating-serializer-lifecycle-hooks","title":"1. Updating Serializer Lifecycle Hooks","text":"<p>If you're using Serializer (Meta-driven pattern), update hook signatures to receive <code>instance</code> parameter:</p> <pre><code>from ninja_aio.models import serializers\nfrom asgiref.sync import sync_to_async\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = Article\n        schema_in = serializers.SchemaModelConfig(\n            fields=[\"title\", \"content\", \"author\"],\n            customs=[(\"send_notification\", bool, True)]\n        )\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"content\", \"author\", \"created_at\"]\n        )\n\n    # Async hooks - receive instance parameter\n    async def custom_actions(self, payload, instance):\n        \"\"\"Execute custom logic after field assignment.\"\"\"\n        if payload.get(\"send_notification\"):\n            # Access instance fields\n            await send_email(\n                instance.author.email,\n                f\"Article created: {instance.title}\"\n            )\n\n    async def post_create(self, instance):\n        \"\"\"Hook after first save (creation only).\"\"\"\n        await AuditLog.objects.acreate(\n            action=\"article_created\",\n            article_id=instance.id,\n            user_id=instance.author_id\n        )\n\n    # Sync hooks - also receive instance parameter\n    def before_save(self, instance):\n        \"\"\"Modify instance before save.\"\"\"\n        from django.utils.text import slugify\n        if not instance.slug:\n            instance.slug = slugify(instance.title)\n\n    def after_save(self, instance):\n        \"\"\"Execute logic after save.\"\"\"\n        # Clear cache\n        from django.core.cache import cache\n        cache.delete(f\"article:{instance.id}\")\n\n    def on_create_before_save(self, instance):\n        \"\"\"Before save, creation only.\"\"\"\n        instance.view_count = 0\n\n    def on_create_after_save(self, instance):\n        \"\"\"After save, creation only.\"\"\"\n        # Log creation\n        import logging\n        logger = logging.getLogger(__name__)\n        logger.info(f\"Article {instance.id} created\")\n\n    def on_delete(self, instance):\n        \"\"\"After deletion.\"\"\"\n        import logging\n        logger = logging.getLogger(__name__)\n        logger.info(f\"Article {instance.id} deleted\")\n</code></pre> <p>Key Points: - All hooks receive <code>instance</code> as a parameter - Async hooks: <code>custom_actions(payload, instance)</code>, <code>post_create(instance)</code> - Sync hooks: <code>before_save(instance)</code>, <code>after_save(instance)</code>, <code>on_delete(instance)</code> - Creation-specific hooks: <code>on_create_before_save(instance)</code>, <code>on_create_after_save(instance)</code></p>"},{"location":"release_notes/#2-configuring-queryset-optimization","title":"2. Configuring QuerySet Optimization","text":"<p>Add QuerySet configuration to your Serializer or ModelSerializer for automatic query optimization:</p> <pre><code>from ninja_aio.models import serializers\nfrom ninja_aio.schemas.helpers import ModelQuerySetSchema, ModelQuerySetExtraSchema\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = Article\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"content\", \"author\", \"category\", \"tags\"]\n        )\n        relations_serializers = {\n            \"author\": AuthorSerializer,\n            \"category\": CategorySerializer,\n            \"tags\": TagSerializer,\n        }\n\n    class QuerySet:\n        # Applied to list and retrieve operations\n        read = ModelQuerySetSchema(\n            select_related=[\"author\", \"category\"],\n            prefetch_related=[\"tags\"],\n        )\n\n        # Applied when queryset_request hook is called\n        queryset_request = ModelQuerySetSchema(\n            select_related=[\"author__profile\"],\n            prefetch_related=[\"comments\", \"comments__author\"],\n        )\n\n        # Named scopes for specific use cases\n        extras = [\n            ModelQuerySetExtraSchema(\n                scope=\"detail_view\",\n                select_related=[\"author\", \"author__profile\", \"category\"],\n                prefetch_related=[\"tags\", \"comments\", \"comments__author\"],\n            ),\n            ModelQuerySetExtraSchema(\n                scope=\"list_view\",\n                select_related=[\"author\", \"category\"],\n                prefetch_related=[\"tags\"],\n            ),\n        ]\n\n    @classmethod\n    async def queryset_request(cls, request):\n        \"\"\"\n        Optional: Customize queryset based on request.\n        Automatically enhanced with QuerySet.queryset_request optimizations.\n        \"\"\"\n        qs = cls._meta.model.objects.all()\n\n        # Filter based on user permissions\n        if not request.user.is_staff:\n            qs = qs.filter(is_published=True)\n\n        # Add request-specific filters\n        if request.GET.get(\"featured\"):\n            qs = qs.filter(is_featured=True)\n\n        return qs\n</code></pre> <p>For ModelSerializer:</p> <pre><code>from ninja_aio.models import ModelSerializer\nfrom ninja_aio.schemas.helpers import ModelQuerySetSchema\nfrom django.db import models\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    author = models.ForeignKey(User, on_delete=models.CASCADE)\n    category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True)\n    tags = models.ManyToManyField(Tag, related_name=\"articles\")\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"content\", \"author\", \"category\", \"tags\"]\n\n    class QuerySet:\n        read = ModelQuerySetSchema(\n            select_related=[\"author\", \"category\"],\n            prefetch_related=[\"tags\"],\n        )\n        queryset_request = ModelQuerySetSchema(\n            select_related=[\"author__profile\"],\n            prefetch_related=[\"comments\"],\n        )\n\n    @classmethod\n    async def queryset_request(cls, request):\n        \"\"\"Optimize queries for this model.\"\"\"\n        return cls.objects.select_related(\"author\", \"category\")\n</code></pre> <p>How QuerySet Configuration Works:</p> <ol> <li><code>read</code>: Applied automatically to list and retrieve operations when <code>is_for_read=True</code></li> <li><code>queryset_request</code>: Applied when <code>with_qs_request=True</code> (default) in <code>get_objects()</code> or <code>get_object()</code></li> <li><code>extras</code>: Named scopes accessible via <code>QueryUtil.SCOPES</code> for custom scenarios</li> <li>Merging: Optimizations from multiple sources are merged (no duplicates)</li> </ol> <p>Benefits: - Eliminates N+1 queries automatically - Centralizes query optimization configuration - Works with both ModelSerializer and Serializer patterns - Optimizations apply to all CRUD operations</p>"},{"location":"release_notes/#3-customizing-model-display-names","title":"3. Customizing Model Display Names","text":"<p>Override verbose names without modifying models:</p> <pre><code>@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    model_verbose_name = \"Blog Post\"\n    model_verbose_name_plural = \"Blog Posts\"\n    # OpenAPI will use \"Blog Post\" instead of \"Article\"\n</code></pre>"},{"location":"release_notes/#bug-fixes","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>Fixed query optimization merging when both model and serializer provide hints</li> <li>Corrected <code>read_s()</code> behavior when both <code>instance</code> and <code>query_data</code> provided (now raises clear error)</li> <li>Improved error messages for missing primary key in <code>get_object()</code></li> <li>Fixed duplicate route registration with <code>@unique_view</code> decorator</li> </ul>"},{"location":"release_notes/#performance-improvements","title":"\ud83d\ude80 Performance Improvements","text":"<ul> <li>Transaction management with <code>@aatomic</code> reduces database round-trips</li> <li>Query optimization merging eliminates redundant select_related/prefetch_related</li> <li><code>with_qs_request</code> parameter allows skipping hook when not needed</li> </ul>"},{"location":"release_notes/#acknowledgments","title":"\ud83d\ude4f Acknowledgments","text":"<p>This release focuses on: - Enhanced transaction safety - Flexible query control - Per-operation customization - Comprehensive documentation</p>"},{"location":"release_notes/#notes","title":"\ud83d\udcdd Notes","text":"<ul> <li> <p>Backward Compatibility: All v2.4.0 code continues to work. New parameters have sensible defaults.</p> </li> <li> <p>Transaction Overhead: The <code>@aatomic</code> decorator adds minimal overhead. If you need non-transactional operations, override the view methods directly.</p> </li> <li> <p>Query Parameters: <code>with_qs_request</code> defaults to <code>True</code> to maintain v2.4.0 behavior. Set to <code>False</code> to skip the queryset_request hook.</p> </li> <li> <p>Serializer Hooks: If migrating from v2.4.0 Serializer usage, ensure all hooks accept the <code>instance</code> parameter.</p> </li> </ul>"},{"location":"release_notes/#links","title":"\ud83d\udd17 Links","text":"<ul> <li>Documentation</li> <li>GitHub Repository</li> <li>Issue Tracker</li> <li>v2.4.0 Release Notes</li> </ul>"},{"location":"release_notes/#release-notes","title":"Release Notes","text":""},{"location":"release_notes/#v240-2026-01-09","title":"[v2.4.0] - 2026-01-09","text":""},{"location":"release_notes/#added","title":"\u2728 Added","text":"<ul> <li>Serializer (Meta-driven):</li> <li>New Serializer for vanilla Django models configured via nested Meta (no ModelSerializer inheritance).</li> <li>Dynamic schema generation helpers: generate_read_s, generate_create_s, generate_update_s, generate_related_s.</li> <li>Relation handling via relations_serializers for forward and reverse relations.</li> <li>APIViewSet:</li> <li>serializer_class to auto-generate missing schemas for non-ModelSerializer models and drive queryset_request.</li> <li>ModelUtil:</li> <li>Accepts serializer_class to build querysets using Serializer.queryset_request when provided.</li> <li>Docs/README:</li> <li>New docs page: api/models/serializers.md with usage and examples.</li> <li>README sections/examples for Meta-driven Serializer.</li> <li>MkDocs nav entry for Serializer.</li> <li>Tests:</li> <li>Serializer tests (forward and reverse relations).</li> <li>Viewset tests using serializer_class-backed endpoints.</li> </ul>"},{"location":"release_notes/#changed","title":"\ud83d\udee0 Changed","text":"<ul> <li>Package layout:</li> <li>ninja_aio/models/init.py now exports ModelUtil and ModelSerializer.</li> <li>models.py refactored to models/utils.py; ModelSerializer moved to models/serializers.py.</li> <li>API internals:</li> <li>APIViewSet.compute_schema generates schemas from serializer_class for vanilla models; retains model-backed generation for ModelSerializer.</li> <li>ModelUtil.get_queryset_request uses serializer_class when provided.</li> <li>Docs:</li> <li>Index formatting tweaks; added links and examples for Serializer docs.</li> </ul>"},{"location":"release_notes/#documentation","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Serializer (Meta-driven):</li> <li>Configure via Meta: model, schema_in, schema_out, schema_update, relations_serializers.</li> <li>Examples for FK and reverse relations; customs and optionals.</li> <li>APIViewSet:</li> <li>Using serializer_class to auto-generate schemas and plug into queryset_request.</li> <li>README:</li> <li>Quick example attaching Serializer to APIViewSet.</li> <li>MkDocs:</li> <li>Added nav entry under Models: Serializer (Meta-driven).</li> </ul>"},{"location":"release_notes/#notes-potential-impact","title":"\u26a0 Notes / Potential Impact","text":"<ul> <li>Relation serializers:</li> <li>Reverse relations on vanilla models need relations_serializers entries to include nested schemas; otherwise skipped unless the related model is a ModelSerializer.</li> <li>A UserWarning is emitted when a reverse relation is listed without a mapping; suppressed in tests via NINJA_AIO_TESTING=True.</li> <li>Refactor:</li> <li>Imports may need updates due to ModelUtil relocation and new serializers module.</li> </ul>"},{"location":"release_notes/#migration-action","title":"\ud83d\udd0d Migration / Action","text":"<ol> <li>Define a Meta-driven Serializer for existing Django models and attach it to APIViewSet via serializer_class.</li> <li>Provide relations_serializers for reverse relations to include nested schemas on read.</li> <li>Update imports:    - from ninja_aio.models import ModelUtil, ModelSerializer    - from ninja_aio.models.serializers import Serializer, SchemaModelConfig</li> <li>If relying on queryset_request with vanilla models, implement Serializer.queryset_request; APIViewSet and ModelUtil will use it automatically.</li> </ol>"},{"location":"release_notes/#v232-2026-01-08","title":"[v2.3.2] - 2026-01-08","text":""},{"location":"release_notes/#added","title":"\u2728 Added","text":"<ul> <li>Support Url pydantic field serialization</li> <li>Support for django ninja until 1.6</li> </ul>"},{"location":"release_notes/#v231-2026-01-07","title":"[v2.3.1] - 2026-01-07","text":""},{"location":"release_notes/#added","title":"\u2728 Added","text":"<ul> <li>CI/Docs Deployment:</li> <li>GitHub workflow updated to recognize and manage version \"2.3\" for docs deploy/delete.</li> <li>Documentation/README:</li> <li>Added link to the external example repository: https://github.com/caspel26/ninja-aio-blog-example.</li> </ul>"},{"location":"release_notes/#changed","title":"\ud83d\udee0 Changed","text":"<ul> <li>README/Docs:</li> <li>Switched examples to decorator-first style with <code>@api.viewset(Model)</code> and in-class method decorators (e.g., <code>@api_post</code>).</li> <li>Removed explicit <code>api = api</code> and <code>model = ...</code> from examples where <code>@api.viewset(...)</code> is used; emphasized automatic registration.</li> <li>Cleaned and reformatted examples and quick links table; clarified usage in the index page and decorators page.</li> <li>Packaging:</li> <li>Python version spec adjusted from <code>&gt;=3.10, &lt;=3.14</code> to <code>&gt;=3.10, &lt;3.15</code> in pyproject metadata.</li> </ul>"},{"location":"release_notes/#removed","title":"\ud83d\uddd1 Removed","text":"<ul> <li>In-repo example apps:</li> <li>Deleted <code>examples/ex_1</code> and <code>examples/ex_2</code> (models, views, urls, and auth). Examples are now hosted in the external repository linked in the README.</li> </ul>"},{"location":"release_notes/#documentation","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Index and README updated to prefer <code>@api.viewset(Model)</code> and decorator-based custom endpoints.</li> <li>Decorators page (<code>docs/api/views/decorators.md</code>) revised to reflect decorator-first usage.</li> <li>Added references to the external example repository for complete, runnable samples.</li> </ul>"},{"location":"release_notes/#release-notes","title":"Release Notes","text":""},{"location":"release_notes/#v230-2026-01-04","title":"[v2.3.0] - 2026-01-04","text":""},{"location":"release_notes/#added","title":"\u2728 Added","text":"<ul> <li>Decorators:</li> <li>New operation decorators for class methods: <code>api_get</code>, <code>api_post</code>, <code>api_put</code>, <code>api_patch</code>, <code>api_delete</code>, <code>api_options</code>, <code>api_head</code> (import from <code>ninja_aio.decorators</code>).</li> <li>Utilities: <code>decorate_view</code>, <code>aatomic</code>, <code>unique_view</code> (now under <code>ninja_aio.decorators</code>).</li> <li>Factory-backed decorators ensure clean OpenAPI signatures (exclude <code>self</code>) and support extra decorators like pagination.</li> <li>Views:</li> <li>APIView/APIViewSet auto-register decorated methods via lazy binding; no manual <code>add_views_to_route()</code> when using <code>@api.view</code> / <code>@api.viewset</code>.</li> <li>APIViewSet supports global trailing slash setting via <code>settings.NINJA_AIO_APPEND_SLASH</code> (default True).</li> <li>M2M:</li> <li><code>M2MRelationSchema.append_slash</code> to control trailing slash on the GET relation route.</li> <li>Relation path normalization for consistent URLs whether <code>path</code> includes leading slash or not.</li> <li>Tests/Examples:</li> <li>Added decorator-based examples and tests for custom endpoints on views and viewsets.</li> </ul>"},{"location":"release_notes/#changed","title":"\ud83d\udee0 Changed","text":"<ul> <li>README/Docs:</li> <li>Prefer <code>@api.viewset(Model)</code> with decorator-based endpoints; legacy <code>views()</code> remains supported.</li> <li>Clarified trailing slash behavior for CRUD retrieve paths and M2M relations.</li> <li>Decorator-first examples across APIView and APIViewSet pages; cleaner OpenAPI notes.</li> <li>API internals:</li> <li>Base API class now binds decorator-registered methods via <code>_add_views()</code>; APIView/APIViewSet call <code>super()._add_views()</code> before legacy <code>views()</code>.</li> <li>APIViewSet path generation respects <code>NINJA_AIO_APPEND_SLASH</code> for retrieve path (<code>/{pk}/</code> vs <code>/{pk}</code>).</li> <li>Exceptions/Helpers:</li> <li>Added docstrings for clearer behavior in exceptions, query helpers, and schemas.</li> </ul>"},{"location":"release_notes/#documentation","title":"\ud83d\udcdd Documentation","text":"<ul> <li>APIView/APIViewSet:</li> <li>Decorator-first usage with examples; automatic lazy registration; signature preservation.</li> <li>Decorators:</li> <li>Using operation decorators with extra decorators (e.g., <code>paginate(PageNumberPagination)</code>, <code>unique_view(name)</code>).</li> <li>ViewSet relations:</li> <li>Per-relation <code>append_slash</code>; path normalization rules; trailing slash settings.</li> <li>README:</li> <li>Simplified setup: <code>@api.viewset(Model)</code> and decorator-based custom endpoints.</li> </ul>"},{"location":"release_notes/#notes-potential-impact","title":"\u26a0 Notes / Potential Impact","text":"<ul> <li>Trailing slash:</li> <li>Global <code>NINJA_AIO_APPEND_SLASH</code> defaults to True. Disable to remove trailing slash from retrieve paths.</li> <li>M2M GET relation endpoints default to no trailing slash; enable per relation with <code>append_slash=True</code>.</li> <li>Registration:</li> <li>When using <code>@api.view</code> / <code>@api.viewset</code>, endpoints defined via decorators are mounted automatically; avoid redundant manual registration.</li> <li>OpenAPI:</li> <li>Decorator-backed handlers exclude <code>self</code> and preserve type hints for cleaner specs.</li> </ul>"},{"location":"release_notes/#migration-action","title":"\ud83d\udd0d Migration / Action","text":"<ol> <li>Adopt decorators for extra endpoints:    - APIView: annotate the class with <code>@api.view(...)</code>, then decorate methods with <code>@api_get(\"/path\", ...)</code>.    - APIViewSet: annotate with <code>@api.viewset(Model, ...)</code>, then use <code>@api_get(\"/path\", ...)</code>, <code>@api_post(...)</code>, etc.</li> <li>Trailing slash configuration:    - Set <code>NINJA_AIO_APPEND_SLASH=False</code> in Django settings to drop trailing slash on retrieve paths globally.    - For M2M GET relations, use <code>M2MRelationSchema(append_slash=True/False)</code> to control trailing slash.</li> <li>Legacy support:    - <code>views()</code> continues to work; prefer decorators for clearer code and better OpenAPI.</li> <li>Docs/examples:    - Update references to new decorator modules and follow decorator-first examples.</li> </ol>"},{"location":"release_notes/#release-notes","title":"Release Notes","text":""},{"location":"release_notes/#220-2026-01-03","title":"[2.2.0] - 2026-01-03","text":""},{"location":"release_notes/#added","title":"\u2728 Added","text":"<ul> <li>API:</li> <li>Decorators: <code>NinjaAIO.view(prefix, tags)</code> and <code>NinjaAIO.viewset(model, prefix, tags)</code> for automatic registration.</li> <li>Base API class: shared attributes for APIView and APIViewSet (api, router_tags, api_route_path).</li> <li>Views:</li> <li>APIView: supports constructor args <code>(api, prefix, tags)</code> with <code>router_tags</code> and standardized <code>error_codes</code>.</li> <li>APIViewSet: constructor <code>(api, model, prefix, tags)</code>; infers base path from model when not provided; <code>router_tags</code> support.</li> <li>Auth:</li> <li>JwtKeys type expands to include <code>jwk.OctKey</code> (HMAC).</li> <li><code>validate_key</code> accepts <code>jwk.OctKey</code>.</li> <li><code>encode_jwt</code>/<code>decode_jwt</code> type hints generalized to <code>JwtKeys</code>.</li> <li>Tests:</li> <li>Added decorator-based tests for APIView and APIViewSet (ModelSerializer and plain Django model).</li> <li>Updated ManyToMany tests to construct viewset with <code>api</code> argument.</li> <li>Docs:</li> <li>APIView and APIViewSet docs: \u201cRecommended\u201d decorator-based examples.</li> <li>Mixins doc moved to <code>docs/api/views/mixins.md</code>.</li> <li>Index updated with modern ModelSchema-based examples and async ORM usage.</li> </ul>"},{"location":"release_notes/#changed","title":"\ud83d\udee0 Changed","text":"<ul> <li>Version:</li> <li>Bumped to 2.2.0 in <code>ninja_aio/__init__.py</code>.</li> <li>Error codes:</li> <li>Standardized to {400, 401, 404}; removed 428 references in code and docs.</li> <li>Docs:</li> <li><code>docs/api/authentication.md</code>: use list-based auth <code>[JWTAuth(), APIKeyAuth()]</code> instead of bitwise OR.</li> <li><code>docs/api/views/api_view.md</code> and <code>api_view_set.md</code>: emphasize decorator usage; cleaner examples; notes updated.</li> <li>MkDocs nav: Mixins path updated to <code>api/views/mixins.md</code>.</li> <li>API internals:</li> <li>APIView/APIViewSet refactored to share base attributes, constructor supports <code>api</code>, <code>prefix</code>, and <code>tags</code>.</li> <li>Docs workflow:</li> <li><code>mike set-default --push latest</code> when MAKE_LATEST is true.</li> <li>Packaging:</li> <li>Python requirement set to <code>&gt;=3.10, &lt;=3.14</code> in <code>pyproject.toml</code>.</li> </ul>"},{"location":"release_notes/#documentation","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Updated:</li> <li>Authentication: list-based auth configuration and clarified behavior.</li> <li>APIView/APIViewSet: decorator-first usage, async compatibility, and standard error codes.</li> <li>Index: ModelSchema In/Out patterns with async ORM examples.</li> <li>Moved:</li> <li>Mixins doc to <code>api/views/mixins.md</code>; MkDocs navigation adjusted.</li> </ul>"},{"location":"release_notes/#notes-potential-impact","title":"\u26a0 Notes / Potential Impact","text":"<ul> <li>Error handling:</li> <li>428 code removed; rely on {400, 401, 404}.</li> <li>Auth configuration:</li> <li>Use lists for multiple auth methods; bitwise OR in docs deprecated.</li> <li>Docs deployment:</li> <li>Default alias set to \u201clatest\u201d on deploy when MAKE_LATEST=true.</li> <li>Python compatibility:</li> <li>Upper bound set to 3.14.</li> </ul>"},{"location":"release_notes/#migration-action","title":"\ud83d\udd0d Migration / Action","text":"<ol> <li>Adopt decorators:    - APIView: <code>@api.view(prefix=\"/path\", tags=[...])</code>    - APIViewSet: <code>@api.viewset(model=MyModel, prefix=\"/path\", tags=[...])</code></li> <li>Update auth configuration:    - HMAC keys supported via <code>jwk.OctKey</code> where applicable.</li> <li>Error codes:    - Remove references/handlers for 428; standardize to {400, 401, 404}.</li> <li>Docs links:    - Update references to Mixins at <code>api/views/mixins.md</code>.</li> <li>Runtime:    - Ensure Python version is &lt;= 3.14 per <code>pyproject.toml</code>.</li> </ol>"},{"location":"release_notes/#release-notes","title":"Release Notes","text":""},{"location":"release_notes/#210-2026-01-01","title":"[2.1.0] - 2026-01-01","text":""},{"location":"release_notes/#added","title":"\u2728 Added","text":"<ul> <li>Views:</li> <li>ReadOnlyViewSet: list and retrieve-only endpoints.</li> <li>WriteOnlyViewSet: create, update, and delete-only endpoints.</li> <li>Exported via <code>ninja_aio.views.__init__</code> for cleaner imports.</li> <li>Mixins:</li> <li>New filtering mixins under <code>ninja_aio/views/mixins.py</code>: IcontainsFilterViewSetMixin, BooleanFilterViewSetMixin, NumericFilterViewSetMixin, DateFilterViewSetMixin, and specialized Greater/Less variants.</li> <li>Auth docs:</li> <li>New <code>docs/auth.md</code> with JWT helpers and <code>AsyncJwtBearer</code> usage and configuration.</li> <li>Tests:</li> <li>Extended test model with <code>age</code>, <code>active</code>, and <code>active_from</code> fields.</li> <li>Added viewset tests for mixins (icontains, boolean, numeric, date comparisons).</li> <li>Added auth tests for JWT encode/decode and AsyncJwtBearer claim validation.</li> <li>Docs navigation:</li> <li>Added Mixins page and JWT &amp; AsyncJwtBearer page to MkDocs nav.</li> <li>MkDocs <code>mike</code> config sets <code>default: latest</code>.</li> </ul>"},{"location":"release_notes/#changed","title":"\ud83d\udee0 Changed","text":"<ul> <li>Docs workflow (<code>.github/workflows/docs.yml</code>):</li> <li>Safer deletion: requires explicit <code>delete_version</code> choice and <code>delete_confirm</code>, protects <code>latest</code>, <code>stable</code>, and current default.</li> <li><code>make_latest</code> default set to false.</li> <li>Coverage workflow:</li> <li>Bump <code>codecov/codecov-action</code> from v5.5.1 to v5.5.2.</li> <li>API helpers:</li> <li>Use <code>decorate_view</code> to compose <code>unique_view</code> and <code>paginate</code> for related GET endpoints.</li> <li>APIViewSet (imports and behavior):</li> <li>Module reorganized to <code>ninja_aio/views/api.py</code> with updated internal imports.</li> <li><code>get_schemas</code>: generates schemas only if missing when model is a <code>ModelSerializerMeta</code>, else returns explicitly set schemas.</li> <li>Hook docs clarified to allow sync or async handlers for query params.</li> <li>Auth:</li> <li><code>encode_jwt</code>: header now includes <code>kid</code> only when present (conditional merge).</li> <li>Docs:</li> <li><code>docs/api/views/api_view_set.md</code> updated to document ReadOnlyViewSet and WriteOnlyViewSet.</li> <li><code>docs/mixins.md</code> aligned with implemented mixins and examples.</li> </ul>"},{"location":"release_notes/#documentation","title":"\ud83d\udcdd Documentation","text":"<ul> <li>New:</li> <li>JWT &amp; AsyncJwtBearer guide with examples for settings and direct JWK usage.</li> <li>Updated:</li> <li>Mixins reference to match implemented classes and recommended query param types.</li> <li>APIViewSet docs extended with ReadOnly/WriteOnly usage.</li> </ul>"},{"location":"release_notes/#notes-potential-impact","title":"\u26a0 Notes / Potential Impact","text":"<ul> <li>Docs deployment:</li> <li>Deletion requires explicit confirmation and cannot remove protected aliases or current default.</li> <li>Mixins:</li> <li>Date filters expect values that implement <code>isoformat</code>; prefer Pydantic <code>date</code>/<code>datetime</code> in query params.</li> </ul>"},{"location":"release_notes/#migration-action","title":"\ud83d\udd0d Migration / Action","text":"<ol> <li>Update imports:    - <code>from ninja_aio.views import APIViewSet, ReadOnlyViewSet, WriteOnlyViewSet</code>    - <code>from ninja_aio.views import mixins</code> for filter mixins.</li> <li>For related list endpoints using custom decorators, consider adopting <code>decorate_view</code> for consistent composition.</li> <li>If using JWT:    - Optionally set <code>JWT_PRIVATE_KEY</code>, <code>JWT_PUBLIC_KEY</code>, <code>JWT_ISSUER</code>, <code>JWT_AUDIENCE</code> in Django settings.    - Validate claims via <code>AsyncJwtBearer.claims</code> registry and verify allowed algorithms.</li> <li>Review docs workflow inputs before deleting versions; use <code>delete_confirm: true</code>.</li> </ol>"},{"location":"release_notes/#release-notes","title":"Release Notes","text":""},{"location":"release_notes/#200-2025-12-16","title":"[2.0.0] - 2025-12-16","text":""},{"location":"release_notes/#added","title":"\u2728 Added","text":"<ul> <li>QueryUtil and query scopes:</li> <li>New <code>QueryUtil</code> with <code>SCOPES</code> (READ, QUERYSET_REQUEST, plus extras) and <code>apply_queryset_optimizations</code>.</li> <li><code>ModelSerializer.query_util</code> bound per model via <code>__init_subclass__</code>.</li> <li><code>ModelSerializer.QuerySet</code> supports <code>read</code>, <code>queryset_request</code>, <code>extras</code>.</li> <li>Query schemas:</li> <li><code>QuerySchema</code>, <code>ObjectQuerySchema</code>, <code>ObjectsQuerySchema</code>, <code>ModelQuerySetSchema</code>, <code>ModelQuerySetExtraSchema</code>, <code>QueryUtilBaseScopesSchema</code>.</li> <li>ModelUtil:</li> <li><code>get_objects(...)</code>: optimized queryset fetching with filters and select/prefetch hints.</li> <li><code>get_object(...)</code>: single-object retrieval by pk or getters with optimizations.</li> <li><code>read_s(...)</code> and <code>list_read_s(...)</code>: serialize instances or auto-fetch via query schemas.</li> <li>Relation discovery helpers: <code>get_select_relateds()</code>, <code>get_reverse_relations()</code>.</li> <li>PK type resolution: <code>pk_field_type</code> with helpful error for unknown field types.</li> <li>ManyToManyAPI:</li> <li>GET related endpoints return <code>{items: [...], count: N}</code>.</li> <li>Relation filter handlers accept sync or async functions.</li> <li>Related items use <code>ModelUtil.list_read_s</code> for serialization.</li> <li>Per-relation single-object resolution handler for POST: <code>&lt;related_name&gt;_query_handler(...)</code>.</li> <li>Schemas modularization:</li> <li>New modules: <code>ninja_aio/schemas/api.py</code>, <code>ninja_aio/schemas/generics.py</code>, and exported names under <code>ninja_aio/schemas/__init__.py</code>.</li> <li>Decorators:</li> <li><code>decorate_view</code> utility to compose multiple decorators (sync/async), skipping <code>None</code>.</li> <li><code>APIViewSet.extra_decorators</code> via <code>DecoratorsSchema</code> for per-operation decoration.</li> <li>Renderer:</li> <li>ORJSON renderer option via <code>settings.NINJA_AIO_ORJSON_RENDERER_OPTION</code> (bitmask, supports <code>|</code>).</li> </ul>"},{"location":"release_notes/#changed","title":"\ud83d\udee0 Changed","text":"<ul> <li>APIViewSet:</li> <li>List uses <code>ModelUtil.get_objects</code> and <code>list_read_s</code> with read optimizations; filter hooks retained.</li> <li>Retrieve uses <code>read_s</code> with <code>QuerySchema(getters={\"pk\": ...})</code>.</li> <li>Path PK schema type inferred from model PK via <code>ModelUtil.pk_field_type</code>.</li> <li>Default read query data comes from <code>ModelSerializer.QuerySet.read</code> via <code>query_util</code>.</li> <li>Built-ins and custom decorators composed with <code>decorate_view</code> (e.g., <code>paginate</code>, <code>unique_view</code>, extras).</li> <li>ModelSerializer:</li> <li>Binds <code>util = ModelUtil(cls)</code> and <code>query_util = QueryUtil(cls)</code> to subclasses.</li> <li><code>queryset_request</code> applies configured optimizations from <code>QuerySet.queryset_request</code>.</li> <li>ModelUtil internals:</li> <li>Unified <code>_apply_query_optimizations</code> merges explicit select/prefetch with auto-discovered relations when <code>is_for_read=True</code>.</li> <li>Serialization paths standardized through internal helpers; <code>read_s</code>/<code>list_read_s</code> accept <code>schema</code> first.</li> <li>Auth:</li> <li><code>AsyncJwtBearer.verify_token</code> simplifies error handling; drops explicit <code>AuthError</code>.</li> <li>Imports:</li> <li><code>ManyToManyAPI</code> consumed from <code>ninja_aio/helpers/api.py</code>.</li> <li>Runtime requirements:</li> <li>Upper bounds added: <code>django-ninja &lt;=1.5.1</code>, <code>joserfc &lt;=1.4.1</code>, <code>orjson &lt;=3.11.5</code>.</li> <li>Docs and site:</li> <li>MkDocs/mike integration for versioned docs; new workflow <code>docs.yml</code>.</li> </ul>"},{"location":"release_notes/#breaking-changes","title":"\ud83d\udd34 Breaking Changes","text":"<ul> <li>Path PK schema type:</li> <li>PK type is inferred from the model PK. Code relying on <code>int | str</code> in path schemas may need adjustments.</li> <li>ManyToMany GET response shape:</li> <li>Response changed from a plain list to <code>{items: [...], count: N}</code>. Clients must adapt parsing.</li> <li>Import paths:</li> <li>Schema helpers moved under <code>ninja_aio/schemas/helpers.py</code> and re-exported by <code>ninja_aio/schemas/__init__.py</code>.</li> <li><code>ManyToManyAPI</code> import is now <code>from ninja_aio.helpers.api import ManyToManyAPI</code>.</li> <li>ModelUtil read API:</li> <li><code>read_s</code> and <code>list_read_s</code> signatures accept <code>schema</code> first and support <code>instance</code> or <code>query_data</code>. Code passing <code>(request, obj, schema)</code> must switch to <code>(schema, request, instance=obj)</code>.</li> </ul>"},{"location":"release_notes/#documentation","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Updated:</li> <li>ModelUtil reference: QuerySet config, QueryUtil, query schemas, <code>get_objects</code>, <code>get_object</code>, <code>read_s</code>, <code>list_read_s</code>.</li> <li>APIViewSet: list/retrieve flow, PK type inference, M2M GET envelope, async/sync filter handlers, operation decorators.</li> <li>Tutorial (model): QuerySet config and <code>query_util</code> examples; fetch/serialize using query schemas.</li> <li>Index: overview of query optimizations and schemas.</li> <li>ORJSON renderer: configuration guide.</li> </ul>"},{"location":"release_notes/#notes-potential-impact","title":"\u26a0 Notes / Potential Impact","text":"Area Observation Impact Query optimizations <code>is_for_read=True</code> merges explicit and auto-discovered relations. More joins/prefetches; re-check performance for heavy endpoints. Requirements caps Upper bounds added for core deps. Ensure compatible versions in your environment. Decorator order <code>decorate_view</code> applies standard Python stacking order. Verify nesting with <code>paginate</code>, <code>unique_view</code>, and custom decorators."},{"location":"release_notes/#migration-action","title":"\ud83d\udd0d Migration / Action","text":"<ol> <li>Update imports:    - <code>from ninja_aio.schemas.helpers import QuerySchema, ObjectQuerySchema, ObjectsQuerySchema, ModelQuerySetSchema, ModelQuerySetExtraSchema</code>    - <code>from ninja_aio.helpers.api import ManyToManyAPI</code></li> <li>Adjust M2M GET consumers to handle <code>{items, count}</code>.</li> <li>Update <code>read_s</code>/<code>list_read_s</code> calls to new parameter order.</li> <li>Verify path PK handling in custom routes that relied on a generic PK type.</li> <li>Review <code>QuerySet.read</code> / <code>QuerySet.queryset_request</code> for desired select/prefetch behavior.</li> <li>Optionally configure ORJSON via <code>NINJA_AIO_ORJSON_RENDERER_OPTION</code>.</li> </ol>"},{"location":"api/authentication/","title":"Authentication","text":"<p>Django Ninja Aio CRUD provides built-in async JWT authentication support with flexible configuration and easy integration with your API endpoints.</p>"},{"location":"api/authentication/#overview","title":"Overview","text":"<p>Authentication in Django Ninja Aio CRUD:</p> <ul> <li> Fully Async \u2014 No blocking operations</li> <li> JWT-Based \u2014 Industry-standard JSON Web Tokens</li> <li> Type-Safe \u2014 Proper type hints and validation</li> <li> Flexible \u2014 Per-endpoint or global authentication</li> <li> Customizable \u2014 Override default behavior</li> <li> RSA/HMAC Support \u2014 Multiple signing algorithms</li> </ul>"},{"location":"api/authentication/#quick-start","title":"Quick Start","text":""},{"location":"api/authentication/#1-create-authentication-class","title":"1. Create Authentication Class","text":"Python<pre><code># auth.py\nfrom ninja_aio.auth import AsyncJwtBearer\nfrom joserfc import jwk\n\nPUBLIC_KEY = \"\"\"-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...\n-----END PUBLIC KEY-----\"\"\"\n\n\nclass JWTAuth(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(PUBLIC_KEY)\n    claims = {\n        \"iss\": {\"essential\": True, \"value\": \"https://your-issuer.com\"},\n        \"aud\": {\"essential\": True, \"value\": \"your-api\"}\n    }\n\n    async def auth_handler(self, request):\n        user_id = self.dcd.claims.get(\"sub\")\n        user = await User.objects.aget(id=user_id)\n        return user\n</code></pre>"},{"location":"api/authentication/#2-apply-to-viewset","title":"2. Apply to ViewSet","text":"Python<pre><code># views.py\nfrom ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom .models import Article\nfrom .auth import JWTAuth\n\napi = NinjaAIO()\n\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    auth = [JWTAuth()]  # Apply to all endpoints\n</code></pre>"},{"location":"api/authentication/#3-make-authenticated-request","title":"3. Make Authenticated Request","text":"Bash<pre><code>curl -H \"Authorization: Bearer eyJhbGciOiJSUzI1NiIs...\" \\\n     http://localhost:8000/api/article/\n</code></pre>"},{"location":"api/authentication/#asyncjwtbearer","title":"AsyncJwtBearer","text":"<p>Base class for JWT authentication.</p>"},{"location":"api/authentication/#class-definition","title":"Class Definition","text":"Python<pre><code>from ninja_aio.auth import AsyncJwtBearer\nfrom joserfc import jwk\n\nclass MyAuth(AsyncJwtBearer):\n    jwt_public: jwk.RSAKey | jwk.OctKey  # Public key for verification\n    jwt_alg: str = \"RS256\"  # Signing algorithm\n    claims: dict = {}  # Required claims\n\n    async def auth_handler(self, request):\n        # Return user object or custom auth context\n        pass\n</code></pre>"},{"location":"api/authentication/#required-attributes","title":"Required Attributes","text":""},{"location":"api/authentication/#jwt_public","title":"<code>jwt_public</code>","text":"<p>Public key for JWT verification.</p> <p>RSA Key (Recommended):</p> Python<pre><code>from joserfc import jwk\n\nPUBLIC_KEY = \"\"\"-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...\n-----END PUBLIC KEY-----\"\"\"\n\nclass JWTAuth(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(PUBLIC_KEY)\n    jwt_alg = \"RS256\"\n</code></pre> <p>HMAC Key (Shared Secret):</p> Python<pre><code>from joserfc import jwk\n\nSECRET = \"your-secret-key\"\n\nclass JWTAuth(AsyncJwtBearer):\n    jwt_public = jwk.OctKey.import_key(SECRET)\n    jwt_alg = \"HS256\"\n</code></pre> <p>From JWK (JSON Web Key):</p> Python<pre><code>import json\nfrom joserfc import jwk\n\njwk_data = {\n    \"kty\": \"RSA\",\n    \"n\": \"xGOr-H7A-PWgPZ...\",\n    \"e\": \"AQAB\",\n    \"alg\": \"RS256\",\n    \"use\": \"sig\"\n}\n\nclass JWTAuth(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(jwk_data)\n</code></pre>"},{"location":"api/authentication/#jwt_alg","title":"<code>jwt_alg</code>","text":"<p>JWT signing algorithm (optional, default: <code>\"RS256\"</code>).</p> <p>Supported Algorithms:</p> Algorithm Type Description <code>RS256</code> RSA RSA Signature with SHA-256 (recommended) <code>RS384</code> RSA RSA Signature with SHA-384 <code>RS512</code> RSA RSA Signature with SHA-512 <code>HS256</code> HMAC HMAC with SHA-256 <code>HS384</code> HMAC HMAC with SHA-384 <code>HS512</code> HMAC HMAC with SHA-512 <code>ES256</code> ECDSA ECDSA with SHA-256 <code>ES384</code> ECDSA ECDSA with SHA-384 <code>ES512</code> ECDSA ECDSA with SHA-512 Python<pre><code>class JWTAuth(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(PUBLIC_KEY)\n    jwt_alg = \"RS512\"  # Use RS512 instead of default RS256\n</code></pre>"},{"location":"api/authentication/#claims","title":"<code>claims</code>","text":"<p>Dictionary of required JWT claims for validation.</p> <p>Claim Options:</p> Key Type Description <code>essential</code> <code>bool</code> Claim must be present <code>value</code> <code>Any</code> Exact value required <code>values</code> <code>list</code> One of the values required <p>Examples:</p> Python<pre><code>class JWTAuth(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(PUBLIC_KEY)\n    claims = {\n        # Issuer must be exact match\n        \"iss\": {\n            \"essential\": True,\n            \"value\": \"https://auth.example.com\"\n        },\n        # Audience must be one of these\n        \"aud\": {\n            \"essential\": True,\n            \"values\": [\"api-prod\", \"api-staging\"]\n        },\n        # Subject must be present (any value)\n        \"sub\": {\n            \"essential\": True\n        },\n        # Optional claim with default\n        \"scope\": {\n            \"essential\": False,\n            \"value\": \"read\"\n        }\n    }\n</code></pre>"},{"location":"api/authentication/#required-methods","title":"Required Methods","text":""},{"location":"api/authentication/#auth_handler","title":"<code>auth_handler()</code>","text":"<p>Process authenticated request and return user/auth context.</p> <p>Signature:</p> Python<pre><code>async def auth_handler(self, request: HttpRequest) -&gt; Any\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>request</code> <code>HttpRequest</code> Django HTTP request <p>Return Value:</p> <p>Object attached to <code>request.auth</code> (typically User instance).</p> <p>Access to JWT Data:</p> <ul> <li><code>self.dcd</code> - Decoded JWT claims</li> <li><code>self.dcd.claims</code> - Claims dictionary</li> <li><code>self.dcd.header</code> - JWT header</li> </ul> <p>Examples:</p> <p>Return User Object:</p> Python<pre><code>async def auth_handler(self, request):\n    user_id = self.dcd.claims.get(\"sub\")\n    user = await User.objects.aget(id=user_id)\n    return user\n\n# In view\nasync def my_view(request):\n    user = request.auth  # User instance\n    print(user.username)\n</code></pre> <p>Return Custom Context:</p> Python<pre><code>async def auth_handler(self, request):\n    return {\n        \"user_id\": self.dcd.claims.get(\"sub\"),\n        \"email\": self.dcd.claims.get(\"email\"),\n        \"roles\": self.dcd.claims.get(\"roles\", []),\n        \"scopes\": self.dcd.claims.get(\"scope\", \"\").split()\n    }\n\n# In view\nasync def my_view(request):\n    context = request.auth\n    print(context[\"user_id\"])\n    print(context[\"roles\"])\n</code></pre> <p>With Additional Validation:</p> Python<pre><code>async def auth_handler(self, request):\n    user_id = self.dcd.claims.get(\"sub\")\n\n    # Check if user exists and is active\n    try:\n        user = await User.objects.aget(id=user_id, is_active=True)\n    except User.DoesNotExist:\n        return False\n\n    # Check subscription status\n    if not await user.has_active_subscription():\n        return False\n\n    return user\n</code></pre> <p>With Caching:</p> Python<pre><code>from django.core.cache import cache\n\nasync def auth_handler(self, request):\n    user_id = self.dcd.claims.get(\"sub\")\n\n    # Try cache first\n    cache_key = f\"user:{user_id}\"\n    user = cache.get(cache_key)\n\n    if user is None:\n        user = await User.objects.aget(id=user_id)\n        cache.set(cache_key, user, 300)  # Cache 5 minutes\n\n    return user\n</code></pre>"},{"location":"api/authentication/#authentication-levels","title":"Authentication Levels","text":""},{"location":"api/authentication/#global-authentication","title":"Global Authentication","text":"<p>Apply authentication to all endpoints in a ViewSet:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    auth = [JWTAuth()]  # All endpoints require auth\n</code></pre> <p>Generated Endpoints:</p> Method Endpoint Auth Required GET <code>/article/</code> \u2713 POST <code>/article/</code> \u2713 GET <code>/article/{id}</code> \u2713 PATCH <code>/article/{id}/</code> \u2713 DELETE <code>/article/{id}/</code> \u2713"},{"location":"api/authentication/#per-method-authentication","title":"Per-Method Authentication","text":"<p>Apply authentication to specific HTTP methods:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    get_auth = None  # GET endpoints public\n    post_auth = [JWTAuth()]  # POST requires auth\n    patch_auth = [JWTAuth()]  # PATCH requires auth\n    delete_auth = [JWTAuth()]  # DELETE requires auth\n</code></pre> <p>Generated Endpoints:</p> Method Endpoint Auth Required GET <code>/article/</code> \u2717 (public) POST <code>/article/</code> \u2713 GET <code>/article/{id}</code> \u2717 (public) PATCH <code>/article/{id}/</code> \u2713 DELETE <code>/article/{id}/</code> \u2713"},{"location":"api/authentication/#custom-view-authentication","title":"Custom View Authentication","text":"<p>Apply authentication to custom views:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    auth = None  # CRUD endpoints public\n\n    def views(self):\n        # Authenticated custom endpoint\n        @self.router.post(\"/publish/{pk}/\", auth=JWTAuth())\n        async def publish(request, pk: int):\n            article = await Article.objects.aget(pk=pk)\n            article.is_published = True\n            await article.asave()\n            return {\"message\": \"Article published\"}\n\n        # Public custom endpoint\n        @self.router.get(\"/stats/\")\n        async def stats(request):\n            total = await Article.objects.acount()\n            return {\"total\": total}\n</code></pre>"},{"location":"api/authentication/#mixed-authentication","title":"Mixed Authentication","text":"<p>Combine different authentication strategies:</p> Python<pre><code>class AdminAuth(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(PUBLIC_KEY)\n\n    async def auth_handler(self, request):\n        user_id = self.dcd.claims.get(\"sub\")\n        user = await User.objects.aget(id=user_id)\n        if not user.is_staff:\n            return False\n        return user\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    get_auth = None  # Public read\n    post_auth = [JWTAuth()]  # Regular user can create\n    patch_auth = [JWTAuth()]  # Regular user can edit own\n    delete_auth = [AdminAuth()]  # Only admin can delete\n</code></pre>"},{"location":"api/authentication/#advanced-usage","title":"Advanced Usage","text":""},{"location":"api/authentication/#role-based-access-control-rbac","title":"Role-Based Access Control (RBAC)","text":"Python<pre><code>class RoleAuth(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(PUBLIC_KEY)\n    required_roles: list[str] = []\n\n    async def auth_handler(self, request):\n        user_id = self.dcd.claims.get(\"sub\")\n        user = await User.objects.aget(id=user_id)\n\n        # Check roles\n        user_roles = self.dcd.claims.get(\"roles\", [])\n        if self.required_roles:\n            if not any(role in user_roles for role in self.required_roles):\n                return False\n\n        request.user_roles = user_roles\n        return user\n\n\nclass AdminAuth(RoleAuth):\n    required_roles = [\"admin\"]\n\n\nclass EditorAuth(RoleAuth):\n    required_roles = [\"editor\", \"admin\"]\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    get_auth = None\n    post_auth = [EditorAuth()]  # Editors and admins\n    delete_auth = [AdminAuth()]  # Only admins\n</code></pre>"},{"location":"api/authentication/#permission-based-access","title":"Permission-Based Access","text":"Python<pre><code>class PermissionAuth(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(PUBLIC_KEY)\n    required_permissions: list[str] = []\n\n    async def auth_handler(self, request):\n        user_id = self.dcd.claims.get(\"sub\")\n        user = await User.objects.select_related('role').aget(id=user_id)\n\n        # Get user permissions\n        permissions = await sync_to_async(list)(\n            user.role.permissions.values_list('code', flat=True)\n        )\n\n        # Check permissions\n        if self.required_permissions:\n            missing = set(self.required_permissions) - set(permissions)\n            if missing:\n                return False\n        request.permissions = permissions\n        return user\n\n\nclass ArticleCreateAuth(PermissionAuth):\n    required_permissions = [\"article.create\"]\n\n\nclass ArticleDeleteAuth(PermissionAuth):\n    required_permissions = [\"article.delete\"]\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    post_auth = [ArticleCreateAuth()]\n    delete_auth = [ArticleDeleteAuth()]\n</code></pre>"},{"location":"api/authentication/#tenantorganization-isolation","title":"Tenant/Organization Isolation","text":"Python<pre><code>class TenantAuth(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(PUBLIC_KEY)\n\n    async def auth_handler(self, request):\n        user_id = self.dcd.claims.get(\"sub\")\n        tenant_id = self.dcd.claims.get(\"tenant_id\")\n\n        if not tenant_id:\n            return False\n\n        user = await User.objects.aget(\n            id=user_id,\n            tenant_id=tenant_id,\n            is_active=True\n        )\n\n        request.tenant_id = tenant_id\n        return user\n\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    tenant = models.ForeignKey(Tenant, on_delete=models.CASCADE)\n\n    @classmethod\n    async def queryset_request(cls, request):\n        # Automatically filter by tenant\n        qs = cls.objects.all()\n        if hasattr(request, 'tenant_id'):\n            qs = qs.filter(tenant_id=request.tenant_id)\n        return qs\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    auth = [TenantAuth()]\n</code></pre>"},{"location":"api/authentication/#scope-based-access","title":"Scope-Based Access","text":"Python<pre><code>class ScopeAuth(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(PUBLIC_KEY)\n    required_scopes: list[str] = []\n\n    async def auth_handler(self, request):\n        # Get scopes from token\n        scope_str = self.dcd.claims.get(\"scope\", \"\")\n        scopes = scope_str.split()\n\n        # Check required scopes\n        if self.required_scopes:\n            missing = set(self.required_scopes) - set(scopes)\n            if missing:\n                return False\n\n        user_id = self.dcd.claims.get(\"sub\")\n        user = await User.objects.aget(id=user_id)\n\n        request.scopes = scopes\n        return user\n\n\nclass ReadAuth(ScopeAuth):\n    required_scopes = [\"read\"]\n\n\nclass WriteAuth(ScopeAuth):\n    required_scopes = [\"write\"]\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    get_auth = [ReadAuth()]  # read scope\n    post_auth = [WriteAuth()]  # write scope\n    patch_auth = [WriteAuth()]  # write scope\n    delete_auth = [WriteAuth()]  # write scope\n</code></pre>"},{"location":"api/authentication/#api-key-authentication","title":"API Key Authentication","text":"<p>For machine-to-machine communication:</p> Python<pre><code>from ninja.security import APIKeyHeader\n\n\nclass APIKeyAuth(APIKeyHeader):\n    param_name = \"X-API-Key\"\n\n    async def authenticate(self, request, key):\n        try:\n            api_key = await APIKey.objects.select_related('user').aget(\n                key=key,\n                is_active=True\n            )\n\n            # Check expiration\n            if api_key.expires_at and api_key.expires_at &lt; timezone.now():\n                return None\n\n            # Update last used\n            api_key.last_used_at = timezone.now()\n            await api_key.asave(update_fields=['last_used_at'])\n\n            return api_key.user\n        except APIKey.DoesNotExist:\n            return None\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    auth = [APIKeyAuth()]\n</code></pre> <p>Usage:</p> Bash<pre><code>curl -H \"X-API-Key: your-api-key-here\" \\\n     http://localhost:8000/api/article/\n</code></pre>"},{"location":"api/authentication/#multiple-authentication-methods","title":"Multiple Authentication Methods","text":"<p>Support both JWT and API Key:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    auth = [JWTAuth(), APIKeyAuth()]  # Either JWT or API Key\n</code></pre> <p>Django Ninja will try both methods; if either succeeds, the request is authenticated.</p>"},{"location":"api/authentication/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Use RSA (asymmetric) keys for production: Python<pre><code>jwt_public = jwk.RSAKey.import_key(PUBLIC_KEY)\njwt_alg = \"RS256\"\n</code></pre></p> </li> <li> <p>Validate essential claims: Python<pre><code>claims = {\n    \"iss\": {\"essential\": True, \"value\": \"your-issuer\"},\n    \"aud\": {\"essential\": True, \"value\": \"your-api\"},\n    \"sub\": {\"essential\": True}\n}\n</code></pre></p> </li> <li> <p>Keep tokens short-lived: Python<pre><code># In your token issuer\nexp = datetime.utcnow() + timedelta(minutes=15)  # 15 min access token\n</code></pre></p> </li> <li> <p>Cache user objects: Python<pre><code>async def auth_handler(self, request):\n    user_id = self.dcd.claims.get(\"sub\")\n    cache_key = f\"user:{user_id}\"\n    user = cache.get(cache_key)\n    if not user:\n        user = await User.objects.aget(id=user_id)\n        cache.set(cache_key, user, 300)\n    return user\n</code></pre></p> </li> <li> <p>Log authentication failures: Python<pre><code>async def auth_handler(self, request):\n    try:\n        user = await User.objects.aget(id=user_id)\n        return user\n    except User.DoesNotExist:\n        logger.warning(f\"Auth failed for user_id: {user_id}\")\n        return False\n</code></pre></p> </li> <li> <p>Use different auth for different operations: Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    get_auth = None  # Public read\n    post_auth = [UserAuth()]  # User can create\n    delete_auth = [AdminAuth()]  # Only admin can delete\n</code></pre></p> </li> <li> <p>Implement rate limiting for auth endpoints: Python<pre><code>from ninja.throttling import AnonRateThrottle\n\n@api.post(\"/login/\", throttle=[AnonRateThrottle('5/minute')])\nasync def login(request, credentials: LoginSchema):\n    # Login logic\n    pass\n</code></pre></p> </li> </ol>"},{"location":"api/authentication/#integration-examples","title":"Integration Examples","text":""},{"location":"api/authentication/#with-auth0","title":"With Auth0","text":"Python<pre><code>import httpx\nfrom joserfc import jwk\n\n\nclass Auth0JWT(AsyncJwtBearer):\n    jwt_alg = \"RS256\"\n\n    def __init__(self):\n        super().__init__()\n        # Fetch JWKS from Auth0\n        self.domain = \"your-domain.auth0.com\"\n        self.audience = \"your-api-identifier\"\n\n    async def get_jwks(self):\n        async with httpx.AsyncClient() as client:\n            response = await client.get(\n                f\"https://{self.domain}/.well-known/jwks.json\"\n            )\n            return response.json()\n\n    claims = {\n        \"iss\": {\"essential\": True, \"value\": \"https://your-domain.auth0.com/\"},\n        \"aud\": {\"essential\": True, \"value\": \"your-api-identifier\"}\n    }\n\n    async def auth_handler(self, request):\n        user_id = self.dcd.claims.get(\"sub\")\n        # Extract user info from token or fetch from database\n        return {\"user_id\": user_id, \"email\": self.dcd.claims.get(\"email\")}\n</code></pre>"},{"location":"api/authentication/#with-keycloak","title":"With Keycloak","text":"Python<pre><code>class KeycloakJWT(AsyncJwtBearer):\n    jwt_alg = \"RS256\"\n\n    def __init__(self):\n        super().__init__()\n        self.realm_url = \"https://keycloak.example.com/realms/your-realm\"\n\n    async def get_public_key(self):\n        async with httpx.AsyncClient() as client:\n            response = await client.get(f\"{self.realm_url}\")\n            data = response.json()\n            return jwk.RSAKey.import_key(data[\"public_key\"])\n\n    claims = {\n        \"iss\": {\"essential\": True, \"value\": \"https://keycloak.example.com/realms/your-realm\"},\n        \"azp\": {\"essential\": True, \"value\": \"your-client-id\"}\n    }\n\n    async def auth_handler(self, request):\n        user_id = self.dcd.claims.get(\"sub\")\n        roles = self.dcd.claims.get(\"realm_access\", {}).get(\"roles\", [])\n        return {\n            \"user_id\": user_id,\n            \"roles\": roles,\n            \"email\": self.dcd.claims.get(\"email\")\n        }\n</code></pre>"},{"location":"api/authentication/#with-firebase","title":"With Firebase","text":"Python<pre><code>import google.auth.transport.requests\nfrom google.oauth2 import id_token\n\n\nclass FirebaseAuth(HttpBearer):\n    def __init__(self):\n        self.project_id = \"your-firebase-project\"\n\n    async def authenticate(self, request, token):\n        try:\n            # Verify Firebase ID token\n            decoded_token = id_token.verify_firebase_token(\n                token,\n                google.auth.transport.requests.Request(),\n                audience=self.project_id\n            )\n\n            user_id = decoded_token[\"uid\"]\n            user = await User.objects.aget(firebase_uid=user_id)\n            return user\n        except Exception as e:\n            return None\n</code></pre>"},{"location":"api/authentication/#see-also","title":"See Also","text":"<ul> <li> <p> APIViewSet</p> <p> Applying auth to ViewSets</p> </li> <li> <p> Tutorial</p> <p> Step-by-step auth guide</p> </li> <li> <p> ModelSerializer</p> <p> Filtering by user</p> </li> </ul>"},{"location":"api/pagination/","title":"Pagination","text":"<p>Django Ninja Aio CRUD provides built-in async pagination support for efficiently handling large datasets in your API responses.</p>"},{"location":"api/pagination/#overview","title":"Overview","text":"<p>Pagination in Django Ninja Aio CRUD:</p> <ul> <li> Fully async \u2014 No blocking database queries</li> <li> Customizable \u2014 Override default behavior per ViewSet</li> <li> Type-safe \u2014 Proper type hints and validation</li> <li> Automatic \u2014 Works out of the box with APIViewSet</li> <li> Flexible \u2014 Support for multiple pagination styles</li> </ul>"},{"location":"api/pagination/#default-pagination","title":"Default Pagination","text":""},{"location":"api/pagination/#pagenumberpagination","title":"PageNumberPagination","text":"<p>The default pagination class used by <code>APIViewSet</code>.</p> <p>Features:</p> <ul> <li>Page-based navigation</li> <li>Configurable page size</li> <li>Total count included</li> <li>Next/previous page info</li> </ul> <p>Default Configuration:</p> Parameter Default Description <code>page</code> <code>1</code> Current page number <code>page_size</code> <code>10</code> Items per page <code>max_page_size</code> <code>100</code> Maximum allowed page size"},{"location":"api/pagination/#response-format","title":"Response Format","text":"JSON<pre><code>{\n  \"count\": 45,\n  \"next\": 3,\n  \"previous\": 1,\n  \"results\": [\n    {\n      \"id\": 11,\n      \"title\": \"Article 11\",\n      \"created_at\": \"2024-01-15T10:30:00Z\"\n    },\n    {\n      \"id\": 12,\n      \"title\": \"Article 12\",\n      \"created_at\": \"2024-01-15T11:00:00Z\"\n    }\n  ]\n}\n</code></pre> <p>Response Fields:</p> Field Type Description <code>count</code> <code>int</code> Total number of items <code>next</code> <code>int \\| None</code> Next page number (null if last page) <code>previous</code> <code>int \\| None</code> Previous page number (null if first page) <code>results</code> <code>list</code> Array of items for current page"},{"location":"api/pagination/#basic-usage","title":"Basic Usage","text":""},{"location":"api/pagination/#with-apiviewset","title":"With APIViewSet","text":"<p>Pagination is automatically applied to list endpoints:</p> Python<pre><code>from ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom .models import Article\n\napi = NinjaAIO()\n\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    pass\n</code></pre> <p>Generated endpoint:</p> Text Only<pre><code>GET /article/?page=1&amp;page_size=10\n</code></pre>"},{"location":"api/pagination/#manual-usage","title":"Manual Usage","text":"Python<pre><code>from ninja.pagination import PageNumberPagination\nfrom django.http import HttpRequest\n\nasync def my_view(request: HttpRequest):\n    # Get queryset\n    queryset = Article.objects.all()\n\n    # Create paginator\n    paginator = PageNumberPagination()\n\n    # Paginate (accepts query params from request)\n    result = await paginator.apaginate_queryset(\n        queryset=queryset,\n        pagination=paginator,\n        request=request\n    )\n\n    return result\n</code></pre>"},{"location":"api/pagination/#query-parameters","title":"Query Parameters","text":""},{"location":"api/pagination/#page","title":"page","text":"<p>Current page number (1-indexed).</p> Bash<pre><code>GET /article/?page=2\n</code></pre> <p>Validation:</p> <ul> <li>Must be &gt;= 1</li> <li>Returns 404 if page doesn't exist</li> </ul>"},{"location":"api/pagination/#page_size","title":"page_size","text":"<p>Number of items per page.</p> Bash<pre><code>GET /article/?page=1&amp;page_size=20\n</code></pre> <p>Validation:</p> <ul> <li>Must be &gt;= 1</li> <li>Cannot exceed <code>max_page_size</code></li> <li>Defaults to pagination class default</li> </ul>"},{"location":"api/pagination/#examples","title":"Examples","text":"<p>First page with 10 items:</p> Bash<pre><code>GET /article/?page=1&amp;page_size=10\n</code></pre> <p>Second page with 25 items:</p> Bash<pre><code>GET /article/?page=2&amp;page_size=25\n</code></pre> <p>Maximum items per page:</p> Bash<pre><code>GET /article/?page=1&amp;page_size=100\n</code></pre>"},{"location":"api/pagination/#custom-pagination","title":"Custom Pagination","text":""},{"location":"api/pagination/#override-default-page-size","title":"Override Default Page Size","text":"Python<pre><code>from ninja.pagination import PageNumberPagination\n\n\nclass LargePagePagination(PageNumberPagination):\n    page_size = 50  # Default 50 items per page\n    max_page_size = 200  # Allow up to 200 items\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    pagination_class = LargePagePagination\n</code></pre>"},{"location":"api/pagination/#small-page-size-for-mobile","title":"Small Page Size for Mobile","text":"Python<pre><code>class MobilePagination(PageNumberPagination):\n    page_size = 5\n    max_page_size = 20\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    pagination_class = MobilePagination\n</code></pre>"},{"location":"api/pagination/#asyncpaginationbase","title":"AsyncPaginationBase","text":"<p>Base class for creating custom pagination.</p>"},{"location":"api/pagination/#class-definition","title":"Class Definition","text":"Python<pre><code>from ninja.pagination import AsyncPaginationBase\n\nclass MyPagination(AsyncPaginationBase):\n    page_size: int = 10\n    max_page_size: int = 100\n\n    async def apaginate_queryset(\n        self,\n        queryset,\n        pagination,\n        request=None,\n        **params\n    ):\n        # Custom pagination logic\n        pass\n</code></pre>"},{"location":"api/pagination/#required-methods","title":"Required Methods","text":""},{"location":"api/pagination/#apaginate_queryset","title":"<code>apaginate_queryset()</code>","text":"<p>Main pagination method that processes the queryset.</p> <p>Signature:</p> Python<pre><code>async def apaginate_queryset(\n    self,\n    queryset: QuerySet,\n    pagination: AsyncPaginationBase,\n    request: HttpRequest = None,\n    **params\n) -&gt; dict\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>queryset</code> <code>QuerySet</code> Django queryset to paginate <code>pagination</code> <code>AsyncPaginationBase</code> Pagination instance <code>request</code> <code>HttpRequest</code> HTTP request object <code>**params</code> <code>dict</code> Additional parameters <p>Returns:</p> <p>Dictionary with pagination metadata and results.</p>"},{"location":"api/pagination/#custom-pagination-examples","title":"Custom Pagination Examples","text":""},{"location":"api/pagination/#cursor-based-pagination","title":"Cursor-Based Pagination","text":"Python<pre><code>from ninja.pagination import AsyncPaginationBase\nfrom ninja import Schema\n\n\nclass CursorPaginationSchema(Schema):\n    cursor: str | None = None\n    page_size: int = 10\n\n\nclass CursorPagination(AsyncPaginationBase):\n    page_size = 10\n    max_page_size = 100\n\n    async def apaginate_queryset(self, queryset, pagination, request=None, **params):\n        cursor = params.get('cursor')\n        page_size = min(params.get('page_size', self.page_size), self.max_page_size)\n\n        # Apply cursor filtering\n        if cursor:\n            queryset = queryset.filter(id__gt=cursor)\n\n        # Fetch items + 1 to check if there's next page\n        items = []\n        async for item in queryset[:page_size + 1]:\n            items.append(item)\n\n        has_next = len(items) &gt; page_size\n        results = items[:page_size]\n\n        next_cursor = None\n        if has_next and results:\n            next_cursor = str(results[-1].id)\n\n        return {\n            \"next_cursor\": next_cursor,\n            \"results\": results\n        }\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    pagination_class = CursorPagination\n</code></pre> <p>Usage:</p> Bash<pre><code># First page\nGET /article/?page_size=10\n\n# Next page\nGET /article/?cursor=10&amp;page_size=10\n</code></pre> <p>Response:</p> JSON<pre><code>{\n  \"next_cursor\": \"20\",\n  \"results\": [...]\n}\n</code></pre>"},{"location":"api/pagination/#offset-based-pagination","title":"Offset-Based Pagination","text":"Python<pre><code>class OffsetPagination(AsyncPaginationBase):\n    page_size = 10\n    max_page_size = 100\n\n    async def apaginate_queryset(self, queryset, pagination, request=None, **params):\n        offset = params.get('offset', 0)\n        limit = min(params.get('limit', self.page_size), self.max_page_size)\n\n        # Get total count\n        total_count = await queryset.acount()\n\n        # Slice queryset\n        items = []\n        async for item in queryset[offset:offset + limit]:\n            items.append(item)\n\n        return {\n            \"count\": total_count,\n            \"offset\": offset,\n            \"limit\": limit,\n            \"results\": items\n        }\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    pagination_class = OffsetPagination\n</code></pre> <p>Usage:</p> Bash<pre><code># First 10 items\nGET /article/?offset=0&amp;limit=10\n\n# Next 10 items\nGET /article/?offset=10&amp;limit=10\n\n# Skip 20, get 15\nGET /article/?offset=20&amp;limit=15\n</code></pre> <p>Response:</p> JSON<pre><code>{\n  \"count\": 100,\n  \"offset\": 20,\n  \"limit\": 15,\n  \"results\": [...]\n}\n</code></pre>"},{"location":"api/pagination/#link-header-pagination","title":"Link Header Pagination","text":"Python<pre><code>from django.http import HttpResponse\n\n\nclass LinkHeaderPagination(AsyncPaginationBase):\n    page_size = 10\n    max_page_size = 100\n\n    async def apaginate_queryset(self, queryset, pagination, request=None, **params):\n        page = params.get('page', 1)\n        page_size = min(params.get('page_size', self.page_size), self.max_page_size)\n\n        total_count = await queryset.acount()\n        total_pages = (total_count + page_size - 1) // page_size\n\n        start = (page - 1) * page_size\n        end = start + page_size\n\n        items = []\n        async for item in queryset[start:end]:\n            items.append(item)\n\n        # Build Link header\n        base_url = request.build_absolute_uri(request.path)\n        links = []\n\n        if page &gt; 1:\n            links.append(f'&lt;{base_url}?page={page-1}&amp;page_size={page_size}&gt;; rel=\"prev\"')\n        if page &lt; total_pages:\n            links.append(f'&lt;{base_url}?page={page+1}&amp;page_size={page_size}&gt;; rel=\"next\"')\n\n        links.append(f'&lt;{base_url}?page=1&amp;page_size={page_size}&gt;; rel=\"first\"')\n        links.append(f'&lt;{base_url}?page={total_pages}&amp;page_size={page_size}&gt;; rel=\"last\"')\n\n        return {\n            \"results\": items,\n            \"_links\": \", \".join(links)\n        }\n</code></pre> <p>Response Headers:</p> Text Only<pre><code>Link: &lt;http://api.example.com/article/?page=1&amp;page_size=10&gt;; rel=\"first\",\n      &lt;http://api.example.com/article/?page=2&amp;page_size=10&gt;; rel=\"prev\",\n      &lt;http://api.example.com/article/?page=4&amp;page_size=10&gt;; rel=\"next\",\n      &lt;http://api.example.com/article/?page=10&amp;page_size=10&gt;; rel=\"last\"\n</code></pre>"},{"location":"api/pagination/#disable-pagination","title":"Disable Pagination","text":""},{"location":"api/pagination/#for-specific-viewset","title":"For Specific ViewSet","text":"Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    pagination_class = None  # Disable pagination\n</code></pre> <p>Now the list endpoint returns all items without pagination:</p> Bash<pre><code>GET /article/\n</code></pre> JSON<pre><code>[\n  {\"id\": 1, \"title\": \"Article 1\"},\n  {\"id\": 2, \"title\": \"Article 2\"},\n  ...\n]\n</code></pre>"},{"location":"api/pagination/#conditional-pagination","title":"Conditional Pagination","text":"Python<pre><code>class ConditionalPagination(PageNumberPagination):\n    async def apaginate_queryset(self, queryset, pagination, request=None, **params):\n        # Disable pagination if 'all' parameter is present\n        if params.get('all'):\n            items = []\n            async for item in queryset:\n                items.append(item)\n            return {\"results\": items}\n\n        # Otherwise use default pagination\n        return await super().apaginate_queryset(queryset, pagination, request, **params)\n</code></pre> <p>Usage:</p> Bash<pre><code># Paginated\nGET /article/?page=1&amp;page_size=10\n\n# All items\nGET /article/?all=true\n</code></pre>"},{"location":"api/pagination/#integration-with-filtering","title":"Integration with Filtering","text":"<p>Pagination works seamlessly with query parameter filtering:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    query_params = {\n        \"is_published\": (bool, None),\n        \"category\": (int, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        if filters.get(\"is_published\") is not None:\n            queryset = queryset.filter(is_published=filters[\"is_published\"])\n        if filters.get(\"category\"):\n            queryset = queryset.filter(category_id=filters[\"category\"])\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># Filter + pagination\nGET /article/?is_published=true&amp;category=5&amp;page=2&amp;page_size=20\n</code></pre> <p>The filtering is applied first, then pagination is applied to the filtered queryset.</p>"},{"location":"api/pagination/#performance-optimization","title":"Performance Optimization","text":""},{"location":"api/pagination/#count-optimization","title":"Count Optimization","text":"<p>For large datasets, counting can be expensive. Cache the count:</p> Python<pre><code>from django.core.cache import cache\n\n\nclass OptimizedPagination(PageNumberPagination):\n    async def apaginate_queryset(self, queryset, pagination, request=None, **params):\n        page = params.get('page', 1)\n        page_size = min(params.get('page_size', self.page_size), self.max_page_size)\n\n        # Try to get cached count\n        cache_key = f\"count_{queryset.model.__name__}\"\n        total_count = cache.get(cache_key)\n\n        if total_count is None:\n            total_count = await queryset.acount()\n            cache.set(cache_key, total_count, 300)  # Cache for 5 minutes\n\n        # Rest of pagination logic\n        start = (page - 1) * page_size\n        end = start + page_size\n\n        items = []\n        async for item in queryset[start:end]:\n            items.append(item)\n\n        return {\n            \"count\": total_count,\n            \"page\": page,\n            \"page_size\": page_size,\n            \"results\": items\n        }\n</code></pre>"},{"location":"api/pagination/#select-related-prefetch-related","title":"Select Related / Prefetch Related","text":"<p>Optimize queries when paginating related data:</p> Python<pre><code>class Article(ModelSerializer):\n    author = models.ForeignKey(User, on_delete=models.CASCADE)\n    category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True)\n    tags = models.ManyToManyField(Tag, related_name=\"articles\")\n\n    @classmethod\n    async def queryset_request(cls, request):\n        # Optimize queries before pagination\n        return cls.objects.select_related(\n            'author',\n            'category'\n        ).prefetch_related(\n            'tags'\n        )\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n</code></pre> <p>Now pagination queries are optimized:</p> SQL<pre><code>-- Single query with joins instead of N+1\nSELECT article.*, user.*, category.*\nFROM article\nLEFT JOIN user ON article.author_id = user.id\nLEFT JOIN category ON article.category_id = category.id\nLIMIT 10 OFFSET 0;\n</code></pre>"},{"location":"api/pagination/#approximate-counts","title":"Approximate Counts","text":"<p>For very large tables, use approximate counts:</p> Python<pre><code>class ApproximatePagination(PageNumberPagination):\n    async def apaginate_queryset(self, queryset, pagination, request=None, **params):\n        from django.db import connection\n\n        # Get approximate count from PostgreSQL statistics\n        with connection.cursor() as cursor:\n            cursor.execute(\n                \"SELECT reltuples::bigint FROM pg_class WHERE relname = %s\",\n                [queryset.model._meta.db_table]\n            )\n            approximate_count = cursor.fetchone()[0]\n\n        # Rest of pagination logic using approximate_count\n        # ...\n</code></pre>"},{"location":"api/pagination/#error-handling","title":"Error Handling","text":""},{"location":"api/pagination/#invalid-page-number","title":"Invalid Page Number","text":"Python<pre><code># Request\nGET /article/?page=999&amp;page_size=10\n\n# Response (404)\n{\n  \"detail\": \"Invalid page.\"\n}\n</code></pre>"},{"location":"api/pagination/#invalid-page-size","title":"Invalid Page Size","text":"Python<pre><code># Request\nGET /article/?page=1&amp;page_size=1000\n\n# Automatically clamped to max_page_size (100)\n# Response\n{\n  \"count\": 45,\n  \"page\": 1,\n  \"page_size\": 100,\n  \"results\": [...]\n}\n</code></pre>"},{"location":"api/pagination/#custom-error-handling","title":"Custom Error Handling","text":"Python<pre><code>class StrictPagination(PageNumberPagination):\n    async def apaginate_queryset(self, queryset, pagination, request=None, **params):\n        page_size = params.get('page_size', self.page_size)\n\n        if page_size &gt; self.max_page_size:\n            raise ValueError(\n                f\"page_size cannot exceed {self.max_page_size}\"\n            )\n\n        # Continue with pagination\n        # ...\n</code></pre>"},{"location":"api/pagination/#testing-pagination","title":"Testing Pagination","text":"Python<pre><code>import pytest\nfrom ninja.testing import TestAsyncClient\nfrom myapp.views import api\n\n\n@pytest.mark.asyncio\nasync def test_pagination():\n    client = TestAsyncClient(api)\n\n    # Create test data\n    for i in range(25):\n        await Article.objects.acreate(title=f\"Article {i}\")\n\n    # Test first page\n    response = await client.get(\"/article/?page=1&amp;page_size=10\")\n    assert response.status_code == 200\n    data = response.json()\n    assert data[\"count\"] == 25\n    assert len(data[\"results\"]) == 10\n    assert data[\"next\"] == 2\n    assert data[\"previous\"] is None\n\n    # Test middle page\n    response = await client.get(\"/article/?page=2&amp;page_size=10\")\n    data = response.json()\n    assert len(data[\"results\"]) == 10\n    assert data[\"next\"] == 3\n    assert data[\"previous\"] == 1\n\n    # Test last page\n    response = await client.get(\"/article/?page=3&amp;page_size=10\")\n    data = response.json()\n    assert len(data[\"results\"]) == 5\n    assert data[\"next\"] is None\n    assert data[\"previous\"] == 2\n\n\n@pytest.mark.asyncio\nasync def test_invalid_page():\n    client = TestAsyncClient(api)\n\n    response = await client.get(\"/article/?page=999\")\n    assert response.status_code == 404\n\n\n@pytest.mark.asyncio\nasync def test_page_size_limit():\n    client = TestAsyncClient(api)\n\n    # Request exceeds max_page_size\n    response = await client.get(\"/article/?page=1&amp;page_size=1000\")\n    data = response.json()\n    assert len(data[\"results\"]) &lt;= 100  # Clamped to max_page_size\n</code></pre>"},{"location":"api/pagination/#best-practices","title":"Best Practices","text":"<ol> <li>Choose appropriate page size:</li> </ol> Python<pre><code># Mobile API\npage_size = 10\n\n# Desktop/Web API\npage_size = 25\n\n# Admin/Internal API\npage_size = 100\n</code></pre> <ol> <li>Set reasonable max_page_size:</li> </ol> Python<pre><code># Prevent excessive data transfer\nmax_page_size = 100\n</code></pre> <ol> <li>Cache expensive counts:</li> </ol> Python<pre><code># For large, slowly-changing datasets\ncache.set(f\"count_{model}\", count, timeout=300)\n</code></pre> <ol> <li>Optimize queries:</li> </ol> Python<pre><code>queryset = queryset.select_related(...).prefetch_related(...)\n</code></pre> <ol> <li>Use cursor pagination for infinite scroll:</li> </ol> Python<pre><code># Better for real-time feeds\nclass FeedPagination(CursorPagination):\n    page_size = 20\n</code></pre> <ol> <li>Consider approximate counts for huge tables: Python<pre><code># Faster than exact count for millions of rows\nuse_approximate = queryset.count() &gt; 1_000_000\n</code></pre></li> </ol>"},{"location":"api/pagination/#see-also","title":"See Also","text":"<ul> <li> <p> APIViewSet</p> <p> Using pagination with ViewSets</p> </li> <li> <p> ModelUtil</p> <p> Query optimization</p> </li> <li> <p> Authentication</p> <p> Securing paginated endpoints</p> </li> </ul>"},{"location":"api/models/model_serializer/","title":"Model Serializer","text":"<p><code>ModelSerializer</code> is a powerful abstract mixin for Django models that centralizes schema generation and serialization configuration directly on the model class.</p>"},{"location":"api/models/model_serializer/#overview","title":"Overview","text":"<p>Goals:</p> <ul> <li> Eliminate duplication between Model and separate serializer classes</li> <li> Provide clear extension points (sync + async hooks, custom synthetic fields)</li> <li> Auto-generate Ninja schemas from model metadata</li> <li> Support nested serialization for relationships</li> </ul> <p>Key Features:</p> <ul> <li> Declarative schema configuration via inner classes</li> <li> Automatic CRUD schema generation</li> <li> Nested relationship handling</li> <li> Sync and async lifecycle hooks</li> <li> Custom field support (computed/synthetic fields)</li> </ul>"},{"location":"api/models/model_serializer/#quick-start","title":"Quick Start","text":"Python<pre><code>from django.db import models\nfrom ninja_aio.models import ModelSerializer\n\nclass User(ModelSerializer):\n    username = models.CharField(max_length=150, unique=True)\n    email = models.EmailField(unique=True)\n\n    class CreateSerializer:\n        fields = [\"username\", \"email\"]\n\n    class ReadSerializer:\n        fields = [\"id\", \"username\", \"email\"]\n\n    def __str__(self):\n        return self.username\n</code></pre>"},{"location":"api/models/model_serializer/#inner-configuration-classes","title":"Inner Configuration Classes","text":""},{"location":"api/models/model_serializer/#createserializer","title":"CreateSerializer","text":"<p>Describes how to build a create (input) schema for a model.</p> <p>Attributes:</p> Attribute Type Description <code>fields</code> <code>list[str \\| tuple]</code> REQUIRED model field names for creation. Can also include inline custom tuples (see below) <code>optionals</code> <code>list[tuple[str, type]]</code> Optional model fields: <code>(field_name, python_type)</code> <code>customs</code> <code>list[tuple]</code> Synthetic inputs. Tuple forms: <code>(name, type)</code> = required (no default); <code>(name, type, default)</code> = optional (literal or callable) <code>excludes</code> <code>list[str]</code> Field names rejected on create <p>Example:</p> Python<pre><code>class User(ModelSerializer):\n    username = models.CharField(max_length=150)\n    email = models.EmailField()\n    password = models.CharField(max_length=128)\n    bio = models.TextField(blank=True)\n\n    class CreateSerializer:\n        fields = [\"username\", \"email\", \"password\"]\n        optionals = [\n            (\"bio\", str),\n        ]\n        customs = [\n            (\"password_confirm\", str),          # required (no default) equivalent of (\"password_confirm\", str, ...)\n            (\"send_welcome_email\", bool, True), # optional with default\n        ]\n        excludes = [\"id\", \"created_at\"]\n</code></pre> <p>Inline Custom Fields:</p> <p>You can also define custom fields directly in the <code>fields</code> list as tuples:</p> Python<pre><code>class User(ModelSerializer):\n    class CreateSerializer:\n        fields = [\n            \"username\",\n            \"email\",\n            (\"password_confirm\", str),          # 2-tuple: required\n            (\"send_welcome\", bool, True),       # 3-tuple: optional with default\n        ]\n</code></pre> <p>This is equivalent to using the separate <code>customs</code> list but keeps field definitions together.</p> <p>Resolution Order for <code>customs</code>:</p> <ol> <li>Payload value (if provided)</li> <li>If default present and callable \u2192 invoked</li> <li>Literal default (if provided)</li> <li>If tuple was only (name, type) and no value supplied \u2192 validation error (required)</li> </ol> <p>Conceptual Equivalent (django-ninja):</p> Python<pre><code># Without ModelSerializer\nfrom ninja import ModelSchema\n\nclass UserIn(ModelSchema):\n    class Meta:\n        model = User\n        fields = [\"username\", \"email\"]\n</code></pre>"},{"location":"api/models/model_serializer/#readserializer","title":"ReadSerializer","text":"<p>Describes how to build a read (output) schema for a model.</p> <p>Attributes</p> Attribute Type Description <code>fields</code> <code>list[str \\| tuple]</code> REQUIRED. Model fields / related names explicitly included in the read (output) schema. Can also include inline custom tuples. <code>excludes</code> <code>list[str]</code> Fields / related names to always omit (takes precedence over <code>fields</code> and <code>optionals</code>). Use for sensitive or noisy data (e.g., passwords, internal flags). <code>customs</code> <code>list[tuple]</code> Computed / synthetic output values. Tuple formats:\u2022 <code>(name, type)</code> = required resolvable attribute (object attribute or property). Serialization error if not resolvable.\u2022 <code>(name, type, default)</code> = optional; default may be a callable (<code>lambda obj: ...</code>) or a literal value. <code>relations_as_id</code> <code>list[str]</code> Relation fields to serialize as IDs instead of nested objects. Works with forward FK, forward O2O, reverse FK, reverse O2O, and M2M relations. <p>Example:</p> Python<pre><code>class User(ModelSerializer):\n    first_name = models.CharField(max_length=150)\n    last_name = models.CharField(max_length=150)\n    email = models.EmailField()\n    password = models.CharField(max_length=128)\n\n    class ReadSerializer:\n        fields = [\"id\", \"first_name\", \"last_name\", \"email\", \"created_at\"]\n        excludes = [\"password\"]\n        customs = [\n            (\"full_name\", str, lambda obj: f\"{obj.first_name} {obj.last_name}\".strip()),\n            (\"is_premium\", bool, lambda obj: obj.subscription.is_active if hasattr(obj, 'subscription') else False),\n        ]\n</code></pre> <p>Resolution Order for <code>customs</code>:</p> <ol> <li>Attribute / property on instance</li> <li>Callable default (if provided)</li> <li>Literal default</li> <li>If required (2\u2011tuple) and still unresolved \u2192 error</li> </ol> <p>Generated Output:</p> JSON<pre><code>{\n  \"id\": 1,\n  \"first_name\": \"John\",\n  \"last_name\": \"Doe\",\n  \"email\": \"john@example.com\",\n  \"created_at\": \"2024-01-15T10:30:00Z\",\n  \"full_name\": \"John Doe\",\n  \"is_premium\": true\n}\n</code></pre>"},{"location":"api/models/model_serializer/#detailserializer","title":"DetailSerializer","text":"<p>Describes how to build a detail (single object) output schema. Use this when you want the retrieve endpoint to return more fields than the list endpoint.</p> <p>Fallback Behavior: <code>DetailSerializer</code> supports per-field-type fallback to <code>ReadSerializer</code>. Each attribute (<code>fields</code>, <code>customs</code>, <code>optionals</code>, <code>excludes</code>) is checked independently:</p> <ul> <li>If <code>DetailSerializer.fields</code> is empty \u2192 uses <code>ReadSerializer.fields</code></li> <li>If <code>DetailSerializer.customs</code> is empty \u2192 uses <code>ReadSerializer.customs</code></li> <li>If <code>DetailSerializer.optionals</code> is empty \u2192 uses <code>ReadSerializer.optionals</code></li> <li>If <code>DetailSerializer.excludes</code> is empty \u2192 uses <code>ReadSerializer.excludes</code></li> </ul> <p>This allows partial overrides: define only <code>DetailSerializer.fields</code> while inheriting <code>customs</code> from <code>ReadSerializer</code>.</p> <p>Attributes:</p> Attribute Type Description <code>fields</code> <code>list[str \\| tuple]</code> Model fields to include in detail view. Can include inline custom tuples. Falls back to ReadSerializer.fields if empty <code>excludes</code> <code>list[str]</code> Fields to exclude from detail view (falls back to ReadSerializer.excludes if empty) <code>customs</code> <code>list[tuple]</code> Computed fields: <code>(name, type)</code> required; <code>(name, type, default)</code> optional (falls back to ReadSerializer.customs if empty) <code>optionals</code> <code>list[tuple[str, type]]</code> Optional output fields (falls back to ReadSerializer.optionals if empty) <p>Example:</p> Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    summary = models.TextField()\n    content = models.TextField()\n    author = models.ForeignKey(User, on_delete=models.CASCADE)\n    tags = models.ManyToManyField(Tag)\n    view_count = models.IntegerField(default=0)\n\n    class ReadSerializer:\n        # List view: minimal fields for performance\n        fields = [\"id\", \"title\", \"summary\", \"author\"]\n        customs = [\n            (\"word_count\", int, lambda obj: len(obj.content.split())),\n        ]\n\n    class DetailSerializer:\n        # Detail view: all fields including expensive relations\n        # customs inherited from ReadSerializer (word_count)\n        fields = [\"id\", \"title\", \"summary\", \"content\", \"author\", \"tags\", \"view_count\"]\n</code></pre> <p>Generated Output (List):</p> JSON<pre><code>[\n  {\"id\": 1, \"title\": \"Getting Started\", \"summary\": \"...\", \"author\": {...}, \"word_count\": 500},\n  {\"id\": 2, \"title\": \"Advanced Topics\", \"summary\": \"...\", \"author\": {...}, \"word_count\": 1200}\n]\n</code></pre> <p>Generated Output (Detail):</p> JSON<pre><code>{\n  \"id\": 1,\n  \"title\": \"Getting Started\",\n  \"summary\": \"...\",\n  \"content\": \"Full article content here...\",\n  \"author\": {...},\n  \"tags\": [{\"id\": 1, \"name\": \"python\"}, {\"id\": 2, \"name\": \"django\"}],\n  \"view_count\": 1234,\n  \"word_count\": 500\n}\n</code></pre> <p>Example with Custom Override:</p> Python<pre><code>class Article(ModelSerializer):\n    # ... fields ...\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"summary\"]\n        customs = [(\"word_count\", int, lambda obj: len(obj.content.split()))]\n\n    class DetailSerializer:\n        fields = [\"id\", \"title\", \"summary\", \"content\"]\n        # Override customs - reading_time instead of word_count\n        customs = [(\"reading_time\", int, lambda obj: len(obj.content.split()) // 200)]\n</code></pre>"},{"location":"api/models/model_serializer/#updateserializer","title":"UpdateSerializer","text":"<p>Describes how to build an update (partial/full) input schema.</p> <p>Attributes:</p> Attribute Type Description <code>fields</code> <code>list[str \\| tuple]</code> REQUIRED fields for update (rarely used). Can include inline custom tuples <code>optionals</code> <code>list[tuple[str, type]]</code> Updatable optional fields (typical for PATCH) <code>customs</code> <code>list[tuple]</code> Instruction fields: <code>(name, type)</code> required; <code>(name, type, default)</code> optional <code>excludes</code> <code>list[str]</code> Immutable fields that cannot be updated <p>Example:</p> Python<pre><code>class User(ModelSerializer):\n    username = models.CharField(max_length=150, unique=True)\n    email = models.EmailField()\n    bio = models.TextField(blank=True)\n    is_active = models.BooleanField(default=True)\n\n    class UpdateSerializer:\n        optionals = [\n            (\"email\", str),\n            (\"bio\", str),\n            (\"is_active\", bool),\n        ]\n        customs = [\n            (\"reset_password\", bool, False),  # optional flag\n            (\"rotate_token\", bool),          # required instruction\n        ]\n        excludes = [\"username\", \"created_at\", \"id\"]\n</code></pre> <p>Usage (PATCH request):</p> JSON<pre><code>{\n  \"email\": \"newemail@example.com\",\n  \"bio\": \"Updated bio\",\n  \"reset_password\": true\n}\n</code></pre>"},{"location":"api/models/model_serializer/#schema-generation","title":"Schema Generation","text":""},{"location":"api/models/model_serializer/#auto-generated-schemas","title":"Auto-Generated Schemas","text":"<p>ModelSerializer automatically generates five schema types:</p> Method Schema Type Purpose <code>generate_create_s()</code> Input (\"In\") POST endpoint payload <code>generate_update_s()</code> Input (\"Patch\") PATCH/PUT endpoint payload <code>generate_read_s(depth=1)</code> Output (\"Out\") List response with nested relations <code>generate_detail_s(depth=1)</code> Output (\"Detail\") Single object response (retrieve) <code>generate_related_s()</code> Output (\"Related\") Compact nested representation <p>Example:</p> Python<pre><code>class User(ModelSerializer):\n    username = models.CharField(max_length=150)\n    email = models.EmailField()\n\n    class CreateSerializer:\n        fields = [\"username\", \"email\"]\n\n    class ReadSerializer:\n        fields = [\"id\", \"username\", \"email\"]\n\n# Auto-generate schemas\nUserCreateSchema = User.generate_create_s()\nUserReadSchema = User.generate_read_s()\nUserDetailSchema = User.generate_detail_s()  # Falls back to read schema if DetailSerializer not defined\nUserUpdateSchema = User.generate_update_s()\nUserRelatedSchema = User.generate_related_s()\n</code></pre>"},{"location":"api/models/model_serializer/#nested-relationship-handling","title":"Nested Relationship Handling","text":"<p>ModelSerializer automatically serializes relationships if the related model is also a ModelSerializer.</p>"},{"location":"api/models/model_serializer/#foreignkey-forward","title":"ForeignKey (Forward)","text":"Python<pre><code>class Profile(ModelSerializer):\n    bio = models.TextField()\n\n    class ReadSerializer:\n        fields = [\"id\", \"bio\"]\n\nclass User(ModelSerializer):\n    username = models.CharField(max_length=150)\n    profile = models.ForeignKey(Profile, on_delete=models.CASCADE)\n\n    class ReadSerializer:\n        fields = [\"id\", \"username\", \"profile\"]\n</code></pre> <p>Output:</p> JSON<pre><code>{\n  \"id\": 1,\n  \"username\": \"john_doe\",\n  \"profile\": {\n    \"id\": 10,\n    \"bio\": \"Software developer\"\n  }\n}\n</code></pre>"},{"location":"api/models/model_serializer/#manytomany","title":"ManyToMany","text":"Python<pre><code>class Tag(ModelSerializer):\n    name = models.CharField(max_length=50)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\"]\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    tags = models.ManyToManyField(Tag, related_name=\"articles\")\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"tags\"]\n</code></pre> <p>Output:</p> JSON<pre><code>{\n  \"id\": 1,\n  \"title\": \"Getting Started\",\n  \"tags\": [\n    { \"id\": 1, \"name\": \"python\" },\n    { \"id\": 2, \"name\": \"django\" }\n  ]\n}\n</code></pre>"},{"location":"api/models/model_serializer/#reverse-relationships","title":"Reverse Relationships","text":"Python<pre><code>class Author(ModelSerializer):\n    name = models.CharField(max_length=200)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"books\"]  # Reverse FK\n\nclass Book(ModelSerializer):\n    title = models.CharField(max_length=200)\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"books\")\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\"]\n</code></pre> <p>Output:</p> JSON<pre><code>{\n  \"id\": 1,\n  \"name\": \"J.K. Rowling\",\n  \"books\": [\n    { \"id\": 1, \"title\": \"Harry Potter\" },\n    { \"id\": 2, \"title\": \"Fantastic Beasts\" }\n  ]\n}\n</code></pre>"},{"location":"api/models/model_serializer/#relations-as-id","title":"Relations as ID","text":"<p>Use <code>relations_as_id</code> to serialize relation fields as IDs instead of nested objects. This is useful for:</p> <ul> <li>Reducing response payload size</li> <li>Avoiding circular serialization</li> <li>Performance optimization when nested data isn't needed</li> <li>API designs where clients fetch related data separately</li> </ul> <p>Supported Relations:</p> Relation Type Output Type Example Value Forward FK <code>PK_TYPE \\| None</code> <code>5</code> or <code>null</code> Forward O2O <code>PK_TYPE \\| None</code> <code>3</code> or <code>null</code> Reverse FK <code>list[PK_TYPE]</code> <code>[1, 2, 3]</code> Reverse O2O <code>PK_TYPE \\| None</code> <code>7</code> or <code>null</code> M2M (forward) <code>list[PK_TYPE]</code> <code>[1, 2]</code> M2M (reverse) <code>list[PK_TYPE]</code> <code>[4, 5, 6]</code> <p>Note: <code>PK_TYPE</code> is automatically detected from the related model's primary key field. Supported types include <code>int</code> (default), <code>UUID</code>, <code>str</code>, and any other Django primary key type.</p> <p>Example:</p> Python<pre><code>class Author(ModelSerializer):\n    name = models.CharField(max_length=200)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"books\"]\n        relations_as_id = [\"books\"]  # Serialize as list of IDs\n\nclass Book(ModelSerializer):\n    title = models.CharField(max_length=200)\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"books\")\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"author\"]\n        relations_as_id = [\"author\"]  # Serialize as ID\n</code></pre> <p>Output (Author):</p> JSON<pre><code>{\n  \"id\": 1,\n  \"name\": \"J.K. Rowling\",\n  \"books\": [1, 2, 3]\n}\n</code></pre> <p>Output (Book):</p> JSON<pre><code>{\n  \"id\": 1,\n  \"title\": \"Harry Potter\",\n  \"author\": 1\n}\n</code></pre> <p>M2M Example:</p> Python<pre><code>class Tag(ModelSerializer):\n    name = models.CharField(max_length=50)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"articles\"]\n        relations_as_id = [\"articles\"]  # Reverse M2M as IDs\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    tags = models.ManyToManyField(Tag, related_name=\"articles\")\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"tags\"]\n        relations_as_id = [\"tags\"]  # Forward M2M as IDs\n</code></pre> <p>Output (Article):</p> JSON<pre><code>{\n  \"id\": 1,\n  \"title\": \"Getting Started with Django\",\n  \"tags\": [1, 2, 5]\n}\n</code></pre> <p>UUID Primary Key Example:</p> <p>When models use UUID primary keys, the output type is automatically <code>UUID</code>:</p> Python<pre><code>import uuid\nfrom django.db import models\nfrom ninja_aio.models import ModelSerializer\n\nclass Author(ModelSerializer):\n    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\n    name = models.CharField(max_length=200)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"books\"]\n        relations_as_id = [\"books\"]\n\nclass Book(ModelSerializer):\n    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\n    title = models.CharField(max_length=200)\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"books\")\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"author\"]\n        relations_as_id = [\"author\"]\n</code></pre> <p>Output (Author with UUID):</p> JSON<pre><code>{\n  \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"name\": \"J.K. Rowling\",\n  \"books\": [\n    \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\",\n    \"6ba7b811-9dad-11d1-80b4-00c04fd430c8\"\n  ]\n}\n</code></pre> <p>Output (Book with UUID):</p> JSON<pre><code>{\n  \"id\": \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\",\n  \"title\": \"Harry Potter\",\n  \"author\": \"550e8400-e29b-41d4-a716-446655440000\"\n}\n</code></pre> <p>Query Optimization Note: When using <code>relations_as_id</code>, you should still use <code>select_related()</code> for forward relations and <code>prefetch_related()</code> for reverse/M2M relations to avoid N+1 queries:</p> Python<pre><code>class Article(ModelSerializer):\n    # ...\n\n    class QuerySet:\n        read = ModelQuerySetSchema(\n            select_related=[\"author\"],       # For forward FK\n            prefetch_related=[\"tags\"],        # For M2M\n        )\n</code></pre>"},{"location":"api/models/model_serializer/#async-extension-points","title":"Async Extension Points","text":""},{"location":"api/models/model_serializer/#queryset_requestrequest","title":"<code>queryset_request(request)</code>","text":"<p>Filter queryset based on request context (user, permissions, tenant, etc.).</p> Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    author = models.ForeignKey(User, on_delete=models.CASCADE)\n    is_published = models.BooleanField(default=False)\n\n    @classmethod\n    async def queryset_request(cls, request):\n        qs = cls.objects.select_related('author').all()\n\n        # Non-authenticated users see only published\n        if not request.auth:\n            return qs.filter(is_published=True)\n\n        # Authors see their own + published\n        return qs.filter(\n            models.Q(author=request.auth) | models.Q(is_published=True)\n        )\n</code></pre>"},{"location":"api/models/model_serializer/#post_create","title":"<code>post_create()</code>","text":"<p>Execute async logic after object creation.</p> Python<pre><code>class User(ModelSerializer):\n    email = models.EmailField()\n\n    async def post_create(self):\n        # Send welcome email\n        from myapp.tasks import send_welcome_email\n        await send_welcome_email(self.email)\n\n        # Create related objects\n        await Profile.objects.acreate(user=self)\n\n        # Log creation\n        await AuditLog.objects.acreate(\n            action=\"user_created\",\n            user_id=self.id\n        )\n</code></pre>"},{"location":"api/models/model_serializer/#custom_actionspayload","title":"<code>custom_actions(payload)</code>","text":"<p>React to synthetic/custom fields from the payload.</p> Python<pre><code>class User(ModelSerializer):\n    password = models.CharField(max_length=128)\n\n    class CreateSerializer:\n        fields = [\"username\", \"email\", \"password\"]\n        customs = [\n            (\"password_confirm\", str, None),\n            (\"send_welcome_email\", bool, True),\n        ]\n\n    async def custom_actions(self, payload: dict):\n        # Validate password confirmation\n        if \"password_confirm\" in payload:\n            if payload[\"password_confirm\"] != self.password:\n                raise ValueError(\"Passwords do not match\")\n\n        # Send welcome email if requested\n        if payload.get(\"send_welcome_email\", True):\n            await send_email(self.email, \"Welcome!\")\n</code></pre>"},{"location":"api/models/model_serializer/#sync-lifecycle-hooks","title":"Sync Lifecycle Hooks","text":""},{"location":"api/models/model_serializer/#save-hooks","title":"Save Hooks","text":"Python<pre><code>class User(ModelSerializer):\n    username = models.CharField(max_length=150)\n    slug = models.SlugField(unique=True, blank=True)\n\n    def before_save(self):\n        \"\"\"Executed before every save (create + update)\"\"\"\n        if not self.slug:\n            self.slug = slugify(self.username)\n\n    def on_create_before_save(self):\n        \"\"\"Executed only on creation, before save\"\"\"\n        self.set_password(self.password)  # Hash password\n\n    def after_save(self):\n        \"\"\"Executed after every save\"\"\"\n        cache.delete(f\"user:{self.id}\")\n\n    def on_create_after_save(self):\n        \"\"\"Executed only after creation\"\"\"\n        send_welcome_email_sync(self.email)\n</code></pre> <p>Execution Order:</p> Text Only<pre><code>CREATE:\n1. on_create_before_save()\n2. before_save()\n3. super().save()\n4. on_create_after_save()\n5. after_save()\n\nUPDATE:\n1. before_save()\n2. super().save()\n3. after_save()\n</code></pre>"},{"location":"api/models/model_serializer/#delete-hook","title":"Delete Hook","text":"Python<pre><code>class User(ModelSerializer):\n\n    def on_delete(self):\n        \"\"\"Executed after object deletion\"\"\"\n        # Clean up related data\n        logger.info(f\"User {self.username} deleted\")\n\n        # Remove from cache\n        cache.delete(f\"user:{self.id}\")\n\n        # Archive data\n        ArchivedUser.objects.create(\n            username=self.username,\n            deleted_at=timezone.now()\n        )\n</code></pre>"},{"location":"api/models/model_serializer/#utility-methods","title":"Utility Methods","text":""},{"location":"api/models/model_serializer/#has_changedfield","title":"<code>has_changed(field)</code>","text":"<p>Check if a field value has changed compared to database.</p> Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    status = models.CharField(max_length=20)\n\n    def before_save(self):\n        if self.has_changed('status'):\n            if self.status == 'published':\n                self.published_at = timezone.now()\n                notify_subscribers(self)\n</code></pre>"},{"location":"api/models/model_serializer/#verbose_name_path_resolver","title":"<code>verbose_name_path_resolver()</code>","text":"<p>Get slugified plural verbose name for URL routing.</p> Python<pre><code>class BlogPost(ModelSerializer):\n    class Meta:\n        verbose_name_plural = \"blog posts\"\n\n# Returns: \"blog-posts\"\npath = BlogPost.verbose_name_path_resolver()\n</code></pre>"},{"location":"api/models/model_serializer/#modelutil","title":"ModelUtil","text":"<p>Helper class for async CRUD operations with ModelSerializer.</p>"},{"location":"api/models/model_serializer/#overview_1","title":"Overview","text":"Python<pre><code>from ninja_aio.models import ModelUtil\n\nutil = ModelUtil(User)\n</code></pre> <p>Key Responsibilities:</p> <ul> <li>Introspect model metadata</li> <li>Normalize inbound/outbound payloads</li> <li>Handle FK resolution and base64 decoding</li> <li>Prefetch reverse relations</li> <li>Invoke serializer hooks</li> </ul>"},{"location":"api/models/model_serializer/#key-methods","title":"Key Methods","text":""},{"location":"api/models/model_serializer/#get_objectrequest-pknone-filtersnone-gettersnone","title":"<code>get_object(request, pk=None, filters=None, getters=None)</code>","text":"<p>Fetch single object or queryset with optimized queries.</p> Python<pre><code># Get single object\nuser = await util.get_object(request, pk=1)\n\n# Get with filters\nactive_users = await util.get_object(\n    request,\n    filters={\"is_active\": True}\n)\n\n# Get with custom lookup\nuser = await util.get_object(\n    request,\n    getters={\"email\": \"john@example.com\"}\n)\n</code></pre> <p>Features:</p> <ul> <li>Automatic <code>select_related()</code> and <code>prefetch_related()</code></li> <li>Respects <code>queryset_request()</code> filtering</li> <li>Raises <code>SerializeError</code> (404) if not found</li> </ul>"},{"location":"api/models/model_serializer/#parse_input_datarequest-data","title":"<code>parse_input_data(request, data)</code>","text":"<p>Convert incoming schema to model-ready dict.</p> <p>Transformations:</p> <ol> <li>Strips custom fields (stored separately)</li> <li>Removes optional fields with <code>None</code> value</li> <li>Decodes BinaryField (base64 \u2192 bytes)</li> <li>Resolves FK IDs to model instances</li> </ol> Python<pre><code>from ninja import Schema\n\nclass UserCreateSchema(Schema):\n    username: str\n    email: str\n    profile_id: int\n    avatar: str  # base64 for BinaryField\n    send_welcome: bool  # custom field\n\ndata = UserCreateSchema(\n    username=\"john\",\n    email=\"john@example.com\",\n    profile_id=5,\n    avatar=\"iVBORw0KG...\",  # base64\n    send_welcome=True\n)\n\npayload, customs = await util.parse_input_data(request, data)\n\n# payload = {\n#     \"username\": \"john\",\n#     \"email\": \"john@example.com\",\n#     \"profile\": &lt;Profile instance&gt;,\n#     \"avatar\": b'\\x89PNG\\r\\n...'\n# }\n# customs = {\"send_welcome\": True}\n</code></pre>"},{"location":"api/models/model_serializer/#parse_output_datarequest-data","title":"<code>parse_output_data(request, data)</code>","text":"<p>Post-process serialized output for consistency.</p> <p>Transformations:</p> <ol> <li>Replaces nested FK dicts with actual instances</li> <li>Rewrites nested FK keys to <code>&lt;field&gt;_id</code> format</li> </ol> Python<pre><code># Before\n{\n    \"id\": 1,\n    \"author\": {\"id\": 10, \"profile\": {\"id\": 5}}\n}\n\n# After parse_output_data\n{\n    \"id\": 1,\n    \"author\": &lt;Author instance&gt;,\n    \"author_id\": 10,\n    \"profile_id\": 5\n}\n</code></pre>"},{"location":"api/models/model_serializer/#crud-operations","title":"CRUD Operations","text":""},{"location":"api/models/model_serializer/#create_srequest-data-obj_schema","title":"<code>create_s(request, data, obj_schema)</code>","text":"Python<pre><code>user_data = UserCreateSchema(username=\"john\", email=\"john@example.com\")\nresult = await util.create_s(request, user_data, UserReadSchema)\n\n# Executes:\n# 1. parse_input_data (normalize)\n# 2. Model.objects.acreate()\n# 3. custom_actions(customs)\n# 4. post_create()\n# 5. read_s (serialize response)\n</code></pre>"},{"location":"api/models/model_serializer/#read_srequest-obj-obj_schema","title":"<code>read_s(request, obj, obj_schema)</code>","text":"Python<pre><code>user = await User.objects.aget(id=1)\nresult = await util.read_s(request, user, UserReadSchema)\n# Returns parsed dict ready for API response\n</code></pre>"},{"location":"api/models/model_serializer/#update_srequest-data-pk-obj_schema","title":"<code>update_s(request, data, pk, obj_schema)</code>","text":"Python<pre><code>update_data = UserUpdateSchema(email=\"newemail@example.com\")\nresult = await util.update_s(request, update_data, 1, UserReadSchema)\n\n# Executes:\n# 1. get_object(pk)\n# 2. parse_input_data\n# 3. Update changed fields\n# 4. custom_actions(customs)\n# 5. obj.asave()\n# 6. read_s (serialize updated object)\n</code></pre>"},{"location":"api/models/model_serializer/#delete_srequest-pk","title":"<code>delete_s(request, pk)</code>","text":"Python<pre><code>await util.delete_s(request, 1)\n# Returns None\n</code></pre>"},{"location":"api/models/model_serializer/#error-handling","title":"Error Handling","text":"Python<pre><code>from ninja_aio.exceptions import SerializeError\n\ntry:\n    user = await util.get_object(request, pk=999)\nexcept SerializeError as e:\n    # e.details = {\"user\": \"not found\"}\n    # e.status_code = 404\n    pass\n\ntry:\n    await util.create_s(request, bad_data, UserReadSchema)\nexcept SerializeError as e:\n    # e.details = {\"avatar\": \"Invalid base64\"}\n    # e.status_code = 400\n    pass\n</code></pre>"},{"location":"api/models/model_serializer/#complete-example","title":"Complete Example","text":"Python<pre><code>from django.db import models\nfrom ninja_aio.models import ModelSerializer\nfrom django.utils.text import slugify\n\nclass Category(ModelSerializer):\n    name = models.CharField(max_length=100)\n    slug = models.SlugField(unique=True, blank=True)\n\n    class CreateSerializer:\n        fields = [\"name\"]\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"slug\"]\n\n    class UpdateSerializer:\n        optionals = [(\"name\", str)]\n\n    def before_save(self):\n        if not self.slug:\n            self.slug = slugify(self.name)\n\nclass Author(ModelSerializer):\n    name = models.CharField(max_length=200)\n    email = models.EmailField(unique=True)\n    bio = models.TextField(blank=True)\n\n    class CreateSerializer:\n        fields = [\"name\", \"email\"]\n        optionals = [(\"bio\", str)]\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"email\", \"bio\"]\n        customs = [\n            (\"post_count\", int, lambda obj: obj.articles.count()),\n        ]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"name\", str),\n            (\"email\", str),\n            (\"bio\", str),\n        ]\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    slug = models.SlugField(unique=True)\n    content = models.TextField()\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"articles\")\n    category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True)\n    tags = models.ManyToManyField('Tag', related_name=\"articles\")\n    is_published = models.BooleanField(default=False)\n    views = models.IntegerField(default=0)\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    class CreateSerializer:\n        fields = [\"title\", \"slug\", \"content\", \"author\", \"category\"]\n        customs = [\n            (\"notify_subscribers\", bool, True),\n        ]\n\n    class ReadSerializer:\n        fields = [\n            \"id\", \"title\", \"slug\", \"content\",\n            \"author\", \"category\", \"tags\",\n            \"is_published\", \"views\", \"created_at\"\n        ]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"title\", str),\n            (\"content\", str),\n            (\"category\", int),\n            (\"is_published\", bool),\n        ]\n        excludes = [\"slug\", \"author\", \"created_at\"]\n\n    @classmethod\n    async def queryset_request(cls, request):\n        qs = cls.objects.select_related('author', 'category').prefetch_related('tags')\n\n        if not request.auth:\n            return qs.filter(is_published=True)\n\n        return qs.filter(\n            models.Q(author=request.auth) | models.Q(is_published=True)\n        )\n\n    async def post_create(self):\n        await AuditLog.objects.acreate(\n            action=\"article_created\",\n            article_id=self.id,\n            author_id=self.author_id\n        )\n\n    async def custom_actions(self, payload: dict):\n        if payload.get(\"notify_subscribers\"):\n            await notify_new_article(self)\n\n    def before_save(self):\n        if self.has_changed('is_published') and self.is_published:\n            self.published_at = timezone.now()\n\nclass Tag(ModelSerializer):\n    name = models.CharField(max_length=50, unique=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\"]\n</code></pre>"},{"location":"api/models/model_serializer/#custom-fields-normalization","title":"Custom Fields Normalization","text":"<p>Custom tuples are normalized by <code>ModelSerializer.get_custom_fields()</code> to <code>(name, python_type, default)</code>.</p> <p>Accepted forms:</p> <ul> <li><code>(name, type)</code> -&gt; stored with <code>default = Ellipsis</code> (treated as required)</li> <li><code>(name, type, default)</code> -&gt; default kept (callable or literal)</li> </ul> <p>Invalid lengths raise <code>ValueError</code>.</p> <p>Example mix:</p> Python<pre><code>class CreateSerializer:\n    customs = [\n        (\"password_confirm\", str),           # required\n        (\"send_welcome\", bool, True),        # optional\n        (\"initial_quota\", int, lambda: 100)  # optional callable\n    ]\n</code></pre> <p>At runtime:</p> Python<pre><code># Normalized\n[\n  (\"password_confirm\", str, Ellipsis),\n  (\"send_welcome\", bool, True),\n  (\"initial_quota\", int, &lt;function ...&gt;)\n]\n</code></pre> <p>Required customs (Ellipsis) must be provided in input (create/update) or resolvable (read) or an error is raised.</p>"},{"location":"api/models/model_serializer/#error-cases","title":"Error Cases","text":"Situation Result 1\u2011item or 4\u2011item tuple ValueError Missing required custom (2\u2011tuple) in payload Validation error Unresolvable required read custom Serialization error"},{"location":"api/models/model_serializer/#best-practices","title":"Best Practices","text":"<ol> <li>Always exclude sensitive fields:</li> </ol> Python<pre><code>class ReadSerializer:\n    excludes = [\"password\", \"secret_key\", \"internal_id\"]\n</code></pre> <ol> <li>Use optionals for PATCH operations:</li> </ol> Python<pre><code>class UpdateSerializer:\n    optionals = [(\"email\", str), (\"bio\", str)]  # Partial updates\n</code></pre> <ol> <li>Leverage customs for computed data:</li> </ol> Python<pre><code>customs = [\n    (\"full_name\", str, lambda obj: f\"{obj.first_name} {obj.last_name}\"),\n]\n</code></pre> <ol> <li>Optimize queries in queryset_request:</li> </ol> Python<pre><code>@classmethod\nasync def queryset_request(cls, request):\n    return cls.objects.select_related('author').prefetch_related('tags')\n</code></pre> <ol> <li>Keep hooks focused: Python<pre><code>async def post_create(self):\n    # Do ONE thing well\n    await send_welcome_email(self.email)\n</code></pre></li> </ol>"},{"location":"api/models/model_serializer/#see-also","title":"See Also","text":"<ul> <li> <p> ModelUtil</p> <p> Deep dive</p> </li> <li> <p> Validators</p> <p> Field &amp; model validators</p> </li> <li> <p> APIViewSet</p> <p> Using with ViewSets</p> </li> <li> <p> Authentication</p> <p> Securing endpoints</p> </li> </ul>"},{"location":"api/models/model_util/","title":"Model Util","text":"<p><code>ModelUtil</code> is an async utility class that provides high-level CRUD operations and serialization management for Django models and ModelSerializer instances.</p>"},{"location":"api/models/model_util/#overview","title":"Overview","text":"<p>ModelUtil acts as a bridge between Django Ninja schemas and Django ORM, handling:</p> <ul> <li> Data normalization \u2014 input/output</li> <li> Relationship resolution \u2014 FK/M2M</li> <li> Binary field handling \u2014 base64 encoding/decoding</li> <li> Query optimization \u2014 select_related/prefetch_related</li> <li> Lifecycle hook invocation \u2014 custom_actions, post_create, queryset_request</li> </ul>"},{"location":"api/models/model_util/#class-definition","title":"Class Definition","text":"Python<pre><code>from ninja_aio.models import ModelUtil\n\nutil = ModelUtil(model, serializer_class=None)\n</code></pre> <p>Parameters:</p> <ul> <li><code>model</code> (<code>type[ModelSerializer] | models.Model</code>): Django model or ModelSerializer subclass</li> <li><code>serializer_class</code> (<code>Serializer | None</code>): Optional Serializer class for plain Django models</li> </ul>"},{"location":"api/models/model_util/#properties","title":"Properties","text":""},{"location":"api/models/model_util/#with_serializer","title":"<code>with_serializer</code>","text":"<p>Indicates if a serializer_class is associated.</p> Python<pre><code>util = ModelUtil(User, serializer_class=UserSerializer)\nprint(util.with_serializer)  # True\n</code></pre>"},{"location":"api/models/model_util/#pk_field_type","title":"<code>pk_field_type</code>","text":"<p>Returns the Python type corresponding to the model's primary key field.</p> Python<pre><code>util = ModelUtil(User)\nprint(util.pk_field_type)  # &lt;class 'int'&gt;\n</code></pre> <p>Uses the Django field's internal type and <code>ninja.orm.fields.TYPES</code> mapping. Raises <code>ConfigError</code> if the internal type is not registered.</p>"},{"location":"api/models/model_util/#model_pk_name","title":"<code>model_pk_name</code>","text":"<p>Returns the primary key field name.</p> Python<pre><code>util = ModelUtil(User)\nprint(util.model_pk_name)  # \"id\"\n</code></pre>"},{"location":"api/models/model_util/#model_fields","title":"<code>model_fields</code>","text":"<p>Returns a list of all model field names.</p> Python<pre><code>util = ModelUtil(User)\nprint(util.model_fields)\n# [\"id\", \"username\", \"email\", \"created_at\", \"is_active\"]\n</code></pre>"},{"location":"api/models/model_util/#serializable_fields","title":"<code>serializable_fields</code>","text":"<p>Returns serializable fields for read operations (ReadSerializer fields or all model fields).</p> Python<pre><code>class User(ModelSerializer):\n    username = models.CharField(max_length=150)\n    password = models.CharField(max_length=128)\n    email = models.EmailField()\n\n    class ReadSerializer:\n        fields = [\"id\", \"username\", \"email\"]\n\nutil = ModelUtil(User)\nprint(util.serializable_fields)\n# [\"id\", \"username\", \"email\"]  (password excluded)\n</code></pre>"},{"location":"api/models/model_util/#serializable_detail_fields","title":"<code>serializable_detail_fields</code>","text":"<p>Returns serializable fields for detail operations (DetailSerializer fields, or falls back to ReadSerializer fields).</p> Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    summary = models.TextField()\n    content = models.TextField()\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"summary\"]\n\n    class DetailSerializer:\n        fields = [\"id\", \"title\", \"summary\", \"content\"]\n\nutil = ModelUtil(Article)\nprint(util.serializable_fields)        # [\"id\", \"title\", \"summary\"]\nprint(util.serializable_detail_fields) # [\"id\", \"title\", \"summary\", \"content\"]\n</code></pre>"},{"location":"api/models/model_util/#model_name","title":"<code>model_name</code>","text":"<p>Returns the Django internal model name.</p> Python<pre><code>util = ModelUtil(User)\nprint(util.model_name)  # \"user\"\n</code></pre>"},{"location":"api/models/model_util/#serializer_meta","title":"<code>serializer_meta</code>","text":"<p>Returns the ModelSerializerMeta instance if model uses ModelSerializer.</p> Python<pre><code>if util.serializer_meta:\n    fields = util.serializer_meta.get_fields(\"create\")\n</code></pre>"},{"location":"api/models/model_util/#queryset-configuration-on-modelserializer","title":"QuerySet Configuration on ModelSerializer","text":"<p>You can declare query optimizations directly on your ModelSerializer via a nested QuerySet:</p> Python<pre><code>from ninja_aio.models import ModelSerializer\nfrom ninja_aio.schemas.helpers import ModelQuerySetSchema, ModelQuerySetExtraSchema\n\nclass Book(ModelSerializer):\n    # ...existing fields...\n\n    class QuerySet:\n        read = ModelQuerySetSchema(\n            select_related=[\"author\", \"category\"],\n            prefetch_related=[\"tags\"],\n        )\n        detail = ModelQuerySetSchema(\n            select_related=[\"author\", \"category\", \"publisher\"],\n            prefetch_related=[\"tags\", \"reviews\"],\n        )\n        queryset_request = ModelQuerySetSchema(\n            select_related=[],\n            prefetch_related=[\"related_items\"],\n        )\n        extras = [\n            ModelQuerySetExtraSchema(\n                scope=\"detail_cards\",\n                select_related=[\"author\"],\n                prefetch_related=[\"tags\"],\n            )\n        ]\n</code></pre> <ul> <li>read: applied to list operations (<code>is_for=\"read\"</code>).</li> <li>detail: applied to retrieve operations (<code>is_for=\"detail\"</code>). Falls back to <code>read</code> if not defined.</li> <li>queryset_request: applied inside queryset_request hook.</li> <li>extras: named configurations available via QueryUtil.SCOPES.</li> </ul>"},{"location":"api/models/model_util/#queryutil","title":"QueryUtil","text":"<p>Each ModelSerializer now exposes a query_util helper:</p> Python<pre><code>util = MyModel.query_util\nqs = util.apply_queryset_optimizations(MyModel.objects.all(), util.SCOPES.READ)\n</code></pre> <ul> <li>SCOPES: includes READ, QUERYSET_REQUEST, plus any extras you've defined.</li> <li>apply_queryset_optimizations: applies select_related/prefetch_related for a scope.</li> </ul>"},{"location":"api/models/model_util/#query-schemas","title":"Query Schemas","text":"<p>New helper schemas standardize filters and getters:</p> Python<pre><code>from ninja_aio.schemas.helpers import (\n    QuerySchema,           # generic: filters or getters\n    ObjectQuerySchema,     # getters + select/prefetch\n    ObjectsQuerySchema,    # filters + select/prefetch\n    ModelQuerySetSchema,   # select/prefetch only\n)\n</code></pre>"},{"location":"api/models/model_util/#core-methods","title":"Core Methods","text":""},{"location":"api/models/model_util/#get_objects","title":"<code>get_objects</code>","text":"<p>Fetch an optimized queryset with optional filters and select/prefetch hints:</p> Python<pre><code>from ninja_aio.models import ModelUtil\nfrom ninja_aio.schemas.helpers import ObjectsQuerySchema\n\nqs = await ModelUtil(Book).get_objects(\n    request,\n    query_data=ObjectsQuerySchema(\n        filters={\"is_published\": True},\n        select_related=[\"author\"],\n        prefetch_related=[\"tags\"],\n    ),\n    with_qs_request=True,  # Apply queryset_request hook\n    is_for=\"read\",  # union with auto-discovered relations for read\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>request</code> (<code>HttpRequest</code>): Current HTTP request</li> <li><code>query_data</code> (<code>ObjectsQuerySchema | None</code>): Query configuration (filters, select_related, prefetch_related)</li> <li><code>with_qs_request</code> (<code>bool</code>): Apply queryset_request hook if available (default: True)</li> <li><code>is_for</code> (<code>Literal[\"read\", \"detail\"] | None</code>): Purpose of the query, determines which serializable fields to use for optimization. Use <code>\"read\"</code> for list operations, <code>\"detail\"</code> for retrieve operations. If <code>None</code>, only query_data optimizations are applied. (default: None)</li> </ul> <p>Returns: Optimized <code>QuerySet</code></p>"},{"location":"api/models/model_util/#get_object","title":"<code>get_object</code>","text":"<p>Fetch a single object by pk or getters with optimizations:</p> Python<pre><code>from ninja_aio.schemas.helpers import ObjectQuerySchema, QuerySchema\n\n# by pk + select/prefetch for detail view\nobj = await ModelUtil(Book).get_object(\n    request,\n    pk=42,\n    query_data=ObjectQuerySchema(select_related=[\"author\"]),\n    with_qs_request=True,\n    is_for=\"detail\",\n)\n\n# by getters (required if pk omitted)\nobj = await ModelUtil(Book).get_object(\n    request,\n    query_data=QuerySchema(getters={\"slug\": \"my-book-slug\"}),\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>request</code> (<code>HttpRequest</code>): Current HTTP request</li> <li><code>pk</code> (<code>int | str | None</code>): Primary key value (optional if getters provided)</li> <li><code>query_data</code> (<code>ObjectQuerySchema | QuerySchema | None</code>): Query configuration</li> <li><code>with_qs_request</code> (<code>bool</code>): Apply queryset_request hook if available (default: True)</li> <li><code>is_for</code> (<code>Literal[\"read\", \"detail\"] | None</code>): Purpose of the query. Use <code>\"detail\"</code> for single object retrieval, <code>\"read\"</code> for list operations. (default: None)</li> </ul> <p>Returns: Model instance</p> <p>Errors:</p> <ul> <li><code>ValueError</code> if neither pk nor getters provided</li> <li><code>NotFoundError</code> if no match found</li> </ul>"},{"location":"api/models/model_util/#read_s-and-list_read_s","title":"<code>read_s</code> and <code>list_read_s</code>","text":"<p>Uniform serialization methods that accept either instances or query data:</p> Python<pre><code>schema = Book.generate_read_s()\ndetail_schema = Book.generate_detail_s()\n\n# single instance\ndata = await ModelUtil(Book).read_s(schema, request, instance=obj)\n\n# single via getters (detail view)\ndata = await ModelUtil(Book).read_s(\n    detail_schema,\n    request,\n    query_data=ObjectQuerySchema(getters={\"pk\": 42}),\n    is_for=\"detail\",\n)\n\n# list from queryset\nitems = await ModelUtil(Book).list_read_s(schema, request, instances=qs)\n\n# list via filters\nitems = await ModelUtil(Book).list_read_s(\n    schema,\n    request,\n    query_data=ObjectsQuerySchema(filters={\"is_published\": True}),\n    is_for=\"read\",\n)\n</code></pre> <p>Parameters (read_s):</p> <ul> <li><code>schema</code> (<code>Schema</code>): Output schema for serialization</li> <li><code>request</code> (<code>HttpRequest</code>): Current HTTP request</li> <li><code>instance</code> (<code>Model | None</code>): Model instance to serialize (optional)</li> <li><code>query_data</code> (<code>ObjectQuerySchema | QuerySchema | None</code>): Query configuration for fetching (optional)</li> <li><code>is_for</code> (<code>Literal[\"read\", \"detail\"] | None</code>): Purpose of the query. Use <code>\"detail\"</code> for single object views, <code>\"read\"</code> for list views. (default: None)</li> </ul> <p>Parameters (list_read_s):</p> <ul> <li><code>schema</code> (<code>Schema</code>): Output schema for serialization</li> <li><code>request</code> (<code>HttpRequest</code>): Current HTTP request</li> <li><code>instances</code> (<code>QuerySet | list[Model] | None</code>): Instances to serialize (optional)</li> <li><code>query_data</code> (<code>ObjectsQuerySchema | None</code>): Query configuration for fetching (optional)</li> <li><code>is_for</code> (<code>Literal[\"read\", \"detail\"] | None</code>): Purpose of the query. Typically <code>\"read\"</code> for list views. (default: None)</li> </ul> <p>Behavior:</p> <ul> <li>When <code>is_for</code> is specified, select_related and prefetch_related are merged with model-discovered relations based on the operation type</li> <li>When <code>is_for=\"detail\"</code> but no <code>QuerySet.detail</code> is configured, falls back to <code>QuerySet.read</code> optimizations</li> <li>Passing <code>instance</code>/<code>instances</code> skips fetching; passing <code>query_data</code> fetches automatically</li> <li>Either <code>instance</code>/<code>instances</code> OR <code>query_data</code> must be provided, not both</li> </ul>"},{"location":"api/models/model_util/#get_reverse_relations","title":"<code>get_reverse_relations()</code>","text":"<p>Discovers reverse relationship field names for prefetch optimization.</p>"},{"location":"api/models/model_util/#signature","title":"Signature","text":"Python<pre><code>def get_reverse_relations() -&gt; list[str]\n</code></pre>"},{"location":"api/models/model_util/#return-value","title":"Return Value","text":"<p>List of reverse relation accessor names.</p>"},{"location":"api/models/model_util/#example","title":"Example","text":"Python<pre><code>class Author(ModelSerializer):\n    name = models.CharField(max_length=200)\n\nclass Book(ModelSerializer):\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"books\")\n\nutil = ModelUtil(Author)\nreverse_rels = util.get_reverse_relations()\nprint(reverse_rels)  # [\"books\"]\n</code></pre>"},{"location":"api/models/model_util/#detected-relation-types","title":"Detected Relation Types","text":"Django Descriptor Example Detected <code>ReverseManyToOneDescriptor</code> <code>author.books</code> \u2713 <code>ReverseOneToOneDescriptor</code> <code>user.profile</code> \u2713 <code>ManyToManyDescriptor</code> <code>article.tags</code> \u2713 <code>ForwardManyToOneDescriptor</code> <code>book.author</code> \u2717 <code>ForwardOneToOneDescriptor</code> <code>profile.user</code> \u2717"},{"location":"api/models/model_util/#use-case","title":"Use Case","text":"Python<pre><code># Avoid N+1 queries when serializing reverse relations\nrelations = util.get_reverse_relations()\nqueryset = Author.objects.prefetch_related(*relations)\n\n# Now iterating over authors won't trigger additional queries for books\nasync for author in queryset:\n    books = await sync_to_async(list)(author.books.all())  # No query!\n</code></pre>"},{"location":"api/models/model_util/#parse_input_data","title":"<code>parse_input_data()</code>","text":"<p>Normalize incoming schema data into model-ready dictionary.</p>"},{"location":"api/models/model_util/#signature_1","title":"Signature","text":"Python<pre><code>async def parse_input_data(\n    request: HttpRequest,\n    data: Schema\n) -&gt; tuple[dict, dict]\n</code></pre>"},{"location":"api/models/model_util/#parameters","title":"Parameters","text":"Parameter Type Description <code>request</code> <code>HttpRequest</code> Current HTTP request <code>data</code> <code>Schema</code> Ninja schema instance"},{"location":"api/models/model_util/#return-value_1","title":"Return Value","text":"<p><code>(payload, customs)</code> where:</p> <ul> <li><code>payload</code> (<code>dict</code>): Model-ready data with resolved relationships</li> <li><code>customs</code> (<code>dict</code>): Custom/synthetic fields stripped from payload</li> </ul>"},{"location":"api/models/model_util/#transformations","title":"Transformations","text":"<ol> <li>Strip custom fields \u2192 Move to <code>customs</code> dict</li> <li>Remove optional None values \u2192 Don't update if not provided</li> <li>Decode BinaryField \u2192 Convert base64 string to bytes</li> <li>Resolve FK IDs \u2192 Fetch related instances</li> </ol>"},{"location":"api/models/model_util/#examples","title":"Examples","text":"<p>Basic transformation:</p> Python<pre><code>from ninja import Schema\n\nclass UserCreateSchema(Schema):\n    username: str\n    email: str\n    bio: str | None = None\n\ndata = UserCreateSchema(\n    username=\"john_doe\",\n    email=\"john@example.com\",\n    bio=None  # Optional, not provided\n)\n\npayload, customs = await util.parse_input_data(request, data)\n\nprint(payload)\n# {\"username\": \"john_doe\", \"email\": \"john@example.com\"}\n# bio is omitted (None stripped)\n\nprint(customs)\n# {}\n</code></pre> <p>With custom fields:</p> Python<pre><code>class User(ModelSerializer):\n    username = models.CharField(max_length=150)\n    email = models.EmailField()\n\n    class CreateSerializer:\n        fields = [\"username\", \"email\"]\n        customs = [\n            (\"password_confirm\", str, None),\n            (\"send_welcome_email\", bool, True),\n        ]\n\n# Schema includes custom fields\ndata = UserCreateSchema(\n    username=\"john\",\n    email=\"john@example.com\",\n    password_confirm=\"secret123\",\n    send_welcome_email=False\n)\n\npayload, customs = await util.parse_input_data(request, data)\n\nprint(payload)\n# {\"username\": \"john\", \"email\": \"john@example.com\"}\n\nprint(customs)\n# {\"password_confirm\": \"secret123\", \"send_welcome_email\": False}\n</code></pre> <p>With ForeignKey resolution:</p> Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    author = models.ForeignKey(User, on_delete=models.CASCADE)\n    category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True)\n\n# Input schema expects IDs\ndata = ArticleCreateSchema(\n    title=\"Getting Started\",\n    author=5,      # User ID\n    category=10    # Category ID\n)\n\npayload, customs = await util.parse_input_data(request, data)\n\nprint(payload)\n# {\n#     \"title\": \"Getting Started\",\n#     \"author\": &lt;User instance with id=5&gt;,\n#     \"category\": &lt;Category instance with id=10&gt;\n# }\n</code></pre> <p>With BinaryField (base64):</p> Python<pre><code>class Document(ModelSerializer):\n    name = models.CharField(max_length=200)\n    file_data = models.BinaryField()\n\ndata = DocumentCreateSchema(\n    name=\"report.pdf\",\n    file_data=\"iVBORw0KGgoAAAANSUhEUgA...\"  # base64 string\n)\n\npayload, customs = await util.parse_input_data(request, data)\n\nprint(payload)\n# {\n#     \"name\": \"report.pdf\",\n#     \"file_data\": b'\\x89PNG\\r\\n\\x1a\\n...'  # decoded bytes\n# }\n</code></pre> <p>Error handling:</p> Python<pre><code>try:\n    payload, customs = await util.parse_input_data(request, bad_data)\nexcept SerializeError as e:\n    print(e.status_code)  # 400\n    print(e.details)\n    # {\"file_data\": \"Invalid base64 encoding\"}\n    # or {\"author\": \"User with id 999 not found\"}\n</code></pre>"},{"location":"api/models/model_util/#parse_output_data","title":"<code>parse_output_data()</code>","text":"<p>Post-process serialized output for consistency.</p>"},{"location":"api/models/model_util/#signature_2","title":"Signature","text":"Python<pre><code>async def parse_output_data(\n    request: HttpRequest,\n    data: Schema\n) -&gt; dict\n</code></pre>"},{"location":"api/models/model_util/#parameters_1","title":"Parameters","text":"Parameter Type Description <code>request</code> <code>HttpRequest</code> Current HTTP request <code>data</code> <code>Schema</code> Serialized schema instance"},{"location":"api/models/model_util/#return-value_2","title":"Return Value","text":"<p>Post-processed dictionary ready for API response.</p>"},{"location":"api/models/model_util/#transformations_1","title":"Transformations","text":"<ol> <li>Replace nested FK dicts \u2192 Actual model instances</li> <li>Add <code>&lt;field&gt;_id</code> keys \u2192 For nested FK references</li> <li>Flatten nested structures \u2192 Consistent response format</li> </ol>"},{"location":"api/models/model_util/#examples_1","title":"Examples","text":"<p>Basic FK transformation:</p> Python<pre><code># Before parse_output_data\n{\n    \"id\": 1,\n    \"title\": \"Article Title\",\n    \"author\": {\"id\": 10, \"username\": \"john_doe\"}\n}\n\n# After parse_output_data\n{\n    \"id\": 1,\n    \"title\": \"Article Title\",\n    \"author\": &lt;User instance&gt;,\n    \"author_id\": 10\n}\n</code></pre> <p>Nested relationships:</p> Python<pre><code># Before\n{\n    \"id\": 1,\n    \"author\": {\n        \"id\": 10,\n        \"profile\": {\n            \"id\": 5,\n            \"bio\": \"Developer\"\n        }\n    }\n}\n\n# After\n{\n    \"id\": 1,\n    \"author\": &lt;User instance&gt;,\n    \"author_id\": 10,\n    \"profile_id\": 5\n}\n</code></pre> <p>Why is this useful?</p> <p>Allows accessing relationships directly in subsequent operations:</p> Python<pre><code>result = await util.read_s(request, article, ArticleReadSchema)\n\n# Direct access to instances (no additional queries)\nauthor_name = result[\"author\"].username\nhas_premium = result[\"author\"].is_premium\n\n# Also provides IDs for convenience\nauthor_id = result[\"author_id\"]\n</code></pre>"},{"location":"api/models/model_util/#verbose_name_path_resolver","title":"<code>verbose_name_path_resolver()</code>","text":"<p>Get URL-friendly path segment from model's verbose name plural.</p>"},{"location":"api/models/model_util/#signature_3","title":"Signature","text":"Python<pre><code>def verbose_name_path_resolver() -&gt; str\n</code></pre>"},{"location":"api/models/model_util/#return-value_3","title":"Return Value","text":"<p>Slugified plural verbose name.</p>"},{"location":"api/models/model_util/#example_1","title":"Example","text":"Python<pre><code>class BlogPost(ModelSerializer):\n    class Meta:\n        verbose_name = \"blog post\"\n        verbose_name_plural = \"blog posts\"\n\nutil = ModelUtil(BlogPost)\npath = util.verbose_name_path_resolver()\nprint(path)  # \"blog-posts\"\n\n# Used in URL routing:\n# /api/blog-posts/\n# /api/blog-posts/{id}/\n</code></pre>"},{"location":"api/models/model_util/#verbose_name_view_resolver","title":"<code>verbose_name_view_resolver()</code>","text":"<p>Get display name from model's singular verbose name.</p>"},{"location":"api/models/model_util/#signature_4","title":"Signature","text":"Python<pre><code>def verbose_name_view_resolver() -&gt; str\n</code></pre>"},{"location":"api/models/model_util/#return-value_4","title":"Return Value","text":"<p>Capitalized singular verbose name.</p>"},{"location":"api/models/model_util/#example_2","title":"Example","text":"Python<pre><code>class BlogPost(ModelSerializer):\n    class Meta:\n        verbose_name = \"blog post\"\n\nutil = ModelUtil(BlogPost)\nname = util.verbose_name_view_resolver()\nprint(name)  # \"Blog post\"\n\n# Used in OpenAPI documentation:\n# \"Create Blog post\"\n# \"Update Blog post\"\n</code></pre>"},{"location":"api/models/model_util/#crud-operations","title":"CRUD Operations","text":""},{"location":"api/models/model_util/#create_s","title":"<code>create_s()</code>","text":"<p>Create new model instance with full lifecycle support.</p>"},{"location":"api/models/model_util/#signature_5","title":"Signature","text":"Python<pre><code>async def create_s(\n    request: HttpRequest,\n    data: Schema,\n    obj_schema: Schema\n) -&gt; dict\n</code></pre>"},{"location":"api/models/model_util/#parameters_2","title":"Parameters","text":"Parameter Type Description <code>request</code> <code>HttpRequest</code> Current HTTP request <code>data</code> <code>Schema</code> Input schema with creation data <code>obj_schema</code> <code>Schema</code> Output schema for response"},{"location":"api/models/model_util/#return-value_5","title":"Return Value","text":"<p>Serialized created object as dictionary.</p>"},{"location":"api/models/model_util/#execution-flow","title":"Execution Flow","text":"Text Only<pre><code>1. parse_input_data(data) \u2192 (payload, customs)\n2. Model.objects.acreate(**payload)\n3. custom_actions(customs)    [if ModelSerializer]\n4. post_create()              [if ModelSerializer]\n5. read_s(obj, obj_schema)\n6. return serialized_dict\n</code></pre>"},{"location":"api/models/model_util/#example_3","title":"Example","text":"Python<pre><code>from ninja import Schema\n\nclass UserCreateSchema(Schema):\n    username: str\n    email: str\n    send_welcome: bool = True\n\nclass UserReadSchema(Schema):\n    id: int\n    username: str\n    email: str\n    created_at: datetime\n\n# Create user\ndata = UserCreateSchema(\n    username=\"john_doe\",\n    email=\"john@example.com\",\n    send_welcome=True\n)\n\nresult = await util.create_s(request, data, UserReadSchema)\n\nprint(result)\n# {\n#     \"id\": 1,\n#     \"username\": \"john_doe\",\n#     \"email\": \"john@example.com\",\n#     \"created_at\": \"2024-01-15T10:30:00Z\"\n# }\n</code></pre>"},{"location":"api/models/model_util/#with-hooks","title":"With Hooks","text":"Python<pre><code>class User(ModelSerializer):\n    username = models.CharField(max_length=150)\n    email = models.EmailField()\n\n    class CreateSerializer:\n        fields = [\"username\", \"email\"]\n        customs = [(\"send_welcome\", bool, True)]\n\n    async def custom_actions(self, payload):\n        if payload.get(\"send_welcome\"):\n            await send_welcome_email(self.email)\n\n    async def post_create(self):\n        await AuditLog.objects.acreate(\n            action=\"user_created\",\n            user_id=self.id\n        )\n\n# Hooks are automatically invoked\nresult = await util.create_s(request, data, UserReadSchema)\n</code></pre>"},{"location":"api/models/model_util/#read_s","title":"<code>read_s()</code>","text":"<p>Serialize model instance to response dict.</p>"},{"location":"api/models/model_util/#signature_6","title":"Signature","text":"Python<pre><code>async def read_s(\n    request: HttpRequest,\n    obj: ModelSerializer | models.Model,\n    obj_schema: Schema\n) -&gt; dict\n</code></pre>"},{"location":"api/models/model_util/#parameters_3","title":"Parameters","text":"Parameter Type Description <code>request</code> <code>HttpRequest</code> Current HTTP request <code>obj</code> <code>ModelSerializer \\| models.Model</code> Model instance to serialize <code>obj_schema</code> <code>Schema</code> Output schema"},{"location":"api/models/model_util/#return-value_6","title":"Return Value","text":"<p>Serialized object as dictionary.</p>"},{"location":"api/models/model_util/#execution-flow_1","title":"Execution Flow","text":"Text Only<pre><code>1. obj_schema.from_orm(obj)\n2. schema.model_dump(mode=\"json\")\n3. parse_output_data(dumped_data)\n4. return processed_dict\n</code></pre>"},{"location":"api/models/model_util/#example_4","title":"Example","text":"Python<pre><code>user = await User.objects.aget(id=1)\nresult = await util.read_s(request, user, UserReadSchema)\n\nprint(result)\n# {\n#     \"id\": 1,\n#     \"username\": \"john_doe\",\n#     \"email\": \"john@example.com\",\n#     \"created_at\": \"2024-01-15T10:30:00Z\"\n# }\n</code></pre>"},{"location":"api/models/model_util/#with-nested-relations","title":"With Nested Relations","text":"Python<pre><code>class ArticleReadSchema(Schema):\n    id: int\n    title: str\n    author: UserReadSchema  # Nested\n\narticle = await Article.objects.select_related('author').aget(id=1)\nresult = await util.read_s(request, article, ArticleReadSchema)\n\nprint(result)\n# {\n#     \"id\": 1,\n#     \"title\": \"Getting Started\",\n#     \"author\": &lt;User instance&gt;,\n#     \"author_id\": 10\n# }\n</code></pre>"},{"location":"api/models/model_util/#update_s","title":"<code>update_s()</code>","text":"<p>Update existing model instance.</p>"},{"location":"api/models/model_util/#signature_7","title":"Signature","text":"Python<pre><code>async def update_s(\n    request: HttpRequest,\n    data: Schema,\n    pk: int | str,\n    obj_schema: Schema\n) -&gt; dict\n</code></pre>"},{"location":"api/models/model_util/#parameters_4","title":"Parameters","text":"Parameter Type Description <code>request</code> <code>HttpRequest</code> Current HTTP request <code>data</code> <code>Schema</code> Input schema with update data <code>pk</code> <code>int \\| str</code> Primary key of object to update <code>obj_schema</code> <code>Schema</code> Output schema for response"},{"location":"api/models/model_util/#return-value_7","title":"Return Value","text":"<p>Serialized updated object as dictionary.</p>"},{"location":"api/models/model_util/#execution-flow_2","title":"Execution Flow","text":"Text Only<pre><code>1. get_object(pk=pk)\n2. parse_input_data(data) \u2192 (payload, customs)\n3. Update obj fields from payload\n4. custom_actions(customs)    [if ModelSerializer]\n5. obj.asave()\n6. read_s(obj, obj_schema)\n7. return serialized_dict\n</code></pre>"},{"location":"api/models/model_util/#example_5","title":"Example","text":"Python<pre><code>class UserUpdateSchema(Schema):\n    email: str | None = None\n    bio: str | None = None\n\ndata = UserUpdateSchema(email=\"newemail@example.com\")\nresult = await util.update_s(request, data, pk=1, obj_schema=UserReadSchema)\n\nprint(result)\n# {\n#     \"id\": 1,\n#     \"username\": \"john_doe\",  # unchanged\n#     \"email\": \"newemail@example.com\",  # updated\n#     \"bio\": \"...\",  # unchanged\n# }\n</code></pre>"},{"location":"api/models/model_util/#partial-updates","title":"Partial Updates","text":"<p>Only provided fields are updated:</p> Python<pre><code># Update only email\ndata = UserUpdateSchema(email=\"new@example.com\")\nawait util.update_s(request, data, pk=1, UserReadSchema)\n\n# Update only bio\ndata = UserUpdateSchema(bio=\"New bio\")\nawait util.update_s(request, data, pk=1, UserReadSchema)\n\n# Update both\ndata = UserUpdateSchema(email=\"new@example.com\", bio=\"New bio\")\nawait util.update_s(request, data, pk=1, UserReadSchema)\n</code></pre>"},{"location":"api/models/model_util/#with-custom-actions","title":"With Custom Actions","text":"Python<pre><code>class User(ModelSerializer):\n    class UpdateSerializer:\n        optionals = [(\"email\", str)]\n        customs = [(\"reset_password\", bool, False)]\n\n    async def custom_actions(self, payload):\n        if payload.get(\"reset_password\"):\n            await self.send_password_reset_email()\n\ndata = UserUpdateSchema(email=\"new@example.com\", reset_password=True)\nawait util.update_s(request, data, pk=1, UserReadSchema)\n# Email updated AND password reset email sent\n</code></pre>"},{"location":"api/models/model_util/#delete_s","title":"<code>delete_s()</code>","text":"<p>Delete model instance.</p>"},{"location":"api/models/model_util/#signature_8","title":"Signature","text":"Python<pre><code>async def delete_s(\n    request: HttpRequest,\n    pk: int | str\n) -&gt; None\n</code></pre>"},{"location":"api/models/model_util/#parameters_5","title":"Parameters","text":"Parameter Type Description <code>request</code> <code>HttpRequest</code> Current HTTP request <code>pk</code> <code>int \\| str</code> Primary key of object to delete"},{"location":"api/models/model_util/#return-value_8","title":"Return Value","text":"<p><code>None</code></p>"},{"location":"api/models/model_util/#execution-flow_3","title":"Execution Flow","text":"Text Only<pre><code>1. get_object(pk=pk)\n2. obj.adelete()\n3. obj.on_delete()    [if ModelSerializer]\n</code></pre>"},{"location":"api/models/model_util/#example_6","title":"Example","text":"Python<pre><code>await util.delete_s(request, pk=1)\n# User with id=1 is deleted\n</code></pre>"},{"location":"api/models/model_util/#with-delete-hook","title":"With Delete Hook","text":"Python<pre><code>class User(ModelSerializer):\n    def on_delete(self):\n        logger.info(f\"User {self.username} deleted\")\n        cache.delete(f\"user:{self.id}\")\n\nawait util.delete_s(request, pk=1)\n# Logs deletion and clears cache\n</code></pre>"},{"location":"api/models/model_util/#error-handling","title":"Error Handling","text":"<p>ModelUtil raises <code>SerializeError</code> for various failure scenarios:</p>"},{"location":"api/models/model_util/#404-not-found","title":"404 Not Found","text":"Python<pre><code>from ninja_aio.exceptions import SerializeError\n\ntry:\n    user = await util.get_object(request, pk=999)\nexcept SerializeError as e:\n    print(e.status_code)  # 404\n    print(e.details)\n    # {\"user\": \"not found\"}\n</code></pre>"},{"location":"api/models/model_util/#400-bad-request","title":"400 Bad Request","text":"<p>Invalid base64:</p> Python<pre><code>try:\n    data = DocumentCreateSchema(\n        name=\"doc.pdf\",\n        file_data=\"not-valid-base64!!!\"\n    )\n    await util.create_s(request, data, DocumentReadSchema)\nexcept SerializeError as e:\n    print(e.status_code)  # 400\n    print(e.details)\n    # {\"file_data\": \"Invalid base64 encoding\"}\n</code></pre> <p>Missing related object:</p> Python<pre><code>try:\n    data = ArticleCreateSchema(\n        title=\"Test\",\n        author=999  # Non-existent user ID\n    )\n    await util.create_s(request, data, ArticleReadSchema)\nexcept SerializeError as e:\n    print(e.status_code)  # 400\n    print(e.details)\n    # {\"author\": \"User with id 999 not found\"}\n</code></pre>"},{"location":"api/models/model_util/#performance-optimization","title":"Performance Optimization","text":""},{"location":"api/models/model_util/#automatic-query-optimization","title":"Automatic Query Optimization","text":"Python<pre><code>class Article(ModelSerializer):\n    author = models.ForeignKey(User, on_delete=models.CASCADE)\n    category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True)\n    tags = models.ManyToManyField(Tag, related_name=\"articles\")\n\nutil = ModelUtil(Article)\n\n# Single query optimization\narticle = await util.get_object(request, pk=1)\n# Automatically executes:\n# SELECT * FROM article\n#   LEFT JOIN user ON article.author_id = user.id\n#   LEFT JOIN category ON article.category_id = category.id\n# WITH prefetch for tags\n\n# Queryset optimization\narticles = await util.get_object(request)\n# Automatically adds select_related and prefetch_related\n</code></pre>"},{"location":"api/models/model_util/#manual-optimization","title":"Manual Optimization","text":"<p>For complex scenarios, override in ModelSerializer:</p> Python<pre><code>class Article(ModelSerializer):\n    @classmethod\n    async def queryset_request(cls, request):\n        return cls.objects.select_related(\n            'author',\n            'author__profile',  # Deep relation\n            'category'\n        ).prefetch_related(\n            'tags',\n            'comments__author'  # Nested prefetch\n        ).only(\n            'id', 'title', 'content',  # Limit fields\n            'author__username',\n            'category__name'\n        )\n</code></pre>"},{"location":"api/models/model_util/#integration-with-apiviewset","title":"Integration with APIViewSet","text":"<p>ModelUtil is automatically used by APIViewSet:</p> Python<pre><code>from ninja_aio.views import APIViewSet\n\nclass UserViewSet(APIViewSet):\n    model = User\n    api = api\n\n    # Internally creates ModelUtil(User)\n    # All CRUD operations use ModelUtil methods\n</code></pre>"},{"location":"api/models/model_util/#complete-example","title":"Complete Example","text":"Python<pre><code>from django.db import models\nfrom ninja_aio.models import ModelSerializer, ModelUtil\nfrom ninja import Schema\nfrom django.http import HttpRequest\n\n# Models\nclass Author(ModelSerializer):\n    name = models.CharField(max_length=200)\n    email = models.EmailField(unique=True)\n\n    class CreateSerializer:\n        fields = [\"name\", \"email\"]\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"email\"]\n\nclass Book(ModelSerializer):\n    title = models.CharField(max_length=200)\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"books\")\n    isbn = models.CharField(max_length=13, unique=True)\n    cover_image = models.BinaryField(null=True)\n    is_published = models.BooleanField(default=False)\n\n    class CreateSerializer:\n        fields = [\"title\", \"author\", \"isbn\"]\n        optionals = [(\"cover_image\", str)]  # base64\n        customs = [(\"notify_author\", bool, True)]\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"author\", \"isbn\", \"is_published\"]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"title\", str),\n            (\"is_published\", bool),\n        ]\n\n    async def custom_actions(self, payload):\n        if payload.get(\"notify_author\"):\n            await send_email(\n                self.author.email,\n                f\"New book created: {self.title}\"\n            )\n\n    async def post_create(self):\n        await AuditLog.objects.acreate(\n            action=\"book_created\",\n            book_id=self.id\n        )\n\n# Usage\nasync def example(request: HttpRequest):\n    util = ModelUtil(Book)\n\n    # Create\n    book_data = BookCreateSchema(\n        title=\"Django Unleashed\",\n        author=5,\n        isbn=\"9781234567890\",\n        cover_image=\"iVBORw0KGgo...\",  # base64\n        notify_author=True\n    )\n    created = await util.create_s(request, book_data, BookReadSchema)\n\n    # Read\n    book = await util.get_object(request, pk=created[\"id\"])\n    serialized = await util.read_s(request, book, BookReadSchema)\n\n    # Update\n    update_data = BookUpdateSchema(is_published=True)\n    updated = await util.update_s(request, update_data, created[\"id\"], BookReadSchema)\n\n    # Delete\n    await util.delete_s(request, created[\"id\"])\n</code></pre>"},{"location":"api/models/model_util/#best-practices","title":"Best Practices","text":"<ol> <li>Always use with async views:</li> </ol> Python<pre><code>async def my_view(request):\n    util = ModelUtil(User)\n    users = await util.get_object(request)\n</code></pre> <ol> <li>Reuse util instances when possible:</li> </ol> Python<pre><code># Good: One util per view\nutil = ModelUtil(User)\nuser = await util.create_s(...)\nupdated = await util.update_s(...)\n</code></pre> <ol> <li>Let ModelUtil handle query optimization:</li> </ol> Python<pre><code># Don't manually optimize unless necessary\nuser = await util.get_object(request, pk=1)\n# ModelUtil already applied select_related/prefetch_related\n</code></pre> <ol> <li>Handle SerializeError appropriately:</li> </ol> Python<pre><code>from ninja_aio.exceptions import SerializeError\n\ntry:\n    result = await util.create_s(request, data, schema)\nexcept SerializeError as e:\n    return e.status_code, e.details\n</code></pre> <ol> <li>Use parse_input_data for custom processing: Python<pre><code>payload, customs = await util.parse_input_data(request, data)\n# Process customs before creation\nif customs.get(\"validate_uniqueness\"):\n    # Custom validation logic\n    pass\n</code></pre></li> </ol>"},{"location":"api/models/model_util/#see-also","title":"See Also","text":"<ul> <li> <p> ModelSerializer</p> <p> Define schemas on models</p> </li> <li> <p> APIViewSet</p> <p> High-level CRUD views</p> </li> </ul>"},{"location":"api/models/serializers/","title":"Serializer (Meta-driven)","text":"<p>The <code>Serializer</code> class provides dynamic schema generation and relation handling for existing Django models without requiring you to adopt the ModelSerializer base class. Use it when:</p> <ul> <li> You already have vanilla Django models in a project and want dynamic Ninja schemas.</li> <li> You prefer to keep models unchanged and define serialization externally.</li> <li> You need to keep your models lean and define API concerns separately.</li> </ul> <p>It mirrors the behavior of ModelSerializer but reads configuration from a nested Meta class.</p>"},{"location":"api/models/serializers/#key-differences-from-modelserializer","title":"Key Differences from ModelSerializer","text":"<p>While both <code>ModelSerializer</code> and <code>Serializer</code> provide schema generation and CRUD operations, there are important differences:</p> Feature ModelSerializer Serializer Model class Custom base class Plain Django model Configuration Nested classes (CreateSerializer) Meta class (schema_in/out/update) Lifecycle hooks Instance methods (uses <code>self</code>) Receives <code>instance</code> parameter Schema generation On-demand via generate_*() methods On-demand via generate_*() methods Usage Inherit from ModelSerializer Separate serializer class Query optimization QuerySet nested class QuerySet nested class (inherited) Relation serializers Auto-resolved Explicit via relations_serializers (supports string refs &amp; Union)"},{"location":"api/models/serializers/#key-points","title":"Key Points","text":"<ul> <li>Works with any Django model (no inheritance required).</li> <li>Generates read/create/update/related schemas on demand via ninja.orm.create_schema.</li> <li>Supports explicit relation serializers for forward and reverse relations.</li> <li>Supports string references in <code>relations_serializers</code> for forward/circular dependencies.</li> <li>Supports Union types for polymorphic relations (e.g., generic foreign keys, content types).</li> <li>Plays nicely with APIViewSet to auto-wire schemas and queryset handling.</li> </ul>"},{"location":"api/models/serializers/#configuration","title":"Configuration","text":"<p>Define a Serializer subclass with a nested Meta:</p> <ul> <li>model: Django model class</li> <li>schema_in: SchemaModelConfig for create inputs</li> <li>schema_out: SchemaModelConfig for read outputs (list endpoint)</li> <li>schema_detail: SchemaModelConfig for detail outputs (retrieve endpoint)</li> <li>schema_update: SchemaModelConfig for patch/update inputs</li> <li>relations_serializers: Mapping of relation field name -&gt; Serializer class, string reference, or Union of serializers (supports forward/circular dependencies and polymorphic relations)</li> <li>relations_as_id: List of relation field names to serialize as IDs instead of nested objects</li> </ul> <p>SchemaModelConfig fields:</p> <ul> <li>fields: <code>list[str | tuple]</code> - Model field names to include. Can also contain inline custom field tuples (see below)</li> <li>optionals: <code>list[tuple[str, type]]</code> - Optional fields with their types</li> <li>exclude: <code>list[str]</code> - Fields to exclude from schema</li> <li>customs: <code>list[tuple[str, type, Any]]</code> - Custom/computed fields</li> </ul>"},{"location":"api/models/serializers/#inline-custom-fields","title":"Inline Custom Fields","text":"<p>You can define custom fields directly in the <code>fields</code> list as tuples, providing a more concise syntax:</p> Python<pre><code>class ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Article\n        schema_out = serializers.SchemaModelConfig(\n            # Mix regular fields with inline custom tuples\n            fields=[\n                \"id\",\n                \"title\",\n                (\"word_count\", int, 0),           # 3-tuple: (name, type, default)\n                (\"is_featured\", bool),             # 2-tuple: (name, type) - required\n            ]\n        )\n</code></pre> <p>Tuple formats:</p> <ul> <li>2-tuple: <code>(name, type)</code> - Required field (equivalent to default <code>...</code>)</li> <li>3-tuple: <code>(name, type, default)</code> - Optional field with default value</li> </ul> <p>This is equivalent to using the separate <code>customs</code> list but keeps field definitions together:</p> Python<pre><code># These two are equivalent:\n\n# Using inline customs\nfields=[\"id\", \"title\", (\"extra\", str, \"default\")]\n\n# Using separate customs list\nfields=[\"id\", \"title\"]\ncustoms=[(\"extra\", str, \"default\")]\n</code></pre>"},{"location":"api/models/serializers/#schema-generation","title":"Schema Generation","text":"<p>Generate schemas explicitly using these methods:</p> Python<pre><code># Explicitly generate schemas when needed\nArticleSerializer.generate_create_s()  # Returns create (In) schema\nArticleSerializer.generate_read_s()    # Returns read (Out) schema for list endpoint\nArticleSerializer.generate_detail_s()  # Returns detail (Out) schema for retrieve endpoint\nArticleSerializer.generate_update_s()  # Returns update (Patch) schema\nArticleSerializer.generate_related_s() # Returns related (nested) schema\n</code></pre> <p>Schemas support forward references and circular dependencies via string references in <code>relations_serializers</code>.</p>"},{"location":"api/models/serializers/#detail-schema-for-retrieve-endpoint","title":"Detail Schema for Retrieve Endpoint","text":"<p>Use <code>schema_detail</code> when you want the retrieve endpoint to return more fields than the list endpoint:</p> Python<pre><code>class ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Article\n        schema_out = serializers.SchemaModelConfig(\n            # List view: minimal fields for performance\n            fields=[\"id\", \"title\", \"summary\"]\n        )\n        schema_detail = serializers.SchemaModelConfig(\n            # Detail view: all fields including expensive relations\n            fields=[\"id\", \"title\", \"summary\", \"content\", \"author\", \"tags\"],\n            customs=[(\"reading_time\", int, lambda obj: len(obj.content.split()) // 200)]\n        )\n</code></pre> <p>When used with <code>APIViewSet</code>: - List endpoint (<code>GET /articles/</code>) uses <code>schema_out</code> - Retrieve endpoint (<code>GET /articles/{pk}</code>) uses <code>schema_detail</code> (falls back to <code>schema_out</code> if not defined)</p> <p>Fallback Behavior: Unlike <code>ModelSerializer</code>, <code>Serializer</code> uses schema-level fallback:</p> <ul> <li>If <code>schema_detail</code> is not defined \u2192 all field types (<code>fields</code>, <code>customs</code>, <code>optionals</code>, <code>exclude</code>) fall back to <code>schema_out</code></li> <li>If <code>schema_detail</code> is defined \u2192 no inheritance from <code>schema_out</code>, even for empty field types</li> </ul> <p>This means you must explicitly define all needed configurations in <code>schema_detail</code> if you define it at all:</p> Python<pre><code>class ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Article\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\"],\n            customs=[(\"word_count\", int, 0)],  # This custom...\n        )\n        schema_detail = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"content\"],\n            # ...is NOT inherited here because schema_detail is defined\n            # You must explicitly add it if needed:\n            # customs=[(\"word_count\", int, 0)],\n        )\n</code></pre>"},{"location":"api/models/serializers/#example-simple-fk","title":"Example: Simple FK","text":"Python<pre><code>from ninja_aio.models import serializers\nfrom . import models\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Article\n        schema_in = serializers.SchemaModelConfig(\n            fields=[\"title\", \"content\", \"author\"]\n        )\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"content\", \"author\"]\n        )\n        schema_update = serializers.SchemaModelConfig(\n            optionals=[(\"title\", str), (\"content\", str)]\n        )\n</code></pre>"},{"location":"api/models/serializers/#lifecycle-hooks","title":"Lifecycle Hooks","text":"<p>Serializer supports lifecycle hooks similar to ModelSerializer, but with a key difference: all hooks receive an <code>instance</code> parameter instead of using <code>self</code>:</p> Python<pre><code>class ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Article\n        schema_in = serializers.SchemaModelConfig(\n            fields=[\"title\", \"content\", \"author\"],\n            customs=[(\"notify_author\", bool, True)]\n        )\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"content\", \"author\"]\n        )\n\n    @classmethod\n    async def queryset_request(cls, request):\n        \"\"\"Filter and optimize queryset per request.\"\"\"\n        return cls._meta.model.objects.select_related(\"author\")\n\n    async def custom_actions(self, payload, instance):\n        \"\"\"Execute custom actions with access to the instance.\"\"\"\n        if payload.get(\"notify_author\"):\n            await send_email(instance.author.email, f\"Article created: {instance.title}\")\n\n    async def post_create(self, instance):\n        \"\"\"Hook after instance creation.\"\"\"\n        await AuditLog.objects.acreate(\n            action=\"article_created\",\n            article_id=instance.id\n        )\n\n    def before_save(self, instance):\n        \"\"\"Sync hook before save (receives instance).\"\"\"\n        instance.slug = slugify(instance.title)\n\n    def after_save(self, instance):\n        \"\"\"Sync hook after save (receives instance).\"\"\"\n        cache.delete(f\"article:{instance.id}\")\n\n    def on_delete(self, instance):\n        \"\"\"Sync hook after deletion (receives instance).\"\"\"\n        logger.info(f\"Article {instance.id} deleted\")\n</code></pre>"},{"location":"api/models/serializers/#available-hooks","title":"Available Hooks","text":"Hook Type When Called Parameters <code>queryset_request(request)</code> async Before queryset building <code>request</code> <code>custom_actions(payload, i)</code> async After field assignment <code>payload</code>, <code>instance</code> <code>post_create(instance)</code> async After first save <code>instance</code> <code>before_save(instance)</code> sync Before any save <code>instance</code> <code>after_save(instance)</code> sync After any save <code>instance</code> <code>on_create_before_save(i)</code> sync Before creation save only <code>instance</code> <code>on_create_after_save(i)</code> sync After creation save only <code>instance</code> <code>on_delete(instance)</code> sync After deletion <code>instance</code>"},{"location":"api/models/serializers/#example-reverse-relation-with-nested-serialization","title":"Example: Reverse Relation with Nested Serialization","text":"Python<pre><code>class AuthorSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Author\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"name\", \"articles\"]  # reverse related name\n        )\n        relations_serializers = {\n            \"articles\": ArticleSerializer,  # include nested article schema\n        }\n</code></pre>"},{"location":"api/models/serializers/#string-references-for-forwardcircular-dependencies","title":"String References for Forward/Circular Dependencies","text":"<p>You can use string references in <code>relations_serializers</code> to handle forward references and circular dependencies:</p> Python<pre><code>class AuthorSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Author\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"name\", \"articles\"]\n        )\n        relations_serializers = {\n            \"articles\": \"ArticleSerializer\",  # String reference - resolved lazily\n        }\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Article\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"author\"]\n        )\n        relations_serializers = {\n            \"author\": \"AuthorSerializer\",  # Circular reference works!\n        }\n</code></pre> <p>String Reference Formats:</p> <ol> <li> <p>Class name in the same module: Python<pre><code>relations_serializers = {\n    \"articles\": \"ArticleSerializer\",  # Resolved in current module\n}\n</code></pre></p> </li> <li> <p>Absolute import path: Python<pre><code>relations_serializers = {\n    \"articles\": \"myapp.serializers.ArticleSerializer\",  # Full import path\n}\n</code></pre></p> </li> </ol> <p>String Reference Requirements: - String can be the class name of a serializer in the same module, or an absolute import path - Absolute paths use dot notation: <code>\"package.module.ClassName\"</code> - References are resolved lazily when schemas are generated - Both forward and circular references are supported</p> <p>Example: Cross-Module References with Absolute Paths</p> Python<pre><code># myapp/serializers.py\nfrom ninja_aio.models import serializers\nfrom . import models\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Article\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"author\"]\n        )\n        relations_serializers = {\n            # Reference a serializer from another module\n            \"author\": \"users.serializers.UserSerializer\",\n        }\n\n# users/serializers.py\nfrom ninja_aio.models import serializers\nfrom . import models\n\nclass UserSerializer(serializers.Serializer):\n    class Meta:\n        model = models.User\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"username\", \"email\", \"articles\"]\n        )\n        relations_serializers = {\n            # Reference back to the article serializer\n            \"articles\": \"myapp.serializers.ArticleSerializer\",\n        }\n</code></pre>"},{"location":"api/models/serializers/#union-types-for-polymorphic-relations","title":"Union Types for Polymorphic Relations","text":"<p>You can use <code>Union</code> types in <code>relations_serializers</code> to handle polymorphic relationships where a field can reference multiple possible serializer types. This is particularly useful for generic foreign keys, content types, or any scenario where a relation can point to different model types.</p> Python<pre><code>from typing import Union\nfrom ninja_aio.models import serializers\nfrom . import models\n\nclass VideoSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Video\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"duration\", \"url\"]\n        )\n\nclass ImageSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Image\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"width\", \"height\", \"url\"]\n        )\n\nclass CommentSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Comment\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"text\", \"content_object\"]\n        )\n        relations_serializers = {\n            # content_object can be a Video or Image\n            \"content_object\": Union[VideoSerializer, ImageSerializer],\n        }\n</code></pre> <p>Union Type Formats:</p> <ol> <li> <p>Direct class references: Python<pre><code>relations_serializers = {\n    \"field\": Union[SerializerA, SerializerB],\n}\n</code></pre></p> </li> <li> <p>String references: Python<pre><code>relations_serializers = {\n    \"field\": Union[\"SerializerA\", \"SerializerB\"],\n}\n</code></pre></p> </li> <li> <p>Mixed class and string references: Python<pre><code>relations_serializers = {\n    \"field\": Union[SerializerA, \"SerializerB\"],\n}\n</code></pre></p> </li> <li> <p>Absolute import paths: Python<pre><code>relations_serializers = {\n    \"field\": Union[\"myapp.serializers.SerializerA\", SerializerB],\n}\n</code></pre></p> </li> </ol> <p>Use Cases for Union Types:</p> <ul> <li>Polymorphic relations: Generic foreign keys or Django ContentType relations</li> <li>Flexible APIs: Different response formats for the same field based on runtime type</li> <li>Gradual migrations: Transitioning between different serializer implementations</li> <li>Multi-tenant systems: Different serialization requirements per tenant</li> </ul> <p>Complete Polymorphic Example:</p> Python<pre><code>from typing import Union\nfrom django.contrib.contenttypes.fields import GenericForeignKey\nfrom ninja_aio.models import serializers\n\n# Models\nclass Comment(models.Model):\n    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)\n    object_id = models.PositiveIntegerField()\n    content_object = GenericForeignKey('content_type', 'object_id')\n    text = models.TextField()\n\n# Serializers for different content types\nclass BlogPostSerializer(serializers.Serializer):\n    class Meta:\n        model = models.BlogPost\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"body\", \"published_at\"]\n        )\n\nclass ProductSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Product\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"name\", \"price\", \"stock\"]\n        )\n\nclass EventSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Event\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"name\", \"date\", \"location\"]\n        )\n\n# Comment serializer with Union support\nclass CommentSerializer(serializers.Serializer):\n    class Meta:\n        model = Comment\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"text\", \"created_at\", \"content_object\"]\n        )\n        relations_serializers = {\n            # Comments can be on blog posts, products, or events\n            \"content_object\": Union[BlogPostSerializer, ProductSerializer, EventSerializer],\n        }\n</code></pre> <p>Notes:</p> <ul> <li>Forward relations are included as plain fields unless a related ModelSerializer/Serializer is declared.</li> <li>Reverse relations require an entry in relations_serializers when using vanilla Django models.</li> <li>When the related model is a ModelSerializer, related schemas can be auto-resolved.</li> <li>Absolute import paths are useful for cross-module references and avoiding circular import issues at module load time.</li> <li>Union types are resolved lazily, so forward and circular references work seamlessly.</li> <li>The schema generator will create a union of all possible schemas from the serializers in the Union.</li> </ul>"},{"location":"api/models/serializers/#relations-as-id","title":"Relations as ID","text":"<p>Use <code>relations_as_id</code> in Meta to serialize relation fields as IDs instead of nested objects. This is useful for:</p> <ul> <li>Reducing response payload size</li> <li>Avoiding circular serialization</li> <li>Performance optimization when nested data isn't needed</li> <li>API designs where clients fetch related data separately</li> </ul> <p>Supported Relations:</p> Relation Type Output Type Example Value Forward FK <code>PK_TYPE \\| None</code> <code>5</code> or <code>null</code> Forward O2O <code>PK_TYPE \\| None</code> <code>3</code> or <code>null</code> Reverse FK <code>list[PK_TYPE]</code> <code>[1, 2, 3]</code> Reverse O2O <code>PK_TYPE \\| None</code> <code>7</code> or <code>null</code> M2M (forward) <code>list[PK_TYPE]</code> <code>[1, 2]</code> M2M (reverse) <code>list[PK_TYPE]</code> <code>[4, 5, 6]</code> <p>Note: <code>PK_TYPE</code> is automatically detected from the related model's primary key field. Supported types include <code>int</code> (default), <code>UUID</code>, <code>str</code>, and any other Django primary key type.</p> <p>Example:</p> Python<pre><code>from ninja_aio.models import serializers\nfrom . import models\n\nclass AuthorSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Author\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"name\", \"books\"]\n        )\n        relations_as_id = [\"books\"]  # Serialize reverse FK as list of IDs\n\nclass BookSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Book\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"author\"]\n        )\n        relations_as_id = [\"author\"]  # Serialize forward FK as ID\n</code></pre> <p>Output (Author):</p> JSON<pre><code>{\n  \"id\": 1,\n  \"name\": \"J.K. Rowling\",\n  \"books\": [1, 2, 3]\n}\n</code></pre> <p>Output (Book):</p> JSON<pre><code>{\n  \"id\": 1,\n  \"title\": \"Harry Potter\",\n  \"author\": 1\n}\n</code></pre> <p>M2M Example:</p> Python<pre><code>class TagSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Tag\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"name\", \"articles\"]\n        )\n        relations_as_id = [\"articles\"]  # Reverse M2M as list of IDs\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Article\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"tags\"]\n        )\n        relations_as_id = [\"tags\"]  # Forward M2M as list of IDs\n</code></pre> <p>Output (Article):</p> JSON<pre><code>{\n  \"id\": 1,\n  \"title\": \"Getting Started with Django\",\n  \"tags\": [1, 2, 5]\n}\n</code></pre> <p>UUID Primary Key Example:</p> <p>When related models use UUID primary keys, the output type is automatically <code>UUID</code>:</p> Python<pre><code>import uuid\nfrom django.db import models\n\nclass Author(models.Model):\n    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\n    name = models.CharField(max_length=200)\n\nclass AuthorSerializer(serializers.Serializer):\n    class Meta:\n        model = Author\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"name\", \"books\"]\n        )\n        relations_as_id = [\"books\"]\n</code></pre> <p>Output (Author with UUID):</p> JSON<pre><code>{\n  \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"name\": \"J.K. Rowling\",\n  \"books\": [\n    \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\",\n    \"6ba7b811-9dad-11d1-80b4-00c04fd430c8\"\n  ]\n}\n</code></pre> <p>Combining with relations_serializers:</p> <p>You can use both <code>relations_as_id</code> and <code>relations_serializers</code> in the same serializer. Fields in <code>relations_as_id</code> take precedence:</p> Python<pre><code>class ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Article\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"author\", \"tags\", \"category\"]\n        )\n        relations_serializers = {\n            \"author\": AuthorSerializer,      # Nested object\n            \"category\": CategorySerializer,  # Nested object\n        }\n        relations_as_id = [\"tags\"]           # Just IDs\n</code></pre> <p>Query Optimization Note: When using <code>relations_as_id</code>, you should still use <code>select_related()</code> for forward relations and <code>prefetch_related()</code> for reverse/M2M relations to avoid N+1 queries:</p> Python<pre><code>class ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Article\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"author\", \"tags\"]\n        )\n        relations_as_id = [\"author\", \"tags\"]\n\n    class QuerySet:\n        read = ModelQuerySetSchema(\n            select_related=[\"author\"],       # For forward FK\n            prefetch_related=[\"tags\"],        # For M2M\n        )\n\n---\n\n## :material-view-grid: Using with APIViewSet\n\nYou can attach a Serializer to an APIViewSet to auto-generate schemas and leverage queryset_request when present:\n\n```python\nfrom ninja_aio.views import APIViewSet\nfrom ninja_aio import NinjaAIO\nfrom . import models\n\napi = NinjaAIO()\n\n@api.viewset(model=models.Article)\nclass ArticleViewSet(APIViewSet):\n    serializer_class = ArticleSerializer\n    # Optionally define query_params or custom handlers\n</code></pre> <p>Behavior:</p> <ul> <li>If <code>model</code> is a ModelSerializer, APIViewSet uses the model to generate schemas directly</li> <li>If <code>model</code> is a vanilla Django model and <code>serializer_class</code> is provided, APIViewSet uses the Serializer to generate missing schemas</li> <li>ModelUtil creates a serializer instance and uses its <code>queryset_request()</code> hook if defined to build optimized querysets</li> <li>Lifecycle hooks from the serializer are invoked during CRUD operations</li> </ul>"},{"location":"api/models/serializers/#crud-operations-with-serializer","title":"CRUD Operations with Serializer","text":"<p>When using a Serializer with APIViewSet, CRUD operations automatically invoke the appropriate lifecycle hooks:</p> Python<pre><code># Create operation flow:\n# 1. parse_input_data() - normalize payload\n# 2. create() - create instance\n# 3. custom_actions() - execute custom logic\n# 4. save() - persists with before/after hooks\n# 5. post_create() - post-creation hook\n# 6. read_s() - serialize response\n\n# Update operation flow:\n# 1. get_object() - fetch instance\n# 2. parse_input_data() - normalize payload\n# 3. update() - update instance fields\n# 4. custom_actions() - execute custom logic\n# 5. save() - persists with before/after hooks\n# 6. read_s() - serialize response\n\n# Delete operation flow:\n# 1. get_object() - fetch instance\n# 2. adelete() - delete instance\n# 3. on_delete() - deletion hook\n</code></pre>"},{"location":"api/models/serializers/#advanced-customs-and-optionals","title":"Advanced: Customs and Optionals","text":"<p>Customs and optionals behave like ModelSerializer:</p> <ul> <li>customs: synthetic fields included in schemas (with default or required when default is Ellipsis).</li> <li>optionals: patch-like optional fields. In read schema, they are included with default None.</li> </ul> Python<pre><code>class PublishSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Article\n        schema_update = serializers.SchemaModelConfig(\n            optionals=[(\"is_published\", bool)],\n            customs=[(\"notify_subscribers\", bool, True)],\n        )\n</code></pre> <p>generate_update_s merges optionals and customs for the Patch schema.</p>"},{"location":"api/models/serializers/#query-optimization-with-serializer","title":"Query Optimization with Serializer","text":"<p>Like ModelSerializer, Serializer supports query optimization via a nested QuerySet class:</p> Python<pre><code>from ninja_aio.schemas.helpers import ModelQuerySetSchema, ModelQuerySetExtraSchema\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Article\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"content\", \"author\", \"category\"]\n        )\n        schema_detail = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"content\", \"author\", \"category\", \"tags\", \"comments\"]\n        )\n\n    class QuerySet:\n        read = ModelQuerySetSchema(\n            select_related=[\"author\", \"category\"],\n            prefetch_related=[\"tags\"],\n        )\n        detail = ModelQuerySetSchema(\n            select_related=[\"author\", \"category\", \"author__profile\"],\n            prefetch_related=[\"tags\", \"comments\", \"comments__author\"],\n        )\n        queryset_request = ModelQuerySetSchema(\n            select_related=[],\n            prefetch_related=[\"comments\"],\n        )\n        extras = [\n            ModelQuerySetExtraSchema(\n                scope=\"detail_view\",\n                select_related=[\"author__profile\"],\n                prefetch_related=[\"tags\", \"comments__author\"],\n            )\n        ]\n</code></pre> <p>The QuerySet configuration is used by ModelUtil to automatically optimize database queries:</p> <ul> <li>read: Applied to list operations (<code>is_for=\"read\"</code>)</li> <li>detail: Applied to retrieve/detail operations (<code>is_for=\"detail\"</code>). Falls back to <code>read</code> if not defined.</li> <li>queryset_request: Applied inside the <code>queryset_request</code> hook</li> <li>extras: Named configurations available via <code>QueryUtil.SCOPES</code></li> </ul>"},{"location":"api/models/serializers/#complete-example","title":"Complete Example","text":"Python<pre><code>from ninja_aio.models import serializers\nfrom ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom django.db import models as django_models\n\n# Plain Django models\nclass Author(django_models.Model):\n    name = django_models.CharField(max_length=200)\n    email = django_models.EmailField()\n\nclass Article(django_models.Model):\n    title = django_models.CharField(max_length=200)\n    content = django_models.TextField()\n    author = django_models.ForeignKey(Author, on_delete=django_models.CASCADE)\n    is_published = django_models.BooleanField(default=False)\n\n# Serializers\nclass AuthorSerializer(serializers.Serializer):\n    class Meta:\n        model = Author\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"name\", \"email\"]\n        )\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = Article\n        schema_in = serializers.SchemaModelConfig(\n            fields=[\"title\", \"content\", \"author\"]\n        )\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"content\", \"author\", \"is_published\"]\n        )\n        schema_update = serializers.SchemaModelConfig(\n            optionals=[(\"title\", str), (\"content\", str)],\n            customs=[(\"publish_now\", bool, False)]\n        )\n        relations_serializers = {\n            \"author\": AuthorSerializer\n        }\n\n    class QuerySet:\n        read = serializers.ModelQuerySetSchema(\n            select_related=[\"author\"]\n        )\n\n    async def custom_actions(self, payload, instance):\n        if payload.get(\"publish_now\"):\n            instance.is_published = True\n            await sync_to_async(instance.save)()\n\n# ViewSets\napi = NinjaAIO()\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    serializer_class = ArticleSerializer\n</code></pre>"},{"location":"api/models/serializers/#when-to-choose-serializer-vs-modelserializer","title":"When to Choose Serializer vs ModelSerializer","text":"<p>Choose Serializer when:</p> <ul> <li>You have existing Django models that you can't or don't want to modify</li> <li>You want to keep models and API concerns separated</li> <li>You're incrementally adding API functionality to an existing project</li> <li>You prefer declarative configuration via Meta classes</li> <li>Multiple teams work on models vs API layers</li> </ul> <p>Choose ModelSerializer when:</p> <ul> <li>You're building a new project from scratch</li> <li>You want to centralize all model and API concerns in one place</li> <li>You prefer configuration via nested classes on the model</li> <li>You want auto-binding and less boilerplate</li> <li>Your models are specifically designed for API usage</li> </ul> <p>Both approaches support:</p> <ul> <li>Nested relations and dynamic schema generation</li> <li>Query optimization via QuerySet configuration</li> <li>Lifecycle hooks for custom business logic</li> <li>Integration with APIViewSet for auto-generated CRUD endpoints</li> </ul> <p>Choose the pattern that best fits your project architecture and team structure.</p>"},{"location":"api/models/serializers/#see-also","title":"See Also","text":"<ul> <li> <p> Model Serializer \u2014 Base class approach with auto-binding</p> <p> Model Serializer</p> </li> <li> <p> Validators \u2014 Field &amp; model validators on serializers</p> <p> Validators</p> </li> <li> <p> Model Util \u2014 Internal CRUD engine and query optimization</p> <p> Model Util</p> </li> <li> <p> APIViewSet \u2014 Auto-generated CRUD endpoints</p> <p> APIViewSet</p> </li> <li> <p> Tutorial: Serializer \u2014 Step-by-step guide</p> <p> Serializer Tutorial</p> </li> </ul>"},{"location":"api/models/validators/","title":"Validators on Serializers","text":"<p>Pydantic's <code>@field_validator</code> and <code>@model_validator</code> can be declared directly on serializer configuration classes. The framework automatically collects these validators and applies them to the generated Pydantic schemas.</p> <p>Use validators when:</p> <ul> <li> You need to enforce input constraints beyond what Django model fields provide (min length, format, cross-field logic)</li> <li> You want schema-level validation that runs before data touches the database</li> <li> You need different validation rules per operation (create vs. update)</li> </ul>"},{"location":"api/models/validators/#modelserializer","title":"ModelSerializer","text":"<p>Define validators directly on the inner serializer classes (<code>CreateSerializer</code>, <code>ReadSerializer</code>, <code>UpdateSerializer</code>, <code>DetailSerializer</code>):</p> Python<pre><code>from django.db import models\nfrom ninja_aio.models import ModelSerializer\nfrom pydantic import field_validator, model_validator\n\n\nclass User(ModelSerializer):\n    username = models.CharField(max_length=150)\n    email = models.EmailField()\n    age = models.PositiveIntegerField(default=0)\n\n    class CreateSerializer:\n        fields = [\"username\", \"email\", \"age\"]\n\n        @field_validator(\"username\")\n        @classmethod\n        def validate_username(cls, v):\n            if len(v) &lt; 3:\n                raise ValueError(\"Username must be at least 3 characters\")\n            if not v.isalnum():\n                raise ValueError(\"Username must be alphanumeric\")\n            return v.lower()\n\n        @field_validator(\"age\")\n        @classmethod\n        def validate_age(cls, v):\n            if v &lt; 13:\n                raise ValueError(\"Must be at least 13 years old\")\n            return v\n\n    class ReadSerializer:\n        fields = [\"id\", \"username\", \"email\"]\n\n    class UpdateSerializer:\n        optionals = [(\"username\", str), (\"email\", str)]\n\n        @field_validator(\"username\")\n        @classmethod\n        def validate_username_not_blank(cls, v):\n            if v is not None and len(v.strip()) == 0:\n                raise ValueError(\"Username cannot be blank\")\n            return v\n</code></pre> <p>Import location</p> <p>The <code>@field_validator</code> and <code>@model_validator</code> decorators must be imported inside each inner class, or at the model class level. Python's scoping rules require the decorator to be accessible where it is used.</p>"},{"location":"api/models/validators/#serializer-meta-driven","title":"Serializer (Meta-driven)","text":"<p>For Meta-driven Serializers, define validators on inner classes named <code>CreateValidators</code>, <code>ReadValidators</code>, <code>UpdateValidators</code>, or <code>DetailValidators</code>:</p> Python<pre><code>from ninja_aio.models import serializers\nfrom pydantic import field_validator, model_validator\nfrom . import models\n\n\nclass UserSerializer(serializers.Serializer):\n    class Meta:\n        model = models.User\n        schema_in = serializers.SchemaModelConfig(\n            fields=[\"username\", \"email\", \"age\"]\n        )\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"username\", \"email\"]\n        )\n        schema_update = serializers.SchemaModelConfig(\n            optionals=[(\"username\", str), (\"email\", str)]\n        )\n\n    class CreateValidators:\n        from pydantic import field_validator\n\n        @field_validator(\"username\")\n        @classmethod\n        def validate_username(cls, v):\n            if len(v) &lt; 3:\n                raise ValueError(\"Username must be at least 3 characters\")\n            return v.lower()\n\n    class UpdateValidators:\n        from pydantic import field_validator\n\n        @field_validator(\"username\")\n        @classmethod\n        def validate_username_not_blank(cls, v):\n            if v is not None and len(v.strip()) == 0:\n                raise ValueError(\"Username cannot be blank\")\n            return v\n</code></pre>"},{"location":"api/models/validators/#validators-class-mapping","title":"Validators Class Mapping","text":"Schema Type Validators Class <code>schema_in</code> <code>CreateValidators</code> <code>schema_update</code> <code>UpdateValidators</code> <code>schema_out</code> <code>ReadValidators</code> <code>schema_detail</code> <code>DetailValidators</code>"},{"location":"api/models/validators/#supported-validator-types","title":"Supported Validator Types","text":""},{"location":"api/models/validators/#field_validator","title":"<code>@field_validator</code>","text":"<p>Validates individual fields. Runs during schema instantiation.</p> Python<pre><code>from pydantic import field_validator\n\nclass CreateSerializer:\n    fields = [\"email\", \"username\"]\n\n    @field_validator(\"email\")\n    @classmethod\n    def validate_email_domain(cls, v):\n        if not v.endswith(\"@company.com\"):\n            raise ValueError(\"Only company emails allowed\")\n        return v\n</code></pre> <p>Modes:</p> Mode Description <code>\"after\"</code> Runs after Pydantic's type validation (default) <code>\"before\"</code> Runs before type coercion <code>\"wrap\"</code> Wraps the default validation <code>\"plain\"</code> Replaces default validation entirely Python<pre><code>@field_validator(\"age\", mode=\"before\")\n@classmethod\ndef coerce_age(cls, v):\n    \"\"\"Accept string ages and convert to int.\"\"\"\n    if isinstance(v, str):\n        return int(v)\n    return v\n</code></pre>"},{"location":"api/models/validators/#model_validator","title":"<code>@model_validator</code>","text":"<p>Validates the entire model after all fields are set. Useful for cross-field validation.</p> Python<pre><code>from pydantic import model_validator\n\nclass CreateSerializer:\n    fields = [\"password\", \"email\"]\n    customs = [(\"password_confirm\", str)]\n\n    @model_validator(mode=\"after\")\n    def check_passwords_match(self):\n        if hasattr(self, 'password_confirm') and self.password != self.password_confirm:\n            raise ValueError(\"Passwords do not match\")\n        return self\n</code></pre> <p>Modes:</p> Mode Description <code>\"after\"</code> Runs after all field validators (receives model instance) <code>\"before\"</code> Runs before field validation (receives raw dict) <code>\"wrap\"</code> Wraps the entire validation process"},{"location":"api/models/validators/#different-validators-per-operation","title":"Different Validators per Operation","text":"<p>A key advantage is applying different validation rules per operation. Create might enforce stricter rules while update allows partial changes:</p> Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    status = models.CharField(max_length=20, default=\"draft\")\n\n    class CreateSerializer:\n        fields = [\"title\", \"content\"]\n\n        @field_validator(\"title\")\n        @classmethod\n        def validate_title(cls, v):\n            if len(v) &lt; 10:\n                raise ValueError(\"Title must be at least 10 characters\")\n            return v\n\n        @field_validator(\"content\")\n        @classmethod\n        def validate_content(cls, v):\n            if len(v) &lt; 50:\n                raise ValueError(\"Content must be at least 50 characters\")\n            return v\n\n    class UpdateSerializer:\n        optionals = [(\"title\", str), (\"content\", str), (\"status\", str)]\n\n        @field_validator(\"status\")\n        @classmethod\n        def validate_status_transition(cls, v):\n            allowed = {\"draft\", \"review\", \"published\", \"archived\"}\n            if v not in allowed:\n                raise ValueError(f\"Status must be one of: {', '.join(allowed)}\")\n            return v\n</code></pre>"},{"location":"api/models/validators/#how-it-works","title":"How It Works","text":"<p>Validators are processed during schema generation:</p> <ol> <li>When <code>generate_create_s()</code>, <code>generate_read_s()</code>, etc. are called, the framework collects any <code>PydanticDescriptorProxy</code> instances (created by <code>@field_validator</code> / <code>@model_validator</code>) from the corresponding configuration class</li> <li>After <code>ninja.orm.create_schema()</code> generates the base Pydantic schema, a subclass is created with the validators attached</li> <li>Pydantic discovers the validators during class creation and registers them normally</li> </ol> <p>This means validators behave exactly as they would on a regular Pydantic model \u2014 including error formatting, mode handling, and validator ordering.</p>"},{"location":"api/models/validators/#error-handling","title":"Error Handling","text":"<p>Validation errors are automatically caught and returned as structured API responses with status code 422:</p> JSON<pre><code>{\n  \"detail\": [\n    {\n      \"type\": \"value_error\",\n      \"loc\": [\"body\", \"username\"],\n      \"msg\": \"Value error, Username must be at least 3 characters\"\n    }\n  ]\n}\n</code></pre> <p>No additional error handling configuration is needed.</p>"},{"location":"api/models/validators/#complete-example","title":"Complete Example","text":"Python<pre><code>from django.db import models\nfrom ninja_aio.models import ModelSerializer\nfrom pydantic import field_validator, model_validator\n\n\nclass Product(ModelSerializer):\n    name = models.CharField(max_length=200)\n    sku = models.CharField(max_length=50, unique=True)\n    price = models.DecimalField(max_digits=10, decimal_places=2)\n    stock = models.PositiveIntegerField(default=0)\n    is_active = models.BooleanField(default=True)\n\n    class CreateSerializer:\n        fields = [\"name\", \"sku\", \"price\", \"stock\"]\n\n        @field_validator(\"sku\")\n        @classmethod\n        def validate_sku_format(cls, v):\n            if not v.startswith(\"PRD-\"):\n                raise ValueError(\"SKU must start with 'PRD-'\")\n            return v.upper()\n\n        @field_validator(\"price\")\n        @classmethod\n        def validate_price_positive(cls, v):\n            if v &lt;= 0:\n                raise ValueError(\"Price must be greater than zero\")\n            return v\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"sku\", \"price\", \"stock\", \"is_active\"]\n        customs = [\n            (\"in_stock\", bool, lambda obj: obj.stock &gt; 0),\n        ]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"name\", str),\n            (\"price\", float),\n            (\"stock\", int),\n            (\"is_active\", bool),\n        ]\n        excludes = [\"sku\"]  # SKU cannot be changed\n\n        @field_validator(\"price\")\n        @classmethod\n        def validate_price_positive(cls, v):\n            if v is not None and v &lt;= 0:\n                raise ValueError(\"Price must be greater than zero\")\n            return v\n\n        @model_validator(mode=\"after\")\n        def validate_stock_active_consistency(self):\n            \"\"\"Cannot activate a product with zero stock.\"\"\"\n            if (\n                getattr(self, \"is_active\", None) is True\n                and getattr(self, \"stock\", None) == 0\n            ):\n                raise ValueError(\"Cannot activate a product with zero stock\")\n            return self\n</code></pre>"},{"location":"api/models/validators/#see-also","title":"See Also","text":"<ul> <li> <p> Model Serializer \u2014 Base class approach with auto-binding</p> <p> Model Serializer</p> </li> <li> <p> Serializer (Meta-driven) \u2014 External serializer for vanilla models</p> <p> Serializer</p> </li> <li> <p> APIViewSet \u2014 Auto-generated CRUD endpoints</p> <p> APIViewSet</p> </li> </ul>"},{"location":"api/renderers/orjson_renderer/","title":"ORJSON Renderer","text":"<p>This package uses an internal ORJSON-based renderer that automatically handles JSON serialization with support for special types.</p>"},{"location":"api/renderers/orjson_renderer/#configuration","title":"Configuration","text":"<p>Configure serialization options via Django settings:</p> Python<pre><code># settings.py\nimport orjson\n\n# Single option\nNINJA_AIO_ORJSON_RENDERER_OPTION = orjson.OPT_INDENT_2\n\n# Multiple options (bitwise OR)\nNINJA_AIO_ORJSON_RENDERER_OPTION = (\n    orjson.OPT_INDENT_2 | orjson.OPT_NON_STR_KEYS\n)\n</code></pre> <p>Notes:</p> <ul> <li>The value is an orjson option bitmask (e.g., <code>orjson.OPT_INDENT_2</code>, <code>orjson.OPT_NON_STR_KEYS</code>), and you can combine multiple options using <code>|</code>.</li> <li>If not set, the default <code>orjson.dumps</code> options are used.</li> </ul>"},{"location":"api/renderers/orjson_renderer/#httpresponse-passthrough","title":"HttpResponse Passthrough","text":"<p>The renderer automatically detects when you return a Django <code>HttpResponse</code> (or any <code>HttpResponseBase</code> subclass) and passes it through without JSON serialization. This allows you to return custom responses with different content types.</p> Python<pre><code>from django.http import HttpResponse\n\n@api.get(\"/public-key\")\ndef get_public_key(request):\n    return HttpResponse(\n        settings.JWT_PUBLIC_KEY.as_pem(),\n        content_type=\"application/x-pem-file\",\n        status=200,\n    )\n</code></pre> <p>This also works with <code>StreamingHttpResponse</code> for large files:</p> Python<pre><code>from django.http import StreamingHttpResponse\n\n@api.get(\"/download\")\ndef download_file(request):\n    return StreamingHttpResponse(\n        file_iterator(),\n        content_type=\"application/octet-stream\",\n    )\n</code></pre> <p>Note</p> <p>When returning an <code>HttpResponse</code> directly, the response bypasses the renderer entirely. Set the <code>status</code> parameter on the <code>HttpResponse</code> itself rather than using a tuple return like <code>return 200, HttpResponse(...)</code>.</p>"},{"location":"api/renderers/orjson_renderer/#see-also","title":"See Also","text":"<ul> <li> <p> APIViewSet</p> <p>Auto-generated CRUD endpoints using orjson rendering</p> <p> Learn more</p> </li> <li> <p> ModelSerializer</p> <p>Schema generation for fast JSON serialization</p> <p> Learn more</p> </li> <li> <p> Quick Start</p> <p>Get up and running in minutes</p> <p> Get started</p> </li> </ul>"},{"location":"api/views/api_view/","title":"API View","text":"<p>The <code>APIView</code> class provides a base for creating simple API endpoints with custom views.</p>"},{"location":"api/views/api_view/#overview","title":"Overview","text":"<p><code>APIView</code> is a lightweight wrapper around Django Ninja's <code>Router</code> that provides:</p> <ul> <li> Organized routing with tags</li> <li> Custom authentication configuration</li> <li> Error handling with standard HTTP status codes</li> </ul>"},{"location":"api/views/api_view/#class-definition","title":"Class Definition","text":"Python<pre><code>class APIView:\n    api: NinjaAPI\n    router_tag: str\n    api_route_path: str\n    auth: list | None = NOT_SET\n</code></pre>"},{"location":"api/views/api_view/#attributes","title":"Attributes","text":"Attribute Type Description <code>api</code> <code>NinjaAPI</code> The NinjaAPI instance to register routes <code>router_tag</code> <code>str</code> Tag name for grouping endpoints in OpenAPI docs <code>api_route_path</code> <code>str</code> Base path for all routes in this view <code>auth</code> <code>list \\| None</code> Authentication classes (optional)"},{"location":"api/views/api_view/#methods","title":"Methods","text":""},{"location":"api/views/api_view/#recommended-decorator-based-endpoints","title":"Recommended: decorator-based endpoints","text":"<p>Prefer class method decorators to define non-CRUD endpoints. Decorators lazily bind instance methods to the router and automatically remove <code>self</code> from the OpenAPI signature while preserving type hints.</p> <p>Available decorators (from <code>ninja_aio.decorators</code>):</p> <ul> <li><code>@api_get(path, ...)</code></li> <li><code>@api_post(path, ...)</code></li> <li><code>@api_put(path, ...)</code></li> <li><code>@api_patch(path, ...)</code></li> <li><code>@api_delete(path, ...)</code></li> <li><code>@api_options(path, ...)</code></li> <li><code>@api_head(path, ...)</code></li> </ul> <p>Example:</p> Python<pre><code>from ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIView\nfrom ninja_aio.decorators import api_get, api_post\nfrom ninja import Schema\n\napi = NinjaAIO(title=\"My API\")\n\nclass StatsSchema(Schema):\n    total: int\n    active: int\n\n@api.view(prefix=\"/analytics\", tags=[\"Analytics\"])\nclass AnalyticsView(APIView):\n    @api_get(\"/dashboard\", response=StatsSchema)\n    async def dashboard(self, request):\n        return {\"total\": 1000, \"active\": 750}\n\n    @api_post(\"/track\")\n    async def track_event(self, request, event: str):\n        return {\"tracked\": event}\n</code></pre> <p>Notes:</p> <ul> <li>Decorators support per-endpoint <code>auth</code>, <code>response</code>, <code>tags</code>, <code>summary</code>, <code>description</code>, throttling, and OpenAPI extras.</li> <li>Sync methods run via <code>sync_to_async</code> automatically.</li> <li><code>self</code> is excluded from the exposed signature; parameter type hints are preserved.</li> </ul>"},{"location":"api/views/api_view/#legacy-views-still-supported","title":"Legacy: <code>views()</code> (still supported)","text":"<p>You can still override <code>views()</code> to define endpoints imperatively.</p> <p>Example - Basic Views:</p> Python<pre><code>class UserAPIView(APIView):\n    api = api_instance\n    router_tag = \"Users\"\n    api_route_path = \"/users\"\n\n    def views(self):\n        @self.router.get(\"/stats\")\n        async def get_stats(request):\n            return {\"total_users\": 100}\n\n        @self.router.post(\"/bulk-create\")\n        async def bulk_create(request, data: list[UserSchema]):\n            # bulk creation logic\n            return {\"created\": len(data)}\n</code></pre> <p>Example - With Authentication:</p> Python<pre><code>class ProtectedAPIView(APIView):\n    api = api_instance\n    router_tag = \"Protected\"\n    api_route_path = \"/protected\"\n    auth = [JWTAuth()]\n\n    def views(self):\n        # Authenticated endpoint\n        @self.router.get(\"/private\", auth=self.auth)\n        async def private_data(request):\n            return {\"user_id\": request.auth.user_id}\n\n        # Public endpoint\n        @self.router.get(\"/public\")\n        async def public_data(request):\n            return {\"message\": \"This is public\"}\n</code></pre>"},{"location":"api/views/api_view/#add_views_to_route","title":"<code>add_views_to_route()</code>","text":"<p>Registers all defined views to the API instance.</p> <p>Returns: The router instance</p> <p>Note: When using <code>@api.view(prefix=\"/path\", tags=[...])</code>, the router is mounted automatically and decorator-based endpoints are registered lazily on instantiation; manual registration via <code>add_views_to_route()</code> is not required.</p>"},{"location":"api/views/api_view/#complete-example","title":"Complete Example","text":"<p>Recommended:</p> Python<pre><code>from ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIView\nfrom ninja_aio.decorators import api_get, api_post\nfrom ninja import Schema\n\napi = NinjaAIO(title=\"My API\")\n\nclass StatsSchema(Schema):\n    total: int\n    active: int\n\n@api.view(prefix=\"/analytics\", tags=[\"Analytics\"])\nclass AnalyticsView(APIView):\n    @api_get(\"/dashboard\", response=StatsSchema)\n    async def dashboard(self, request):\n        return {\"total\": 1000, \"active\": 750}\n\n    @api_post(\"/track\")\n    async def track_event(self, request, event: str):\n        return {\"tracked\": event}\n</code></pre> <p>Alternative implementation:</p> Python<pre><code>api = NinjaAIO(title=\"My API\")\n\nclass AnalyticsView(APIView):\n    api = api\n    router_tag = \"Analytics\"\n    api_route_path = \"/analytics\"\n\n    def views(self):\n        @self.router.get(\"/dashboard\", response=StatsSchema)\n        async def dashboard(request):\n            return {\"total\": 1000, \"active\": 750}\n\n        @self.router.post(\"/track\")\n        async def track_event(request, event: str):\n            return {\"tracked\": event}\n\nAnalyticsView().add_views_to_route()\n</code></pre>"},{"location":"api/views/api_view/#notes","title":"Notes","text":"<ul> <li>Use <code>APIView</code> for simple, non-CRUD endpoints</li> <li>For CRUD operations, use <code>APIViewSet</code></li> <li>All views are async-compatible</li> <li>Standard error codes are available via <code>self.error_codes</code></li> <li>Decorator-based endpoints are preferred for clarity and better OpenAPI signatures.</li> </ul> <p>Note:</p> <ul> <li>Path schema PK type is inferred from the model\u2019s primary key for ViewSets.</li> <li>NinjaAIO remains API-compatible; global CSRF argument is no longer required in initialization.</li> </ul>"},{"location":"api/views/api_view/#see-also","title":"See Also","text":"<ul> <li> <p> APIViewSet</p> <p> Full CRUD operations</p> </li> <li> <p> Authentication</p> <p> Authentication setup</p> </li> </ul>"},{"location":"api/views/api_view_set/","title":"APIViewSet","text":"<p><code>APIViewSet</code> auto-generates async CRUD endpoints and optional Many-to-Many (M2M) endpoints for a Django <code>Model</code> or a <code>ModelSerializer</code>. It supports dynamic schema generation, per-verb authentication, pagination, list &amp; relation filtering with runtime-built Pydantic schemas, and custom view injection.</p>"},{"location":"api/views/api_view_set/#generated-crud-endpoints","title":"Generated CRUD Endpoints","text":"Method Path Summary Response POST <code>/{base}/</code> Create Model <code>201 schema_out</code> GET <code>/{base}/</code> List Models <code>200 List[schema_out]</code> (paginated) GET <code>/{base}/{pk}</code> Retrieve Model <code>200 schema_detail</code> (or <code>schema_out</code> if none) PATCH <code>/{base}/{pk}/</code> Update Model <code>200 schema_out</code> DELETE <code>/{base}/{pk}/</code> Delete Model <code>204 No Content</code> <p>Notes:</p> <ul> <li>Retrieve path typically includes a trailing slash by default (see settings below); update/delete include a trailing slash.</li> <li><code>{base}</code> auto-resolves from model verbose name plural (lowercase) unless <code>api_route_path</code> is provided.</li> <li>Error responses may use a unified generic schema for codes: 400, 401, 404.</li> </ul>"},{"location":"api/views/api_view_set/#settings-trailing-slash-behavior","title":"Settings: trailing slash behavior","text":"<ul> <li>NINJA_AIO_APPEND_SLASH (default: True)</li> <li>When True (default, for backward compatibility), retrieve and POST paths includes a trailing slash into CRUD: <code>/{base}/{pk}/</code>.</li> <li>When False, retrieve and post paths is generated without a trailing slash: <code>/{base}/{pk}</code>.</li> </ul>"},{"location":"api/views/api_view_set/#recommended-decorator-based-extra-endpoints","title":"Recommended: Decorator-based extra endpoints","text":"<p>Use class method decorators to add non-CRUD endpoints to your ViewSet. This is the preferred way to extend a ViewSet with custom routes. The decorators lazily bind instance methods to the router and ensure correct OpenAPI signatures (no <code>self</code> in parameters).</p> <p>Available decorators (from <code>ninja_aio.decorators</code>):</p> <ul> <li><code>@api_get(path, ...)</code></li> <li><code>@api_post(path, ...)</code></li> <li><code>@api_put(path, ...)</code></li> <li><code>@api_patch(path, ...)</code></li> <li><code>@api_delete(path, ...)</code></li> <li><code>@api_options(path, ...)</code></li> <li><code>@api_head(path, ...)</code></li> </ul> <p>Example:</p> Python<pre><code>from ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom ninja_aio.decorators import api_get, api_post\nfrom .models import Article\n\napi = NinjaAIO(title=\"Blog API\")\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    @api_get(\"/stats/\")\n    async def stats(self, request):\n        total = await self.model.objects.acount()\n        return {\"total\": total}\n\n    @api_post(\"/{pk}/publish/\")\n    async def publish(self, request, pk: int):\n        obj = await self.model.objects.aget(pk=pk)\n        obj.is_published = True\n        await obj.asave()\n        return {\"message\": \"published\"}\n</code></pre> <p>Notes:</p> <ul> <li>Decorators support per-endpoint <code>auth</code>, <code>response</code>, <code>tags</code>, <code>summary</code>, <code>description</code>, and more.</li> <li>Sync methods are executed via <code>sync_to_async</code> automatically.</li> <li>Signatures and type hints are preserved for OpenAPI (excluding <code>self</code>).</li> </ul>"},{"location":"api/views/api_view_set/#legacy-views-method-still-supported","title":"Legacy: views() method (still supported)","text":"<p>The previous pattern of injecting endpoints inside <code>views()</code> is still supported, but the decorator-based approach above is now recommended.</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    def views(self):\n        @self.router.get(\"/stats/\")\n        async def stats(request):\n            total = await self.model.objects.acount()\n            return {\"total\": total}\n\n        @self.router.post(\"/{pk}/publish/\")\n        async def publish(request, pk: int):\n            obj = await self.model.objects.aget(pk=pk)\n            obj.is_published = True\n            await obj.asave()\n            return {\"message\": \"published\"}\n</code></pre>"},{"location":"api/views/api_view_set/#core-attributes","title":"Core Attributes","text":"Attribute Type Default Description <code>model</code> <code>ModelSerializer \\| Model</code> \u2014 Target model (required) <code>api</code> <code>NinjaAPI</code> \u2014 API instance (required) <code>serializer_class</code> <code>Serializer \\| None</code> <code>None</code> Serializer class for plain models (alternative to ModelSerializer) <code>schema_in</code> <code>Schema \\| None</code> <code>None</code> (auto) Create input schema override <code>schema_out</code> <code>Schema \\| None</code> <code>None</code> (auto) List/output schema override <code>schema_detail</code> <code>Schema \\| None</code> <code>None</code> (auto) Retrieve/detail schema override (falls back to <code>schema_out</code>) <code>schema_update</code> <code>Schema \\| None</code> <code>None</code> (auto) Update input schema override <code>pagination_class</code> <code>type[AsyncPaginationBase]</code> <code>PageNumberPagination</code> Pagination strategy <code>query_params</code> <code>dict[str, tuple[type, ...]]</code> <code>{}</code> List endpoint filters definition <code>disable</code> <code>list[type[VIEW_TYPES]]</code> <code>[]</code> Disable CRUD views (<code>create</code>,<code>list</code>,<code>retrieve</code>,<code>update</code>,<code>delete</code>,<code>all</code>) <code>api_route_path</code> <code>str</code> <code>\"\"</code> Base route segment <code>list_docs</code> <code>str</code> <code>\"List all objects.\"</code> List endpoint description <code>create_docs</code> <code>str</code> <code>\"Create a new object.\"</code> Create endpoint description <code>retrieve_docs</code> <code>str</code> <code>\"Retrieve a specific object by its primary key.\"</code> Retrieve endpoint description <code>update_docs</code> <code>str</code> <code>\"Update an object by its primary key.\"</code> Update endpoint description <code>delete_docs</code> <code>str</code> <code>\"Delete an object by its primary key.\"</code> Delete endpoint description <code>m2m_relations</code> <code>list[M2MRelationSchema]</code> <code>[]</code> M2M relation configs <code>m2m_auth</code> <code>list \\| None</code> <code>NOT_SET</code> Default auth for all M2M endpoints (overridden per relation if set) <code>extra_decorators</code> <code>DecoratorsSchema</code> <code>DecoratorsSchema()</code> Custom decorators for CRUD operations <code>model_verbose_name</code> <code>str</code> <code>\"\"</code> Override model verbose name for display <code>model_verbose_name_plural</code> <code>str</code> <code>\"\"</code> Override model verbose name plural for display"},{"location":"api/views/api_view_set/#authentication-attributes","title":"Authentication Attributes","text":"Attribute Type Default Description <code>auth</code> <code>list \\| None</code> <code>NOT_SET</code> Global fallback auth <code>get_auth</code> <code>list \\| None</code> <code>NOT_SET</code> Auth for list + retrieve <code>post_auth</code> <code>list \\| None</code> <code>NOT_SET</code> Auth for create <code>patch_auth</code> <code>list \\| None</code> <code>NOT_SET</code> Auth for update <code>delete_auth</code> <code>list \\| None</code> <code>NOT_SET</code> Auth for delete <p>Resolution rules:</p> <ul> <li>Per-verb auth overrides <code>auth</code> when not <code>NOT_SET</code>.</li> <li><code>None</code> makes the endpoint public (no authentication).</li> <li>M2M endpoints use relation-level auth (<code>m2m_data.auth</code>) or fall back to <code>m2m_auth</code>.</li> </ul>"},{"location":"api/views/api_view_set/#transaction-management","title":"Transaction Management","text":"<p>Create, update, and delete operations are automatically wrapped in atomic transactions using the <code>@aatomic</code> decorator. This ensures that database operations are rolled back on exceptions:</p> Python<pre><code>@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    pass  # create/update/delete automatically transactional\n</code></pre> <p>The transaction behavior is applied by default. Custom decorators can be added via <code>extra_decorators</code> attribute.</p>"},{"location":"api/views/api_view_set/#automatic-schema-generation","title":"Automatic Schema Generation","text":"<p>If <code>model</code> is a subclass of <code>ModelSerializerMeta</code>:</p> <ul> <li><code>schema_out</code> is generated from <code>ReadSerializer</code></li> <li><code>schema_detail</code> is generated from <code>DetailSerializer</code> (optional, falls back to <code>schema_out</code>)</li> <li><code>schema_in</code> from <code>CreateSerializer</code></li> <li><code>schema_update</code> from <code>UpdateSerializer</code></li> </ul> <p>For plain Django models, you can provide a <code>serializer_class</code> (Serializer) instead:</p> Python<pre><code>from ninja_aio.models import serializers\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Article\n        schema_in = serializers.SchemaModelConfig(\n            fields=[\"title\", \"content\", \"author\"]\n        )\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"content\", \"author\"]\n        )\n\n@api.viewset(model=models.Article)\nclass ArticleViewSet(APIViewSet):\n    serializer_class = ArticleSerializer\n</code></pre> <p>Otherwise provide schemas manually via <code>schema_in</code>, <code>schema_out</code>, <code>schema_detail</code>, and <code>schema_update</code> attributes.</p>"},{"location":"api/views/api_view_set/#detail-schema-for-retrieve-endpoint","title":"Detail Schema for Retrieve Endpoint","text":"<p>Use <code>schema_detail</code> (or <code>DetailSerializer</code> on ModelSerializer) when you want the retrieve endpoint to return more fields than the list endpoint. This is useful for:</p> <ul> <li>Performance optimization: List endpoints return minimal fields, retrieve endpoints include expensive relations</li> <li>API design: Clients get a summary in lists and full details on individual requests</li> </ul> Python<pre><code>from ninja_aio.models import ModelSerializer\nfrom django.db import models\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    summary = models.TextField()\n    content = models.TextField()\n    author = models.ForeignKey(User, on_delete=models.CASCADE)\n    tags = models.ManyToManyField(Tag)\n\n    class ReadSerializer:\n        # List view: minimal fields\n        fields = [\"id\", \"title\", \"summary\"]\n\n    class DetailSerializer:\n        # Detail view: all fields\n        fields = [\"id\", \"title\", \"summary\", \"content\", \"author\", \"tags\"]\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    pass  # Schemas auto-generated from model\n</code></pre> <p>Endpoints behavior: - <code>GET /articles/</code> returns <code>[{\"id\": 1, \"title\": \"...\", \"summary\": \"...\"}, ...]</code> - <code>GET /articles/1</code> returns <code>{\"id\": 1, \"title\": \"...\", \"summary\": \"...\", \"content\": \"...\", \"author\": {...}, \"tags\": [...]}</code></p>"},{"location":"api/views/api_view_set/#list-filtering","title":"List Filtering","text":"<p>Define filters for the list view with <code>query_params</code>:</p> Python<pre><code>query_params = {\n    \"is_active\": (bool, None),\n    \"role\": (str, None),\n    \"search\": (str, None),\n}\n</code></pre> <p>Override handler:</p> Python<pre><code>async def query_params_handler(self, queryset, filters: dict):\n    if filters.get(\"is_active\") is not None:\n        queryset = queryset.filter(is_active=filters[\"is_active\"])\n    if filters.get(\"role\"):\n        queryset = queryset.filter(role=filters[\"role\"])\n    if filters.get(\"search\"):\n        from django.db.models import Q\n        s = filters[\"search\"]\n        queryset = queryset.filter(Q(username__icontains=s) | Q(email__icontains=s))\n    return queryset\n</code></pre> <p>A dynamic Pydantic model (<code>FiltersSchema</code>) is built with <code>pydantic.create_model</code> from <code>query_params</code>.</p>"},{"location":"api/views/api_view_set/#list-and-retrieve-implementations","title":"List and Retrieve implementations","text":"<p>List now leverages ModelUtil.get_objects and list_read_s, automatically applying read optimizations and optional filters:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    def views(self):\n        @self.router.get(\"/\")\n        async def list(request, filters: self.filters_schema = None):\n            qs = await self.model_util.get_objects(\n                request,\n                query_data=self._get_query_data(),  # defaults from ModelSerializer.QuerySet.read\n                is_for_read=True,\n            )\n            if filters is not None:\n                qs = await self.query_params_handler(qs, filters.model_dump())\n            return await self.model_util.list_read_s(self.schema_out, request, qs)\n</code></pre> <p>Retrieve uses read_s with getters, deriving PK type from the model:</p> Python<pre><code>@self.router.get(\"/{pk}/\")\nasync def retrieve(request, pk: self.path_schema):\n    return await self.model_util.read_s(\n        self.schema_out,\n        request,\n        query_data=QuerySchema(getters={\"pk\": self._get_pk(pk)}),\n        is_for_read=True,\n    )\n</code></pre> <ul> <li>Path schema PK type is inferred from the model\u2019s primary key field.</li> </ul>"},{"location":"api/views/api_view_set/#many-to-many-relations","title":"Many-to-Many Relations","text":"<p>Relations are declared via <code>M2MRelationSchema</code> objects (not tuples). Each schema can include:</p> <ul> <li><code>model</code>: related Django model or ModelSerializer</li> <li><code>related_name</code>: attribute name on the main model (e.g. <code>\"tags\"</code>)</li> <li><code>path</code>: custom URL segment (optional)</li> <li><code>auth</code>: list of auth instances (optional)</li> <li><code>add</code>: enable additions (bool)</li> <li><code>remove</code>: enable removals (bool)</li> <li><code>get</code>: enable GET listing (bool)</li> <li><code>filters</code>: dict of <code>{param_name: (type, default)}</code> for relation-level filtering</li> <li><code>related_schema</code>: optional pre-built schema for the related model (auto-generated if the <code>model</code> is a <code>ModelSerializer</code>)</li> <li><code>serializer_class</code>: optional <code>Serializer</code> class for plain Django models. When provided, <code>related_schema</code> is auto-generated from the serializer. Cannot be used when <code>model</code> is a <code>ModelSerializer</code>.</li> <li><code>append_slash</code>: bool to control trailing slash for the GET relation endpoint path. Defaults to <code>False</code> (no trailing slash) for backward compatibility. When <code>True</code>, the GET path ends with a trailing slash.</li> <li><code>verbose_name_plural</code>: optional human-readable plural name for the related model, used in endpoint summaries and descriptions. When not provided, defaults to the related model's <code>_meta.verbose_name_plural</code>.</li> <li><code>get_decorators</code>: optional list of decorators to apply to the GET (list related objects) endpoint. Decorators are applied via <code>decorate_view()</code> alongside built-in decorators like <code>unique_view</code> and <code>paginate</code>.</li> <li><code>post_decorators</code>: optional list of decorators to apply to the POST (add/remove) endpoint. Decorators are applied via <code>decorate_view()</code> alongside the built-in <code>unique_view</code> decorator.</li> </ul> <p>If <code>path</code> is empty it falls back to the related model verbose name (lowercase plural). If <code>filters</code> is provided, a per-relation filters schema is auto-generated and exposed on the GET relation endpoint: <code>GET /{base}/{pk}/{related_path}?param=value</code></p> <p>Custom filter hook naming convention: <code>&lt;related_name&gt;_query_params_handler(self, queryset, filters_dict)</code></p> <p>The M2M helper:</p> <ul> <li>Returns a paginated list of related items on GET.</li> <li>Supports both sync and async custom filter handlers.</li> <li>Uses <code>list_read_s</code> for related items serialization.</li> </ul> <p>Example filter handler (sync or async):</p> Python<pre><code>def tags_query_params_handler(self, queryset, filters_dict):\n    name = filters_dict.get(\"name\")\n    return queryset.filter(name=name) if name else queryset\n\n# or\n\nasync def tags_query_params_handler(self, queryset, filters_dict):\n    # perform async lookups if needed, then return queryset\n    return queryset\n</code></pre> <p>Warning: Model support</p> <ul> <li>You can supply a standard Django <code>Model</code> (not a <code>ModelSerializer</code>) in <code>M2MRelationSchema.model</code>. When doing so you must provide either <code>related_schema</code> manually or <code>serializer_class</code>:</li> </ul> With related_schemaWith serializer_class Python<pre><code>M2MRelationSchema(\n    model=Tag,                # plain django.db.models.Model\n    related_name=\"tags\",\n    related_schema=TagOut,    # a Pydantic/Ninja Schema you define\n    add=True,\n    remove=True,\n    get=True,\n)\n</code></pre> Python<pre><code>from ninja_aio.models import serializers\n\nclass TagSerializer(serializers.Serializer):\n    class Meta:\n        model = Tag\n        schema_out = serializers.SchemaModelConfig(fields=[\"id\", \"name\"])\n\nM2MRelationSchema(\n    model=Tag,                        # plain django.db.models.Model\n    related_name=\"tags\",\n    serializer_class=TagSerializer,   # auto-generates related_schema\n    add=True,\n    remove=True,\n    get=True,\n)\n</code></pre> <p>For <code>ModelSerializer</code> models, <code>related_schema</code> can be inferred automatically (via internal helpers).</p> <p>Note: You cannot use <code>serializer_class</code> when <code>model</code> is already a <code>ModelSerializer</code> - this will raise a <code>ValueError</code>.</p> <p>Example with filters:</p> Python<pre><code>class UserViewSet(APIViewSet):\n    model = User\n    api = api\n    m2m_relations = [\n        M2MRelationSchema(\n            model=Tag,\n            related_name=\"tags\",\n            filters={\"name\": (str, \"\")}\n        )\n    ]\n\n    async def tags_query_params_handler(self, queryset, filters):\n        name_filter = filters.get(\"name\")\n        if name_filter:\n            queryset = queryset.filter(name__icontains=name_filter)\n        return queryset\n</code></pre>"},{"location":"api/views/api_view_set/#relation-handlers-get-filters-vs-post-per-pk-resolution","title":"Relation Handlers: GET filters vs POST per-PK resolution","text":"<ul> <li> <p>GET filters handler (per relation):</p> </li> <li> <p>Name: <code>&lt;related_name&gt;_query_params_handler(self, queryset, filters_dict)</code></p> </li> <li>Purpose: apply filters to the related list queryset (GET endpoint).</li> <li> <p>Supports both synchronous and asynchronous functions.</p> </li> <li> <p>POST per-PK resolution handler (per relation):</p> </li> <li>Name: <code>&lt;related_name&gt;_query_handler(self, request, pk, instance)</code></li> <li>Purpose: resolve a single related object (for add/remove validation) before mutation.</li> <li>Must return a queryset; the object is resolved with <code>.afirst()</code>.</li> <li>Automatic fallback if missing: <code>ModelUtil(related_model).get_objects(request, ObjectsQuerySchema(filters={\"pk\": pk}))</code> + <code>.afirst()</code>.</li> </ul> <p>Example:</p> Python<pre><code>class MyViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    async def tags_query_params_handler(self, qs, filters: dict):\n        name = filters.get(\"name\")\n        return qs.filter(name__icontains=name) if name else qs\n\n    async def tags_query_handler(self, request, pk, instance):\n        # allow only tags belonging to the same project as the instance\n        return Tag.objects.filter(pk=pk, project_id=instance.project_id)\n</code></pre>"},{"location":"api/views/api_view_set/#endpoint-paths-and-operation-naming","title":"Endpoint paths and operation naming","text":"<ul> <li>GET relation: <code>/{base}/{pk}/{rel_path}</code> by default (no trailing slash). You can enable a trailing slash per relation with <code>append_slash=True</code>, resulting in <code>/{base}/{pk}/{rel_path}/</code>.</li> <li>POST relation: <code>/{base}/{pk}/{rel_path}/</code> (always with trailing slash).</li> </ul> <p>Path normalization rules:</p> <ul> <li>Relation <code>path</code> is normalized internally; providing <code>path</code> with or without a leading slash produces the same final URL.</li> <li>Example: <code>path=\"tags\"</code> or <code>path=\"/tags\"</code> both yield <code>GET /{base}/{pk}/tags</code> (or <code>GET /{base}/{pk}/tags/</code> when <code>append_slash=True</code>) and <code>POST /{base}/{pk}/tags/</code>.</li> <li>If <code>path</code> is empty, it falls back to the related model verbose name.</li> </ul>"},{"location":"api/views/api_view_set/#requestresponse-and-concurrency","title":"Request/Response and concurrency","text":"<p>Request bodies:</p> <ul> <li>Add &amp; Remove: <code>{ \"add\": number[], \"remove\": number[] }</code></li> <li>Add only: <code>{ \"add\": number[] }</code></li> <li>Remove only: <code>{ \"remove\": number[] }</code></li> </ul> <p>Standard response (M2MSchemaOut):</p> JSON<pre><code>{\n  \"results\": { \"count\": X, \"details\": [\"...\"] },\n  \"errors\": { \"count\": Y, \"details\": [\"...\"] }\n}\n</code></pre> <ul> <li>Concurrency: <code>aadd(...)</code> and <code>aremove(...)</code> run in parallel via <code>asyncio.gather</code> when both lists are non-empty.</li> <li>Per-PK errors include: object not found, state mismatch (removing non-related, adding already-related).</li> <li>Per-PK success messages indicate the executed action.</li> </ul>"},{"location":"api/views/api_view_set/#generated-m2m-endpoints-per-relation","title":"Generated M2M Endpoints (per relation)","text":"Method Path Feature GET <code>/{base}/{pk}/{rel_path}</code> List related objects (paginated, optional filters) POST <code>/{base}/{pk}/{rel_path}/</code> Add/remove related objects <p>Example:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    m2m_relations = [\n        M2MRelationSchema(model=Tag, related_name=\"tags\"),\n        M2MRelationSchema(model=Category, related_name=\"categories\", path=\"article-categories\"),\n        M2MRelationSchema(model=User, related_name=\"authors\", path=\"co-authors\", auth=[AdminAuth()])\n    ]\n    m2m_auth = [JWTAuth()]  # fallback for relations without custom auth\n</code></pre> <p>Example with trailing slash on GET relation:</p> Python<pre><code>M2MRelationSchema(\n    model=Tag,\n    related_name=\"tags\",\n    filters={\"name\": (str, \"\")},\n    append_slash=True,  # GET /{base}/{pk}/tags/\n)\n</code></pre> <p>Example with custom verbose name:</p> Python<pre><code>M2MRelationSchema(\n    model=Tag,\n    related_name=\"tags\",\n    verbose_name_plural=\"Article Tags\",  # Used in summaries: \"Get Article Tags\", \"Add or Remove Article Tags\"\n    add=True,\n    remove=True,\n    get=True,\n)\n</code></pre> <p>Example with custom decorators:</p> Python<pre><code>from functools import wraps\n\ndef cache_response(timeout=60):\n    \"\"\"Cache decorator for GET endpoints.\"\"\"\n    def decorator(func):\n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            # caching logic here\n            return await func(*args, **kwargs)\n        return wrapper\n    return decorator\n\ndef rate_limit(max_calls=100):\n    \"\"\"Rate limiting decorator for POST endpoints.\"\"\"\n    def decorator(func):\n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            # rate limiting logic here\n            return await func(*args, **kwargs)\n        return wrapper\n    return decorator\n\nM2MRelationSchema(\n    model=Tag,\n    related_name=\"tags\",\n    get_decorators=[cache_response(timeout=300)],  # Cache GET for 5 minutes\n    post_decorators=[rate_limit(max_calls=50)],     # Rate limit POST operations\n    add=True,\n    remove=True,\n    get=True,\n)\n</code></pre> <p>Note: Decorators are applied in addition to built-in decorators (<code>unique_view</code>, <code>paginate</code>). The order follows standard Python decorator stacking: decorators listed first are applied outermost.</p>"},{"location":"api/views/api_view_set/#custom-views","title":"Custom Views","text":"<p>Preferred (decorators): see the section above.</p> <p>Legacy (still supported):</p> Python<pre><code>def views(self):\n    @self.router.get(\"/stats/\", response={200: GenericMessageSchema})\n    async def stats(request):\n        total = await self.model.objects.acount()\n        return {\"message\": f\"Total: {total}\"}\n</code></pre>"},{"location":"api/views/api_view_set/#dynamic-view-naming","title":"Dynamic View Naming","text":"<p>All generated handlers are decorated with <code>@unique_view(...)</code> to ensure stable unique function names (prevents collisions and ensures consistent OpenAPI schema generation). Relation endpoints use explicit names like <code>get_&lt;model&gt;_&lt;rel_path&gt;</code> and <code>manage_&lt;model&gt;_&lt;rel_path&gt;</code>.</p>"},{"location":"api/views/api_view_set/#extra-decorators","title":"Extra Decorators","text":"<p>Apply custom decorators to specific CRUD operations via the <code>extra_decorators</code> attribute:</p> Python<pre><code>from ninja_aio.schemas.helpers import DecoratorsSchema\nfrom functools import wraps\n\ndef log_operation(func):\n    @wraps(func)\n    async def wrapper(*args, **kwargs):\n        print(f\"Calling {func.__name__}\")\n        return await func(*args, **kwargs)\n    return wrapper\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    extra_decorators = DecoratorsSchema(\n        create=[log_operation],\n        update=[log_operation],\n        delete=[log_operation],\n    )\n</code></pre> <p>Available decorator fields: - <code>create</code>: Decorators for create endpoint - <code>list</code>: Decorators for list endpoint - <code>retrieve</code>: Decorators for retrieve endpoint - <code>update</code>: Decorators for update endpoint - <code>delete</code>: Decorators for delete endpoint</p>"},{"location":"api/views/api_view_set/#overridable-hooks","title":"Overridable Hooks","text":"Hook Purpose <code>views()</code> Register custom endpoints <code>query_params_handler(queryset, filters)</code> Apply list filters <code>&lt;related_name&gt;_query_params_handler(queryset, filters)</code> Apply relation-specific filters"},{"location":"api/views/api_view_set/#error-handling","title":"Error Handling","text":"<p>All CRUD and M2M endpoints may respond with <code>GenericMessageSchema</code> for error codes: 400 (validation), 401 (auth), 404 (not found).</p>"},{"location":"api/views/api_view_set/#performance-tips","title":"Performance Tips","text":"<ol> <li>Implement <code>@classmethod async def queryset_request(cls, request)</code> in your <code>ModelSerializer</code> to prefetch related objects.</li> <li>Use database indexes on filtered fields (<code>query_params</code> and relation <code>filters</code>).</li> <li>Keep pagination enabled for large datasets.</li> <li>Prefetch reverse relations via <code>model_util.get_reverse_relations()</code> (already applied in list view).</li> <li>Limit slice size for expensive searches if needed (<code>queryset = queryset[:1000]</code>).</li> </ol>"},{"location":"api/views/api_view_set/#minimal-usage","title":"Minimal Usage","text":"RecommendedAlternative implementation Python<pre><code>from ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom .models import User\nfrom ninja_aio.decorators import api_get\n\napi = NinjaAIO(title=\"My API\")\n\n@api.viewset(model=User)\nclass UserViewSet(APIViewSet):\n    @api_get(\"/stats/\")\n    async def stats(self, request):\n        total = await self.model.objects.acount()\n        return {\"total\": total}\n</code></pre> Python<pre><code>from ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom .models import User\n\napi = NinjaAIO(title=\"My API\")\n\nclass UserViewSet(APIViewSet):\n    model = User\n    api = api\n\n    def views(self):\n        @self.router.get(\"/stats/\")\n        async def stats(request):\n            total = await self.model.objects.acount()\n            return {\"total\": total}\n\nUserViewSet().add_views_to_route()\n</code></pre> <p>Note: prefix and tags are optional. If omitted, the base path is inferred from the model verbose name plural and tags default to the model verbose name.</p>"},{"location":"api/views/api_view_set/#disable-selected-views","title":"Disable Selected Views","text":"Python<pre><code>@api.viewset(model=User)\nclass ReadOnlyUserViewSet(APIViewSet):\n    disable = [\"create\", \"update\", \"delete\"]\n</code></pre>"},{"location":"api/views/api_view_set/#authentication-example","title":"Authentication Example","text":"Python<pre><code>@api.viewset(model=User)\nclass UserViewSet(APIViewSet):\n    auth = [JWTAuth()]      # global fallback\n    get_auth = None         # list/retrieve public\n    delete_auth = [AdminAuth()]  # delete restricted\n</code></pre>"},{"location":"api/views/api_view_set/#complete-m2m-filters-example","title":"Complete M2M + Filters Example","text":"<p>Recommended:</p> Python<pre><code>from ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom ninja_aio.models import ModelSerializer\nfrom ninja_aio.decorators import api_get\nfrom django.db import models\n\napi = NinjaAIO(title=\"My API\")\n\nclass Tag(ModelSerializer):\n    name = models.CharField(max_length=100)\n    class ReadSerializer:\n        fields = [\"id\", \"name\"]\n\nclass User(ModelSerializer):\n    username = models.CharField(max_length=150)\n    tags = models.ManyToManyField(Tag, related_name=\"users\")\n    class ReadSerializer:\n        fields = [\"id\", \"username\", \"tags\"]\n\n@api.viewset(model=User)\nclass UserViewSet(APIViewSet):\n    query_params = {\"search\": (str, None)}\n    m2m_relations = [\n        M2MRelationSchema(\n            model=Tag,\n            related_name=\"tags\",\n            filters={\"name\": (str, \"\")},\n            add=True,\n            remove=True,\n            get=True,\n        )\n    ]\n\n    async def query_params_handler(self, queryset, filters):\n        if filters.get(\"search\"):\n            from django.db.models import Q\n            s = filters[\"search\"]\n            return queryset.filter(Q(username__icontains=s))\n        return queryset\n\n    async def tags_query_params_handler(self, queryset, filters):\n        name_filter = filters.get(\"name\")\n        if name_filter:\n            queryset = queryset.filter(name__icontains=name_filter)\n        return queryset\n</code></pre> <p>Alternative implementation:</p> Python<pre><code>class UserViewSet(APIViewSet):\n    model = User\n    api = api\n    query_params = {\"search\": (str, None)}\n    m2m_relations = [\n        M2MRelationSchema(\n            model=Tag,\n            related_name=\"tags\",\n            filters={\"name\": (str, \"\")},\n            add=True,\n            remove=True,\n            get=True,\n        )\n    ]\n\n    async def query_params_handler(self, queryset, filters):\n        if filters.get(\"search\"):\n            from django.db.models import Q\n            s = filters[\"search\"]\n            return queryset.filter(Q(username__icontains=s))\n        return queryset\n\n    async def tags_query_params_handler(self, queryset, filters):\n        name_filter = filters.get(\"name\")\n        if name_filter:\n            queryset = queryset.filter(name__icontains=name_filter)\n        return queryset\n\nUserViewSet().add_views_to_route()\n</code></pre>"},{"location":"api/views/api_view_set/#readonlyviewset","title":"ReadOnlyViewSet","text":"<p>ReadOnlyViewSet enables only list and retrieve endpoints.</p> Python<pre><code>@api.viewset(model=MyModel)\nclass MyModelReadOnlyViewSet(ReadOnlyViewSet):\n    pass\n</code></pre>"},{"location":"api/views/api_view_set/#writeonlyviewset","title":"WriteOnlyViewSet","text":"<p>WriteOnlyViewSet enables only create, update, and delete endpoints.</p> Python<pre><code>@api.viewset(model=MyModel)\nclass MyModelWriteOnlyViewSet(WriteOnlyViewSet):\n    pass\n</code></pre>"},{"location":"api/views/api_view_set/#see-also","title":"See Also","text":"<ul> <li> <p> ModelSerializer</p> <p> Schema generation</p> </li> <li> <p> Authentication</p> <p> JWT auth setup</p> </li> <li> <p> Pagination</p> <p> Custom strategies</p> </li> <li> <p> APIView</p> <p> Simple endpoints</p> </li> </ul>"},{"location":"api/views/decorators/","title":"View Decorators","text":"<p>This package provides:</p> <ul> <li> decorate_view \u2014 compose multiple decorators (sync/async views), preserving Python stacking order, and skipping None values.</li> <li> APIViewSet.extra_decorators \u2014 declarative per-operation decorators.</li> </ul>"},{"location":"api/views/decorators/#decorate_view","title":"decorate_view","text":"<p>Behavior:</p> <ul> <li>Order matches normal stacking: <code>@d1</code> over <code>@d2</code> \u2261 <code>d1(d2(view))</code>.</li> <li>Works with sync/async views.</li> <li>Ignores None values, useful for conditional decoration.</li> </ul> <p>Example:</p> Python<pre><code>from ninja_aio.decorators import decorate_view\nfrom ninja_aio.views import APIViewSet\n\nclass MyViewSet(APIViewSet):\n    api = api\n    model = MyModel\n\n    def views(self):\n        @self.router.get(\"health/\")\n        @decorate_view(authenticate, log_request)\n        async def health(request):\n            return {\"ok\": True}\n</code></pre> <p>Conditional decoration:</p> Python<pre><code>cache_dec = cache_page(60) if settings.ENABLE_CACHE else None\n\n@self.router.get(\"data/\")\n@decorate_view(cache_dec, authenticate)\nasync def data(request):\n    ...\n</code></pre> <p>Note: decorate_view does not add an extra wrapper; each decorator should preserve metadata itself (e.g., functools.wraps).</p>"},{"location":"api/views/decorators/#apiviewsetextra_decorators","title":"APIViewSet.extra_decorators","text":"<p>Attach decorators to CRUD operations without redefining views:</p> Python<pre><code>from ninja_aio.schemas.helpers import DecoratorsSchema\n\n@api.viewset(MyModel)\nclass MyViewSet(APIViewSet):\n    extra_decorators = DecoratorsSchema(\n        list=[require_auth, cache_page(30)],\n        retrieve=[require_auth],\n        create=[require_auth],\n        update=[require_auth],\n        delete=[require_auth],\n    )\n</code></pre> <p>These are applied in combination with built-ins (e.g., unique_view, paginate) using decorate_view in the implementation.</p>"},{"location":"api/views/decorators/#m2mrelationschema-decorators","title":"M2MRelationSchema Decorators","text":"<p>Apply custom decorators to Many-to-Many relation endpoints via <code>get_decorators</code> and <code>post_decorators</code>:</p> Python<pre><code>from ninja_aio.schemas import M2MRelationSchema\n\nM2MRelationSchema(\n    model=Tag,\n    related_name=\"tags\",\n    get_decorators=[cache_decorator, log_decorator],   # Applied to GET (list related)\n    post_decorators=[rate_limit_decorator],            # Applied to POST (add/remove)\n)\n</code></pre> <p>These decorators are applied alongside built-in decorators (<code>unique_view</code>, <code>paginate</code>) using <code>decorate_view</code>. See APIViewSet M2M Relations for more details.</p>"},{"location":"api/views/decorators/#apimethodfactorydecorators","title":"ApiMethodFactory.decorators","text":"<p>Example: use api_get within a ViewSet with extra decorators:</p> Python<pre><code>from ninja.pagination import PageNumberPagination\nfrom ninja_aio.decorators.operations import api_get\nfrom ninja_aio.views import APIViewSet\nfrom ninja_aio.models import ModelSerializer\nfrom ninja_aio.decorators import unique_view\nfrom ninja.pagination import paginate\n\nfrom . import models\n\napi = NinjaAIO()\n\n@api.viewset(models.Book)\nclass BookAPI(APIViewSet):\n    query_params = {\n        \"title\": (str, None),\n    }\n\n    @api_get(\n        \"/custom-get\",\n        response={200: list[GenericMessageSchema]},\n        decorators=[paginate(PageNumberPagination), unique_view(\"test-unique-view\")],\n    )\n    async def get_test(self, request):\n        return [{\"message\": \"This is a custom GET method in BookAPI\"}]\n</code></pre> <p>Notes:</p> <ul> <li>Provide decorators as a list; they are applied in reverse order internally.</li> <li>paginate(PageNumberPagination) enables async pagination on the handler.</li> <li>unique_view(name) marks the route as unique to avoid duplicate registration.</li> <li>Works with @api.viewset(Model) classes extending APIViewSet.</li> </ul>"},{"location":"api/views/decorators/#see-also","title":"See Also","text":"<ul> <li> <p> APIViewSet</p> <p>Complete CRUD view generation with decorator support</p> <p> Learn more</p> </li> <li> <p> APIView</p> <p>Base view class for custom endpoints</p> <p> Learn more</p> </li> <li> <p> Mixins</p> <p>Reusable filtering and query behaviors</p> <p> Learn more</p> </li> <li> <p> Pagination</p> <p>Async pagination support for list endpoints</p> <p> Learn more</p> </li> </ul>"},{"location":"api/views/mixins/","title":"ViewSet Mixins","text":"<p>These mixins implement a <code>query_params_handler</code> to apply common filtering patterns to Django QuerySets. Import from <code>ninja_aio.views.mixins</code>. Values used for filtering come from validated query params in your viewset's <code>query_params</code>.</p> <p>Note</p> <p>Each mixin overrides <code>query_params_handler</code>. When composing multiple mixins, define your own <code>query_params_handler</code> and call <code>super()</code> in the desired order.</p>"},{"location":"api/views/mixins/#icontainsfilterviewsetmixin","title":"IcontainsFilterViewSetMixin","text":"<p>Applies case-insensitive substring filters (<code>__icontains</code>) for string values.</p> <ul> <li>Behavior: For each <code>str</code> value in <code>filters</code>, applies <code>field__icontains=value</code>.</li> <li>Ignores non-string values.</li> </ul> <p>Example:</p> Python<pre><code>from ninja_aio.views.mixins import IcontainsFilterViewSetMixin\nfrom ninja_aio.views.api import APIViewSet\n\nclass UserViewSet(IcontainsFilterViewSetMixin, APIViewSet):\n    model = models.User\n    api = api\n    query_params = {\"name\": (str, \"\"), \"email\": (str, \"\")}\n</code></pre>"},{"location":"api/views/mixins/#booleanfilterviewsetmixin","title":"BooleanFilterViewSetMixin","text":"<p>Filters boolean fields using exact match.</p> <ul> <li>Behavior: Applies <code>{key: value}</code> only for <code>bool</code> values.</li> </ul> <p>Example:</p> Python<pre><code>from ninja_aio.views.mixins import BooleanFilterViewSetMixin\n\nclass FeatureViewSet(BooleanFilterViewSetMixin, APIViewSet):\n    model = models.FeatureFlag\n    api = api\n    query_params = {\"enabled\": (bool, False)}\n</code></pre>"},{"location":"api/views/mixins/#numericfilterviewsetmixin","title":"NumericFilterViewSetMixin","text":"<p>Applies exact filters for numeric values.</p> <ul> <li>Behavior: Filters only <code>int</code> and <code>float</code> values.</li> </ul> <p>Example:</p> Python<pre><code>from ninja_aio.views.mixins import NumericFilterViewSetMixin\n\nclass OrderViewSet(NumericFilterViewSetMixin, APIViewSet):\n    model = models.Order\n    api = api\n    query_params = {\"amount\": (float, 0.0), \"quantity\": (int, 0)}\n</code></pre>"},{"location":"api/views/mixins/#datefilterviewsetmixin","title":"DateFilterViewSetMixin","text":"<p>Base mixin for date/datetime filtering with custom comparisons.</p> <ul> <li>Attributes:</li> <li><code>_compare_attr</code>: comparison operator suffix (e.g., <code>__gt</code>, <code>__lt</code>, <code>__gte</code>, <code>__lte</code>).</li> <li>Behavior: Applies filters for values that implement <code>isoformat</code> (date/datetime-like). Prefer using Pydantic <code>date</code>/<code>datetime</code> types in <code>query_params</code>.</li> </ul> <p>Example:</p> Python<pre><code>from ninja_aio.views.mixins import DateFilterViewSetMixin\n\nclass EventViewSet(DateFilterViewSetMixin, APIViewSet):\n    model = models.Event\n    api = api\n    # Use date/datetime types so values have `isoformat`.\n    query_params = {\"created_at\": (datetime, None)}\n    _compare_attr = \"__gt\"\n</code></pre>"},{"location":"api/views/mixins/#greaterdatefilterviewsetmixin","title":"GreaterDateFilterViewSetMixin","text":"<p>Sets comparison to strict greater-than (<code>__gt</code>).</p> <p>Example:</p> Python<pre><code>from ninja_aio.views.mixins import GreaterDateFilterViewSetMixin\n\nclass EventViewSet(GreaterDateFilterViewSetMixin, APIViewSet):\n    model = models.Event\n    api = api\n    query_params = {\"created_at\": (datetime, None)}\n</code></pre>"},{"location":"api/views/mixins/#lessdatefilterviewsetmixin","title":"LessDateFilterViewSetMixin","text":"<p>Sets comparison to strict less-than (<code>__lt</code>).</p> <p>Example:</p> Python<pre><code>from ninja_aio.views.mixins import LessDateFilterViewSetMixin\n\nclass EventViewSet(LessDateFilterViewSetMixin, APIViewSet):\n    model = models.Event\n    api = api\n    query_params = {\"created_at\": (datetime, None)}\n</code></pre>"},{"location":"api/views/mixins/#greaterequaldatefilterviewsetmixin","title":"GreaterEqualDateFilterViewSetMixin","text":"<p>Sets comparison to greater-than-or-equal (<code>__gte</code>).</p> <p>Example:</p> Python<pre><code>from ninja_aio.views.mixins import GreaterEqualDateFilterViewSetMixin\n\nclass EventViewSet(GreaterEqualDateFilterViewSetMixin, APIViewSet):\n    model = models.Event\n    api = api\n    query_params = {\"created_at\": (datetime, None)}\n</code></pre>"},{"location":"api/views/mixins/#lessequaldatefilterviewsetmixin","title":"LessEqualDateFilterViewSetMixin","text":"<p>Sets comparison to less-than-or-equal (<code>__lte</code>).</p> <p>Example:</p> Python<pre><code>from ninja_aio.views.mixins import LessEqualDateFilterViewSetMixin\n\nclass EventViewSet(LessEqualDateFilterViewSetMixin, APIViewSet):\n    model = models.Event\n    api = api\n    query_params = {\"created_at\": (datetime, None)}\n</code></pre>"},{"location":"api/views/mixins/#relationfilterviewsetmixin","title":"RelationFilterViewSetMixin","text":"<p>Filters by related model fields using configurable <code>RelationFilterSchema</code> entries.</p> <ul> <li>Behavior: Maps query parameters to Django ORM lookups on related models.</li> <li>Configuration: Define <code>relations_filters</code> as a list of <code>RelationFilterSchema</code> objects.</li> <li>Query params are automatically registered from <code>relations_filters</code>.</li> </ul> <p>Each <code>RelationFilterSchema</code> requires:</p> <ul> <li><code>query_param</code>: The API query parameter name exposed to clients.</li> <li><code>query_filter</code>: The Django ORM lookup path (e.g., <code>author__id</code>, <code>category__name__icontains</code>).</li> <li><code>filter_type</code>: Tuple of <code>(type, default)</code> for schema generation (e.g., <code>(int, None)</code>).</li> </ul> <p>Example:</p> Python<pre><code>from ninja_aio.views.mixins import RelationFilterViewSetMixin\nfrom ninja_aio.views.api import APIViewSet\nfrom ninja_aio.schemas import RelationFilterSchema\n\nclass BookViewSet(RelationFilterViewSetMixin, APIViewSet):\n    model = models.Book\n    api = api\n    relations_filters = [\n        RelationFilterSchema(\n            query_param=\"author\",\n            query_filter=\"author__id\",\n            filter_type=(int, None),\n        ),\n        RelationFilterSchema(\n            query_param=\"category_name\",\n            query_filter=\"category__name__icontains\",\n            filter_type=(str, None),\n        ),\n    ]\n</code></pre> <p>This enables:</p> <ul> <li><code>GET /books?author=5</code> \u2192 <code>queryset.filter(author__id=5)</code></li> <li><code>GET /books?category_name=fiction</code> \u2192 <code>queryset.filter(category__name__icontains=\"fiction\")</code></li> </ul>"},{"location":"api/views/mixins/#matchcasefilterviewsetmixin","title":"MatchCaseFilterViewSetMixin","text":"<p>Applies conditional filtering based on boolean query parameters, where different filter conditions are applied for <code>True</code> and <code>False</code> values. This is useful when you need to map a simple boolean API parameter to complex underlying filter logic.</p> <ul> <li>Behavior: For each <code>MatchCaseFilterSchema</code> entry, applies different Django ORM filters based on the boolean value of the query parameter.</li> <li>Configuration: Define <code>filters_match_cases</code> as a list of <code>MatchCaseFilterSchema</code> objects.</li> <li>Query params are automatically registered from <code>filters_match_cases</code>.</li> <li>Supports both <code>filter()</code> (include) and <code>exclude()</code> operations via the <code>include</code> attribute.</li> </ul> <p>Each <code>MatchCaseFilterSchema</code> requires:</p> <ul> <li><code>query_param</code>: The API query parameter name exposed to clients.</li> <li><code>cases</code>: A <code>BooleanMatchFilterSchema</code> defining the filter conditions for <code>True</code> and <code>False</code> cases.</li> </ul> <p>Each <code>MatchConditionFilterSchema</code> (used within <code>BooleanMatchFilterSchema</code>) requires:</p> <ul> <li><code>query_filter</code>: A dictionary of Django ORM lookups to apply (e.g., <code>{\"status\": \"active\"}</code>).</li> <li><code>include</code>: Boolean indicating whether to use <code>filter()</code> (True) or <code>exclude()</code> (False). Defaults to <code>True</code>.</li> </ul> <p>Example - Simple status filtering:</p> Python<pre><code>from ninja_aio.views.mixins import MatchCaseFilterViewSetMixin\nfrom ninja_aio.views.api import APIViewSet\nfrom ninja_aio.schemas import (\n    MatchCaseFilterSchema,\n    MatchConditionFilterSchema,\n    BooleanMatchFilterSchema,\n)\n\nclass OrderViewSet(MatchCaseFilterViewSetMixin, APIViewSet):\n    model = models.Order\n    api = api\n    filters_match_cases = [\n        MatchCaseFilterSchema(\n            query_param=\"is_completed\",\n            cases=BooleanMatchFilterSchema(\n                true=MatchConditionFilterSchema(\n                    query_filter={\"status\": \"completed\"},\n                    include=True,\n                ),\n                false=MatchConditionFilterSchema(\n                    query_filter={\"status\": \"completed\"},\n                    include=False,  # excludes completed orders\n                ),\n            ),\n        ),\n    ]\n</code></pre> <p>This enables:</p> <ul> <li><code>GET /orders?is_completed=true</code> \u2192 <code>queryset.filter(status=\"completed\")</code></li> <li><code>GET /orders?is_completed=false</code> \u2192 <code>queryset.exclude(status=\"completed\")</code></li> </ul> <p>Example - Complex filtering with multiple conditions:</p> Python<pre><code>class TaskViewSet(MatchCaseFilterViewSetMixin, APIViewSet):\n    model = models.Task\n    api = api\n    filters_match_cases = [\n        MatchCaseFilterSchema(\n            query_param=\"show_active\",\n            cases=BooleanMatchFilterSchema(\n                true=MatchConditionFilterSchema(\n                    query_filter={\"status__in\": [\"pending\", \"in_progress\"]},\n                    include=True,\n                ),\n                false=MatchConditionFilterSchema(\n                    query_filter={\"status__in\": [\"completed\", \"cancelled\"]},\n                    include=True,\n                ),\n            ),\n        ),\n    ]\n</code></pre> <p>This enables:</p> <ul> <li><code>GET /tasks?show_active=true</code> \u2192 <code>queryset.filter(status__in=[\"pending\", \"in_progress\"])</code></li> <li><code>GET /tasks?show_active=false</code> \u2192 <code>queryset.filter(status__in=[\"completed\", \"cancelled\"])</code></li> </ul>"},{"location":"api/views/mixins/#tips","title":"Tips","text":"<ul> <li>Align <code>query_params</code> types with expected filter values; prefer Pydantic <code>date</code>/<code>datetime</code> for date filters so values implement <code>isoformat</code>.</li> <li>Validate field names and lookups to avoid runtime errors.</li> <li>For multiple mixins, implement your own <code>async def query_params_handler(...)</code> and chain with <code>await super().query_params_handler(...)</code> to combine behaviors.</li> </ul>"},{"location":"api/views/mixins/#see-also","title":"See Also","text":"<ul> <li> <p> APIViewSet</p> <p>Complete CRUD operations with mixin support</p> <p> Learn more</p> </li> <li> <p> Filtering Tutorial</p> <p>Step-by-step guide to filtering &amp; pagination</p> <p> Learn more</p> </li> <li> <p> Decorators</p> <p>Route decorators for pagination and unique views</p> <p> Learn more</p> </li> <li> <p> APIView</p> <p>Base view class for custom endpoints</p> <p> Learn more</p> </li> </ul>"},{"location":"getting_started/installation/","title":"Installation","text":""},{"location":"getting_started/installation/#installation","title":"Installation","text":"pippoetrypipenv Bash<pre><code>pip install django-ninja-aio-crud\n</code></pre> Bash<pre><code>poetry add django-ninja-aio-crud\n</code></pre> Bash<pre><code>pipenv install django-ninja-aio-crud\n</code></pre> <p>Requirements</p> <ul> <li>Python 3.10+</li> <li>Django 4.1+ (for async ORM support)</li> <li>django-ninja &gt;=1.3.0 (installed automatically)</li> </ul>"},{"location":"getting_started/installation/#next-steps","title":"Next Steps","text":"<ul> <li> <p> Quick Start (ModelSerializer)</p> <p>Define schemas directly on your Django models</p> <p> Get started</p> </li> <li> <p> Quick Start (Serializer)</p> <p>Keep models unchanged with separate serializer classes</p> <p> Get started</p> </li> <li> <p> Tutorial</p> <p>Step-by-step guide to building a complete API</p> <p> Start tutorial</p> </li> <li> <p> API Reference</p> <p>Detailed documentation for all components</p> <p> Explore</p> </li> </ul>"},{"location":"getting_started/quick_start/","title":"Quick Start (ModelSerializer)","text":""},{"location":"getting_started/quick_start/#quick-start-modelserializer","title":"Quick Start (ModelSerializer)","text":"<p>This guide shows how to create a CRUD API using <code>ModelSerializer</code>, which combines your Django model and serialization configuration in a single class.</p> <p>Alternative Approach</p> <p>If you prefer to keep your models unchanged and define serialization separately, see Quick Start (Serializer).</p>"},{"location":"getting_started/quick_start/#1-create-your-model","title":"1. Create Your Model","text":"<p>Define your model using <code>ModelSerializer</code> with embedded serializer configuration:</p> Python<pre><code># models.py\nfrom django.db import models\nfrom ninja_aio.models import ModelSerializer\n\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    is_published = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"content\", \"is_published\", \"created_at\"]\n\n    class CreateSerializer:\n        fields = [\"title\", \"content\"]\n        optionals = [(\"is_published\", bool)]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"title\", str),\n            (\"content\", str),\n            (\"is_published\", bool),\n        ]\n</code></pre>"},{"location":"getting_started/quick_start/#2-create-your-viewset","title":"2. Create Your ViewSet","text":"<p>Define your API views using <code>APIViewSet</code>:</p> Python<pre><code># views.py\nfrom ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom .models import Article\n\napi = NinjaAIO(title=\"My Blog API\", version=\"1.0.0\")\n\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    pass\n</code></pre>"},{"location":"getting_started/quick_start/#3-configure-urls","title":"3. Configure URLs","text":"<p>Add the API to your URL configuration:</p> Python<pre><code># urls.py\nfrom django.urls import path\nfrom .views import api\n\nurlpatterns = [\n    path(\"api/\", api.urls),\n]\n</code></pre>"},{"location":"getting_started/quick_start/#4-run-your-server","title":"4. Run Your Server","text":"Bash<pre><code>python manage.py runserver\n</code></pre> <p>Visit http://localhost:8000/api/docs to see your auto-generated API documentation!</p>"},{"location":"getting_started/quick_start/#generated-api-documentation","title":"Generated API Documentation","text":""},{"location":"getting_started/quick_start/#endpoints-overview","title":"Endpoints Overview","text":"<p>Your API automatically includes:</p> Method Endpoint Description <code>GET</code> <code>/article/</code> List all articles (paginated) <code>POST</code> <code>/article/</code> Create new article <code>GET</code> <code>/article/{id}</code> Retrieve single article <code>PATCH</code> <code>/article/{id}/</code> Update article <code>DELETE</code> <code>/article/{id}/</code> Delete article"},{"location":"getting_started/quick_start/#list-endpoint","title":"List Endpoint","text":"<ul> <li> Automatic pagination</li> <li> Query parameter filtering</li> <li> Sorting support</li> </ul>"},{"location":"getting_started/quick_start/#create-endpoint","title":"Create Endpoint","text":"<ul> <li> Input validation</li> <li> Custom field support</li> <li> Relationship handling</li> </ul>"},{"location":"getting_started/quick_start/#retrieve-endpoint","title":"Retrieve Endpoint","text":"<ul> <li> Nested relationship serialization</li> <li> Optimized queries</li> </ul>"},{"location":"getting_started/quick_start/#update-endpoint","title":"Update Endpoint","text":"<ul> <li> Partial updates (PATCH)</li> <li> Field-level validation</li> <li> Custom actions</li> </ul>"},{"location":"getting_started/quick_start/#delete-endpoint","title":"Delete Endpoint","text":"<ul> <li> Soft delete support</li> <li> Cascade handling</li> <li> Custom hooks</li> </ul>"},{"location":"getting_started/quick_start/#next-steps","title":"Next Steps","text":"<ul> <li> <p> ModelSerializer Reference</p> <p>Deep dive into all ModelSerializer features</p> <p> Learn more</p> </li> <li> <p> APIViewSet Features</p> <p>Custom endpoints, pagination, and filtering</p> <p> Explore</p> </li> <li> <p> Authentication</p> <p>Add JWT authentication to your API</p> <p> Add auth</p> </li> <li> <p> Full Tutorial</p> <p>Step-by-step guide covering all features</p> <p> Start tutorial</p> </li> </ul>"},{"location":"getting_started/quick_start_serializer/","title":"Quick Start (Serializer)","text":""},{"location":"getting_started/quick_start_serializer/#quick-start-serializer","title":"Quick Start (Serializer)","text":"<p>This guide shows how to create a CRUD API using the <code>Serializer</code> class with plain Django models. This approach keeps your models unchanged and defines API configuration separately.</p> <p>Alternative Approach</p> <p>If you prefer an all-in-one approach with embedded serialization, see Quick Start (ModelSerializer).</p>"},{"location":"getting_started/quick_start_serializer/#when-to-use-serializer","title":"When to Use Serializer","text":"<p>Choose the <code>Serializer</code> approach when:</p> <ul> <li> You have existing Django models you don't want to modify</li> <li> You want to keep models and API concerns separated</li> <li> You're adding API functionality to an existing project</li> <li> Multiple teams work on models vs. API layers</li> </ul>"},{"location":"getting_started/quick_start_serializer/#1-create-your-model","title":"1. Create Your Model","text":"<p>Use a standard Django model:</p> Python<pre><code># models.py\nfrom django.db import models\n\n\nclass Article(models.Model):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    is_published = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    class Meta:\n        ordering = [\"-created_at\"]\n</code></pre>"},{"location":"getting_started/quick_start_serializer/#2-create-your-serializer","title":"2. Create Your Serializer","text":"<p>Define a <code>Serializer</code> class with API configuration in a nested <code>Meta</code> class:</p> Python<pre><code># serializers.py\nfrom ninja_aio.models import serializers\nfrom .models import Article\n\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = Article\n        schema_in = serializers.SchemaModelConfig(\n            fields=[\"title\", \"content\"],\n            optionals=[(\"is_published\", bool)],\n        )\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"content\", \"is_published\", \"created_at\"]\n        )\n        schema_update = serializers.SchemaModelConfig(\n            optionals=[\n                (\"title\", str),\n                (\"content\", str),\n                (\"is_published\", bool),\n            ]\n        )\n</code></pre>"},{"location":"getting_started/quick_start_serializer/#3-create-your-viewset","title":"3. Create Your ViewSet","text":"<p>Define your API views using <code>APIViewSet</code> with <code>serializer_class</code>:</p> Python<pre><code># views.py\nfrom ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom .models import Article\nfrom .serializers import ArticleSerializer\n\napi = NinjaAIO(title=\"My Blog API\", version=\"1.0.0\")\n\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    serializer_class = ArticleSerializer\n</code></pre>"},{"location":"getting_started/quick_start_serializer/#4-configure-urls","title":"4. Configure URLs","text":"<p>Add the API to your URL configuration:</p> Python<pre><code># urls.py\nfrom django.urls import path\nfrom .views import api\n\nurlpatterns = [\n    path(\"api/\", api.urls),\n]\n</code></pre>"},{"location":"getting_started/quick_start_serializer/#5-run-your-server","title":"5. Run Your Server","text":"Bash<pre><code>python manage.py runserver\n</code></pre> <p>Visit http://localhost:8000/api/docs to see your auto-generated API documentation!</p>"},{"location":"getting_started/quick_start_serializer/#adding-relationships","title":"Adding Relationships","text":"<p>The <code>Serializer</code> approach supports nested serialization for related models:</p> Python<pre><code># models.py\nfrom django.db import models\n\n\nclass Author(models.Model):\n    name = models.CharField(max_length=200)\n    email = models.EmailField()\n\n\nclass Article(models.Model):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"articles\")\n    is_published = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n</code></pre> Python<pre><code># serializers.py\nfrom ninja_aio.models import serializers\nfrom .models import Author, Article\n\n\nclass AuthorSerializer(serializers.Serializer):\n    class Meta:\n        model = Author\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"name\", \"email\"]\n        )\n\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = Article\n        schema_in = serializers.SchemaModelConfig(\n            fields=[\"title\", \"content\", \"author\"],\n        )\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"content\", \"author\", \"is_published\", \"created_at\"]\n        )\n        schema_update = serializers.SchemaModelConfig(\n            optionals=[\n                (\"title\", str),\n                (\"content\", str),\n                (\"is_published\", bool),\n            ]\n        )\n        # Nested serialization for the author field\n        relations_serializers = {\n            \"author\": AuthorSerializer,\n        }\n\n    class QuerySet:\n        # Optimize queries with select_related\n        read = serializers.ModelQuerySetSchema(\n            select_related=[\"author\"]\n        )\n</code></pre>"},{"location":"getting_started/quick_start_serializer/#adding-lifecycle-hooks","title":"Adding Lifecycle Hooks","text":"<p>Add custom logic to CRUD operations using hooks:</p> Python<pre><code># serializers.py\nfrom ninja_aio.models import serializers\nfrom .models import Article\n\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = Article\n        schema_in = serializers.SchemaModelConfig(\n            fields=[\"title\", \"content\"],\n            customs=[(\"notify_subscribers\", bool, False)],  # Custom field\n        )\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"content\", \"is_published\", \"created_at\"]\n        )\n        schema_update = serializers.SchemaModelConfig(\n            optionals=[(\"title\", str), (\"content\", str), (\"is_published\", bool)]\n        )\n\n    async def custom_actions(self, payload, instance):\n        \"\"\"Execute after field assignment, before save.\"\"\"\n        if payload.get(\"notify_subscribers\"):\n            await send_notification(instance.title)\n\n    async def post_create(self, instance):\n        \"\"\"Execute after instance creation.\"\"\"\n        await AuditLog.objects.acreate(\n            action=\"article_created\",\n            article_id=instance.id\n        )\n\n    def before_save(self, instance):\n        \"\"\"Execute before any save (sync hook).\"\"\"\n        instance.slug = slugify(instance.title)\n\n    def on_delete(self, instance):\n        \"\"\"Execute after deletion (sync hook).\"\"\"\n        logger.info(f\"Article {instance.id} deleted\")\n</code></pre>"},{"location":"getting_started/quick_start_serializer/#next-steps","title":"Next Steps","text":"<ul> <li> <p> Serializer Configuration</p> <p> Learn more</p> </li> <li> <p> APIViewSet Features</p> <p> Explore</p> </li> <li> <p> Authentication</p> <p> Add auth</p> </li> <li> <p> Pagination</p> <p> Configure</p> </li> </ul>"},{"location":"tutorial/authentication/","title":"Step 3: Add Authentication","text":"<p>Step 3 of 4</p> <p>Prerequisites \u2014 Make sure you've completed Step 1: Define Your Model and Step 2: Create CRUD Views.</p>"},{"location":"tutorial/authentication/#add-authentication","title":"Add Authentication","text":"<p> Secure your API with JWT authentication and implement role-based access control. </p>"},{"location":"tutorial/authentication/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li> Setting up JWT authentication</li> <li> Protecting endpoints</li> <li> Implementing role-based access</li> <li> Creating login/register endpoints</li> <li> Testing authenticated requests</li> </ul>"},{"location":"tutorial/authentication/#setting-up-jwt-keys","title":"Setting Up JWT Keys","text":""},{"location":"tutorial/authentication/#generate-rsa-keys-recommended-for-production","title":"Generate RSA Keys (Recommended for Production)","text":"Bash<pre><code># Generate private key\nopenssl genrsa -out private_key.pem 2048\n\n# Generate public key\nopenssl rsa -in private_key.pem -pubout -out public_key.pem\n</code></pre>"},{"location":"tutorial/authentication/#store-keys-securely","title":"Store Keys Securely","text":"Python<pre><code># settings.py\nimport os\nfrom pathlib import Path\n\nBASE_DIR = Path(__file__).resolve().parent.parent\n\n# JWT Settings\nJWT_PRIVATE_KEY_PATH = os.path.join(BASE_DIR, 'private_key.pem')\nJWT_PUBLIC_KEY_PATH = os.path.join(BASE_DIR, 'public_key.pem')\n\n# Read keys\nwith open(JWT_PUBLIC_KEY_PATH, 'r') as f:\n    JWT_PUBLIC_KEY = f.read()\n\nwith open(JWT_PRIVATE_KEY_PATH, 'r') as f:\n    JWT_PRIVATE_KEY = f.read()\n\n# Token expiration (in seconds)\nJWT_ACCESS_TOKEN_EXPIRE = 60 * 15  # 15 minutes\nJWT_REFRESH_TOKEN_EXPIRE = 60 * 60 * 24 * 7  # 7 days\n\n# JWT Claims\nJWT_ISSUER = \"https://your-api.com\"\nJWT_AUDIENCE = \"your-api\"\n</code></pre> <p>Security</p> <p>Never commit your private key to version control! Add <code>private_key.pem</code> to your <code>.gitignore</code>.</p>"},{"location":"tutorial/authentication/#create-user-model","title":"Create User Model","text":"<p>Update your User model to work with authentication:</p> Python<pre><code># models.py\nfrom django.contrib.auth.models import AbstractUser\nfrom django.db import models\nfrom ninja_aio.models import ModelSerializer\n\n\nclass User(AbstractUser, ModelSerializer):\n    email = models.EmailField(unique=True)\n    bio = models.TextField(blank=True)\n    avatar = models.URLField(blank=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"username\", \"email\", \"first_name\", \"last_name\", \"bio\", \"avatar\"]\n        excludes = [\"password\"]\n\n    class CreateSerializer:\n        fields = [\"username\", \"email\", \"password\", \"first_name\", \"last_name\"]\n        optionals = [(\"bio\", str), (\"avatar\", str)]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"first_name\", str),\n            (\"last_name\", str),\n            (\"bio\", str),\n            (\"avatar\", str),\n        ]\n        excludes = [\"username\", \"email\", \"password\"]\n\n    def __str__(self):\n        return self.username\n\n\n# Update Article model to use custom User\nclass Article(ModelSerializer):\n    # ... existing fields ...\n    author = models.ForeignKey(\n        \"User\",  # Use string reference\n        on_delete=models.CASCADE,\n        related_name=\"articles\"\n    )\n    # ... rest of model ...\n</code></pre>"},{"location":"tutorial/authentication/#configure-django-to-use-custom-user","title":"Configure Django to Use Custom User","text":"Python<pre><code># settings.py\nAUTH_USER_MODEL = 'myapp.User'  # Replace 'myapp' with your app name\n</code></pre>"},{"location":"tutorial/authentication/#run-migrations","title":"Run Migrations","text":"Bash<pre><code>python manage.py makemigrations\npython manage.py migrate\n</code></pre>"},{"location":"tutorial/authentication/#create-authentication-class","title":"Create Authentication Class","text":"Python<pre><code># auth.py\nfrom ninja_aio.auth import AsyncJwtBearer\nfrom joserfc import jwk\nfrom django.conf import settings\nfrom .models import User\n\n\nclass JWTAuth(AsyncJwtBearer):\n    # Import public key for verification\n    jwt_public = jwk.RSAKey.import_key(settings.JWT_PUBLIC_KEY)\n    jwt_alg = \"RS256\"\n\n    # Validate required claims\n    claims = {\n        \"iss\": {\"essential\": True, \"value\": settings.JWT_ISSUER},\n        \"aud\": {\"essential\": True, \"value\": settings.JWT_AUDIENCE},\n        \"sub\": {\"essential\": True},  # User ID\n    }\n\n    async def auth_handler(self, request):\n        \"\"\"\n        Called after token validation.\n        Returns the user object that will be attached to request.auth\n        \"\"\"\n        # Get user ID from token\n        user_id = self.dcd.claims.get(\"sub\")\n\n        try:\n            # Fetch user from database\n            user = await User.objects.aget(id=user_id, is_active=True)\n            return user\n        except User.DoesNotExist:\n            return False\n</code></pre>"},{"location":"tutorial/authentication/#create-token-generation-helper","title":"Create Token Generation Helper","text":"Python<pre><code># utils.py\nfrom datetime import datetime, timedelta\nimport jwt\nfrom django.conf import settings\n\n\ndef create_access_token(user_id: int, **extra_claims) -&gt; str:\n    \"\"\"Generate JWT access token\"\"\"\n    now = datetime.utcnow()\n\n    payload = {\n        \"sub\": str(user_id),\n        \"iss\": settings.JWT_ISSUER,\n        \"aud\": settings.JWT_AUDIENCE,\n        \"iat\": now,\n        \"exp\": now + timedelta(seconds=settings.JWT_ACCESS_TOKEN_EXPIRE),\n        **extra_claims\n    }\n\n    token = jwt.encode(\n        payload,\n        settings.JWT_PRIVATE_KEY,\n        algorithm=\"RS256\"\n    )\n\n    return token\n\n\ndef create_refresh_token(user_id: int) -&gt; str:\n    \"\"\"Generate JWT refresh token\"\"\"\n    now = datetime.utcnow()\n\n    payload = {\n        \"sub\": str(user_id),\n        \"iss\": settings.JWT_ISSUER,\n        \"aud\": settings.JWT_AUDIENCE,\n        \"iat\": now,\n        \"exp\": now + timedelta(seconds=settings.JWT_REFRESH_TOKEN_EXPIRE),\n        \"type\": \"refresh\"\n    }\n\n    token = jwt.encode(\n        payload,\n        settings.JWT_PRIVATE_KEY,\n        algorithm=\"RS256\"\n    )\n\n    return token\n</code></pre>"},{"location":"tutorial/authentication/#create-loginregister-endpoints","title":"Create Login/Register Endpoints","text":"Python<pre><code># views.py\nfrom ninja_aio import NinjaAIO\nfrom ninja import Schema\nfrom ninja_aio.exceptions import SerializeError\nfrom django.contrib.auth.hashers import make_password, check_password\nfrom .models import User\nfrom .utils import create_access_token, create_refresh_token\nfrom .auth import JWTAuth\n\napi = NinjaAIO(title=\"Blog API\", version=\"1.0.0\")\n\n\n# Schemas for authentication\nclass RegisterSchema(Schema):\n    username: str\n    email: str\n    password: str\n    first_name: str = \"\"\n    last_name: str = \"\"\n\n\nclass LoginSchema(Schema):\n    username: str\n    password: str\n\n\nclass TokenResponse(Schema):\n    access_token: str\n    refresh_token: str\n    token_type: str = \"bearer\"\n    expires_in: int\n\n\nclass UserResponse(Schema):\n    id: int\n    username: str\n    email: str\n    first_name: str\n    last_name: str\n\n\n# Register endpoint\n@api.post(\"/auth/register/\", response=TokenResponse)\nasync def register(request, data: RegisterSchema):\n    \"\"\"Register a new user\"\"\"\n    # Check if username exists\n    if await User.objects.filter(username=data.username).aexists():\n        raise SerializeError(\n            {\"username\": \"Username already taken\"},\n            status_code=400\n        )\n\n    # Check if email exists\n    if await User.objects.filter(email=data.email).aexists():\n        raise SerializeError(\n            {\"email\": \"Email already registered\"},\n            status_code=400\n        )\n\n    # Create user\n    user = await User.objects.acreate(\n        username=data.username,\n        email=data.email,\n        password=make_password(data.password),\n        first_name=data.first_name,\n        last_name=data.last_name,\n    )\n\n    # Generate tokens\n    access_token = create_access_token(user.id)\n    refresh_token = create_refresh_token(user.id)\n\n    from django.conf import settings\n    return {\n        \"access_token\": access_token,\n        \"refresh_token\": refresh_token,\n        \"expires_in\": settings.JWT_ACCESS_TOKEN_EXPIRE\n    }\n\n\n# Login endpoint\n@api.post(\"/auth/login/\", response=TokenResponse)\nasync def login(request, data: LoginSchema):\n    \"\"\"Login user\"\"\"\n    try:\n        user = await User.objects.aget(username=data.username)\n    except User.DoesNotExist:\n        raise SerializeError(\n            {\"detail\": \"Invalid credentials\"},\n            status_code=401\n        )\n\n    # Check password\n    if not check_password(data.password, user.password):\n        raise SerializeError(\n            {\"detail\": \"Invalid credentials\"},\n            status_code=401\n        )\n\n    # Check if user is active\n    if not user.is_active:\n        raise SerializeError(\n            {\"detail\": \"Account is disabled\"},\n            status_code=401\n        )\n\n    # Generate tokens\n    access_token = create_access_token(user.id)\n    refresh_token = create_refresh_token(user.id)\n\n    from django.conf import settings\n    return {\n        \"access_token\": access_token,\n        \"refresh_token\": refresh_token,\n        \"expires_in\": settings.JWT_ACCESS_TOKEN_EXPIRE\n    }\n\n\n# Get current user\n@api.get(\"/auth/me/\", response=UserResponse, auth=JWTAuth())\nasync def me(request):\n    \"\"\"Get current authenticated user\"\"\"\n    user = request.auth\n    return {\n        \"id\": user.id,\n        \"username\": user.username,\n        \"email\": user.email,\n        \"first_name\": user.first_name,\n        \"last_name\": user.last_name,\n    }\n\n\n# Refresh token\n@api.post(\"/auth/refresh/\", response=TokenResponse)\nasync def refresh(request, refresh_token: str):\n    \"\"\"Refresh access token\"\"\"\n    import jwt\n    from django.conf import settings\n\n    try:\n        # Decode refresh token\n        payload = jwt.decode(\n            refresh_token,\n            settings.JWT_PUBLIC_KEY,\n            algorithms=[\"RS256\"],\n            audience=settings.JWT_AUDIENCE,\n            issuer=settings.JWT_ISSUER\n        )\n\n        # Check token type\n        if payload.get(\"type\") != \"refresh\":\n            raise SerializeError(\n                {\"detail\": \"Invalid token type\"},\n                status_code=401\n            )\n\n        user_id = int(payload.get(\"sub\"))\n\n        # Generate new tokens\n        new_access_token = create_access_token(user_id)\n        new_refresh_token = create_refresh_token(user_id)\n\n        return {\n            \"access_token\": new_access_token,\n            \"refresh_token\": new_refresh_token,\n            \"expires_in\": settings.JWT_ACCESS_TOKEN_EXPIRE\n        }\n\n    except jwt.ExpiredSignatureError:\n        raise SerializeError(\n            {\"detail\": \"Refresh token expired\"},\n            status_code=401\n        )\n    except jwt.InvalidTokenError:\n        raise SerializeError(\n            {\"detail\": \"Invalid refresh token\"},\n            status_code=401\n        )\n</code></pre>"},{"location":"tutorial/authentication/#protect-your-viewsets","title":"Protect Your ViewSets","text":"<p>Now let's add authentication to your CRUD endpoints:</p> Python<pre><code># views.py\nfrom ninja_aio.views import APIViewSet\nfrom .models import Article\nfrom .auth import JWTAuth\n\napi = NinjaAIO(title=\"Blog API\", version=\"1.0.0\")\n\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    # Public read, authenticated write\n    get_auth = None  # List and retrieve are public\n    post_auth = [JWTAuth()]  # Create requires auth\n    patch_auth = [JWTAuth()]  # Update requires auth\n    delete_auth = [JWTAuth()]  # Delete requires auth\n</code></pre>"},{"location":"tutorial/authentication/#set-author-automatically","title":"Set Author Automatically","text":"<p>Modify the Article model to set the author from the authenticated user:</p> Python<pre><code># models.py\nclass Article(ModelSerializer):\n    # ... existing fields ...\n\n    @classmethod\n    async def queryset_request(cls, request):\n        \"\"\"Filter articles based on authentication\"\"\"\n        qs = cls.objects.select_related('author', 'category').prefetch_related('tags')\n\n        # Show all published articles\n        # Plus user's own drafts if authenticated\n        if request.auth:\n            from django.db.models import Q\n            return qs.filter(\n                Q(is_published=True) | Q(author=request.auth)\n            )\n\n        return qs.filter(is_published=True)\n\n    async def custom_actions(self, payload: dict):\n        \"\"\"Set author from request\"\"\"\n        # This is called during creation\n        if hasattr(self, '_request') and self._request.auth:\n            self.author = self._request.auth\n            await self.asave(update_fields=['author'])\n\n        # Call parent\n        await super().custom_actions(payload)\n</code></pre>"},{"location":"tutorial/authentication/#role-based-access-control","title":"Role-Based Access Control","text":"<p>Create different authentication classes for different roles:</p> Python<pre><code># auth.py\nfrom ninja_aio.auth import AsyncJwtBearer\nfrom joserfc import jwk\nfrom django.conf import settings\nfrom .models import User\n\n\nclass JWTAuth(AsyncJwtBearer):\n    \"\"\"Base JWT authentication\"\"\"\n    jwt_public = jwk.RSAKey.import_key(settings.JWT_PUBLIC_KEY)\n    jwt_alg = \"RS256\"\n    claims = {\n        \"iss\": {\"essential\": True, \"value\": settings.JWT_ISSUER},\n        \"aud\": {\"essential\": True, \"value\": settings.JWT_AUDIENCE},\n        \"sub\": {\"essential\": True},\n    }\n\n    async def auth_handler(self, request):\n        user_id = self.dcd.claims.get(\"sub\")\n        try:\n            user = await User.objects.aget(id=user_id, is_active=True)\n            return user\n        except User.DoesNotExist:\n            return False\n\n\nclass AdminAuth(JWTAuth):\n    \"\"\"Requires admin/staff privileges\"\"\"\n\n    async def auth_handler(self, request):\n        user = await super().auth_handler(request)\n\n        if not user.is_staff:\n            return False\n\n        return user\n\n\nclass SuperuserAuth(JWTAuth):\n    \"\"\"Requires superuser privileges\"\"\"\n\n    async def auth_handler(self, request):\n        user = await super().auth_handler(request)\n\n        if not user.is_superuser:\n            return False\n\n        return user\n</code></pre>"},{"location":"tutorial/authentication/#apply-role-based-auth","title":"Apply Role-Based Auth","text":"Python<pre><code># views.py\nfrom .auth import JWTAuth, AdminAuth\n\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    # Public read\n    get_auth = None\n\n    # Regular users can create\n    post_auth = [JWTAuth()]\n\n    # Regular users can update (own articles)\n    patch_auth = [JWTAuth()]\n\n    # Only admins can delete\n    delete_auth = [AdminAuth()]\n\n\n@api.viewset(model=User)\nclass UserViewSet(APIViewSet):\n    # Only admins can manage users\n    auth = [AdminAuth()]\n</code></pre>"},{"location":"tutorial/authentication/#ownership-validation","title":"Ownership Validation","text":"<p>Ensure users can only edit their own articles:</p> Python<pre><code># views.py\nfrom ninja_aio.decorators import api_patch, api_delete\n\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    get_auth = None\n    post_auth = [JWTAuth()]\n    patch_auth = [JWTAuth()]\n    delete_auth = [JWTAuth()]\n\n    # Override update to check ownership\n    @api_patch(\"/{pk}/\")\n    async def update(self, request, pk: int, data: Article.generate_update_s()):\n        \"\"\"Update article (owner or admin only)\"\"\"\n        try:\n            article = await Article.objects.aget(pk=pk)\n        except Article.DoesNotExist:\n            raise SerializeError({\"article\": \"not found\"}, status_code=404)\n\n        # Check ownership (unless admin)\n        user = request.auth\n        if article.author_id != user.id and not user.is_staff:\n            raise SerializeError(\n                {\"detail\": \"You can only edit your own articles\"},\n                status_code=403\n            )\n\n        # Update article\n        from ninja_aio.models import ModelUtil\n        util = ModelUtil(Article)\n        schema = Article.generate_read_s()\n\n        return await util.update_s(request, article, data, schema)\n\n    # Override delete to check ownership\n    @api_delete(\"/{pk}/\")\n    async def delete(self, request, pk: int):\n        \"\"\"Delete article (owner or admin only)\"\"\"\n        try:\n            article = await Article.objects.aget(pk=pk)\n        except Article.DoesNotExist:\n            raise SerializeError({\"article\": \"not found\"}, status_code=404)\n\n        # Check ownership (unless admin)\n        user = request.auth\n        if article.author_id != user.id and not user.is_staff:\n            raise SerializeError(\n                {\"detail\": \"You can only delete your own articles\"},\n                status_code=403\n            )\n\n        await article.adelete()\n        return {\"message\": \"Article deleted successfully\"}\n</code></pre>"},{"location":"tutorial/authentication/#testing-authentication","title":"Testing Authentication","text":""},{"location":"tutorial/authentication/#register-a-user","title":"Register a User","text":"Bash<pre><code>curl -X POST http://localhost:8000/api/auth/register/ \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"username\": \"johndoe\",\n    \"email\": \"john@example.com\",\n    \"password\": \"secure_password_123\",\n    \"first_name\": \"John\",\n    \"last_name\": \"Doe\"\n  }'\n</code></pre> <p>Response:</p> JSON<pre><code>{\n  \"access_token\": \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...\",\n  \"refresh_token\": \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...\",\n  \"token_type\": \"bearer\",\n  \"expires_in\": 900\n}\n</code></pre>"},{"location":"tutorial/authentication/#login","title":"Login","text":"Bash<pre><code>curl -X POST http://localhost:8000/api/auth/login/ \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"username\": \"johndoe\",\n    \"password\": \"secure_password_123\"\n  }'\n</code></pre>"},{"location":"tutorial/authentication/#get-current-user","title":"Get Current User","text":"Bash<pre><code>curl http://localhost:8000/api/auth/me/ \\\n  -H \"Authorization: Bearer YOUR_ACCESS_TOKEN\"\n</code></pre>"},{"location":"tutorial/authentication/#create-article-authenticated","title":"Create Article (Authenticated)","text":"Bash<pre><code>curl -X POST http://localhost:8000/api/article/ \\\n  -H \"Authorization: Bearer YOUR_ACCESS_TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"title\": \"My Article\",\n    \"content\": \"Article content...\",\n    \"category\": 1\n  }'\n</code></pre>"},{"location":"tutorial/authentication/#refresh-token","title":"Refresh Token","text":"Bash<pre><code>curl -X POST http://localhost:8000/api/auth/refresh/ \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"refresh_token\": \"YOUR_REFRESH_TOKEN\"}'\n</code></pre>"},{"location":"tutorial/authentication/#error-responses","title":"Error Responses","text":""},{"location":"tutorial/authentication/#missing-token","title":"Missing Token","text":"Bash<pre><code>curl http://localhost:8000/api/article/ \\\n  -X POST \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"title\": \"Test\"}'\n</code></pre> <p>Response (401):</p> JSON<pre><code>{\n  \"detail\": \"Unauthorized\"\n}\n</code></pre>"},{"location":"tutorial/authentication/#invalid-token","title":"Invalid Token","text":"Bash<pre><code>curl http://localhost:8000/api/article/ \\\n  -H \"Authorization: Bearer invalid_token\" \\\n  -X POST\n</code></pre> <p>Response (401):</p> JSON<pre><code>{\n  \"detail\": \"Invalid token\"\n}\n</code></pre>"},{"location":"tutorial/authentication/#expired-token","title":"Expired Token","text":"<p>Response (401):</p> JSON<pre><code>{\n  \"detail\": \"Token has expired\"\n}\n</code></pre>"},{"location":"tutorial/authentication/#insufficient-permissions","title":"Insufficient Permissions","text":"Bash<pre><code># Regular user trying to delete\ncurl -X DELETE http://localhost:8000/api/article/1/ \\\n  -H \"Authorization: Bearer USER_TOKEN\"\n</code></pre> <p>Response (403):</p> JSON<pre><code>{\n  \"detail\": \"Admin privileges required\"\n}\n</code></pre>"},{"location":"tutorial/authentication/#using-swagger-ui-with-auth","title":"Using Swagger UI with Auth","text":"<p>The Swagger UI at <code>/api/docs</code> has built-in authentication support:</p> <ol> <li>Click the \"Authorize\" button at the top</li> <li>Enter your token: <code>Bearer YOUR_ACCESS_TOKEN</code></li> <li>Click \"Authorize\"</li> <li>Now all requests will include the token</li> </ol>"},{"location":"tutorial/authentication/#custom-claims","title":"Custom Claims","text":"<p>Add custom claims to your tokens:</p> Python<pre><code># utils.py\ndef create_access_token(user_id: int, **extra_claims) -&gt; str:\n    \"\"\"Generate JWT access token with custom claims\"\"\"\n    now = datetime.utcnow()\n\n    # Add custom claims\n    payload = {\n        \"sub\": str(user_id),\n        \"iss\": settings.JWT_ISSUER,\n        \"aud\": settings.JWT_AUDIENCE,\n        \"iat\": now,\n        \"exp\": now + timedelta(seconds=settings.JWT_ACCESS_TOKEN_EXPIRE),\n        **extra_claims\n    }\n\n    return jwt.encode(payload, settings.JWT_PRIVATE_KEY, algorithm=\"RS256\")\n\n\n# In login endpoint\nasync def login(request, data: LoginSchema):\n    # ... authentication logic ...\n\n    # Create token with custom claims\n    access_token = create_access_token(\n        user.id,\n        email=user.email,\n        username=user.username,\n        is_staff=user.is_staff,\n        permissions=[\"read:articles\", \"write:articles\"]\n    )\n\n    # ...\n</code></pre> <p>Access custom claims in your auth handler:</p> Python<pre><code>class JWTAuth(AsyncJwtBearer):\n    # ...\n\n    async def auth_handler(self, request):\n        user_id = self.dcd.claims.get(\"sub\")\n        user = await User.objects.aget(id=user_id, is_active=True)\n\n        # Attach custom claims to request\n        request.user_permissions = self.dcd.claims.get(\"permissions\", [])\n        request.user_email = self.dcd.claims.get(\"email\")\n\n        return user\n</code></pre>"},{"location":"tutorial/authentication/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Use RSA keys in production: Python<pre><code>jwt_public = jwk.RSAKey.import_key(settings.JWT_PUBLIC_KEY)\njwt_alg = \"RS256\"\n</code></pre></p> </li> <li> <p>Keep access tokens short-lived: Python<pre><code>JWT_ACCESS_TOKEN_EXPIRE = 60 * 15  # 15 minutes\n</code></pre></p> </li> <li> <p>Use refresh tokens: Python<pre><code>JWT_REFRESH_TOKEN_EXPIRE = 60 * 60 * 24 * 7  # 7 days\n</code></pre></p> </li> <li> <p>Validate claims: Python<pre><code>claims = {\n    \"iss\": {\"essential\": True, \"value\": \"your-issuer\"},\n    \"aud\": {\"essential\": True, \"value\": \"your-api\"},\n}\n</code></pre></p> </li> <li> <p>Hash passwords properly: Python<pre><code>from django.contrib.auth.hashers import make_password\npassword = make_password(raw_password)\n</code></pre></p> </li> <li> <p>Check user ownership: Python<pre><code>if article.author_id != user.id and not user.is_staff:\n    raise SerializeError({\"detail\": \"Forbidden\"}, status_code=403)\n</code></pre></p> </li> <li> <p>Use HTTPS in production - Never send tokens over HTTP</p> </li> <li> <p>Implement token blacklist for logout functionality</p> </li> </ol> <p>Ready for the next step?</p> <p>Now that you have authentication set up, let's add filtering and pagination!</p> <p>Step 4: Filtering &amp; Pagination </p> <ul> <li> <p> API Reference</p> <p> Authentication \u00b7  APIViewSet Auth Options</p> </li> </ul>"},{"location":"tutorial/authentication/#what-youve-learned","title":"What You've Learned","text":"<ul> <li> Setting up JWT authentication</li> <li> Creating login/register endpoints</li> <li> Protecting API endpoints</li> <li> Implementing role-based access control</li> <li> Validating ownership</li> <li> Testing authenticated requests</li> </ul>"},{"location":"tutorial/crud/","title":"Step 2: Create CRUD Views","text":"<p>Step 2 of 4</p> <p>Prerequisites \u2014 Make sure you've completed Step 1: Define Your Model. You should have the <code>Article</code>, <code>Author</code>, <code>Category</code>, and <code>Tag</code> models defined.</p>"},{"location":"tutorial/crud/#create-crud-views","title":"Create CRUD Views","text":"<p> Build a complete REST API with automatic CRUD operations using <code>APIViewSet</code>. </p>"},{"location":"tutorial/crud/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li> How to create a basic ViewSet</li> <li> Understanding auto-generated endpoints</li> <li> Customizing query parameters</li> <li> Adding custom endpoints</li> <li> Working with request context</li> <li> Handling errors</li> </ul>"},{"location":"tutorial/crud/#basic-viewset","title":"Basic ViewSet","text":"<p>Let's create a simple API for the Article model:</p> Python<pre><code># views.py\nfrom ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom .models import Article\n\n# Create API instance\napi = NinjaAIO(\n    title=\"Blog API\",\n    version=\"1.0.0\",\n    description=\"A simple blog API built with Django Ninja Aio CRUD\"\n)\n\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    pass\n</code></pre> <p>That's it! You now have a complete CRUD API with 5 endpoints.</p>"},{"location":"tutorial/crud/#configure-urls","title":"Configure URLs","text":"<p>Add the API to your Django URLs:</p> Python<pre><code># urls.py\nfrom django.contrib import admin\nfrom django.urls import path\nfrom myapp.views import api\n\nurlpatterns = [\n    path(\"admin/\", admin.site.urls),\n    path(\"api/\", api.urls),\n]\n</code></pre>"},{"location":"tutorial/crud/#auto-generated-endpoints","title":"Auto-Generated Endpoints","text":"<p>The ViewSet automatically generates these endpoints:</p> Method Endpoint Description Request Body Response <code>GET</code> <code>/api/article/</code> List all articles (paginated) None <code>{count, next, previous, results}</code> <code>POST</code> <code>/api/article/</code> Create new article Article data Created article <code>GET</code> <code>/api/article/{id}</code> Retrieve single article None Article data <code>PATCH</code> <code>/api/article/{id}/</code> Update article Partial article data Updated article <code>DELETE</code> <code>/api/article/{id}/</code> Delete article None None (204)"},{"location":"tutorial/crud/#test-your-api","title":"Test Your API","text":"<p>Start the development server:</p> Bash<pre><code>python manage.py runserver\n</code></pre> <p>Visit http://localhost:8000/api/docs to see the auto-generated Swagger UI documentation.</p>"},{"location":"tutorial/crud/#creating-multiple-viewsets","title":"Creating Multiple ViewSets","text":"<p>Let's add APIs for all our models:</p> Python<pre><code># views.py\nfrom ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom .models import Article, Author, Category, Tag\n\napi = NinjaAIO(title=\"Blog API\", version=\"1.0.0\")\n\n\n@api.viewset(model=Author)\nclass AuthorViewSet(APIViewSet):\n    pass\n\n\n@api.viewset(model=Category)\nclass CategoryViewSet(APIViewSet):\n    pass\n\n\n@api.viewset(model=Tag)\nclass TagViewSet(APIViewSet):\n    pass\n\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    pass\n</code></pre> <p>Now you have complete CRUD APIs for all models:</p> <ul> <li><code>/api/author/</code></li> <li><code>/api/category/</code></li> <li><code>/api/tag/</code></li> <li><code>/api/article/</code></li> </ul>"},{"location":"tutorial/crud/#adding-query-parameters","title":"Adding Query Parameters","text":"<p>Let's add filtering to the Article list endpoint:</p> Python<pre><code>@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    query_params = {\n        \"is_published\": (bool, None),\n        \"author\": (int, None),\n        \"category\": (int, None),\n        \"search\": (str, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        # Filter by published status\n        if filters.get(\"is_published\") is not None:\n            queryset = queryset.filter(is_published=filters[\"is_published\"])\n\n        # Filter by author\n        if filters.get(\"author\"):\n            queryset = queryset.filter(author_id=filters[\"author\"])\n\n        # Filter by category\n        if filters.get(\"category\"):\n            queryset = queryset.filter(category_id=filters[\"category\"])\n\n        # Search in title and content\n        if filters.get(\"search\"):\n            from django.db.models import Q\n            search_term = filters[\"search\"]\n            queryset = queryset.filter(\n                Q(title__icontains=search_term) |\n                Q(content__icontains=search_term)\n            )\n\n        return queryset\n</code></pre>"},{"location":"tutorial/crud/#using-query-parameters","title":"Using Query Parameters","text":"<p>Now you can filter articles:</p> Bash<pre><code># Get published articles\nGET /api/article/?is_published=true\n\n# Get articles by specific author\nGET /api/article/?author=5\n\n# Get articles in specific category\nGET /api/article/?category=3\n\n# Search articles\nGET /api/article/?search=django\n\n# Combine filters\nGET /api/article/?is_published=true&amp;author=5&amp;category=3\n\n# With pagination\nGET /api/article/?is_published=true&amp;page=2&amp;page_size=20\n</code></pre>"},{"location":"tutorial/crud/#custom-endpoints","title":"Custom Endpoints","text":"<p>Add custom endpoints beyond CRUD:</p> Python<pre><code>from ninja_aio.decorators import api_get, api_post\n\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    # Publish an article\n    @api_post(\"/{pk}/publish/\")\n    async def publish(self, request, pk: int):\n        article = await Article.objects.aget(pk=pk)\n        article.is_published = True\n        from django.utils import timezone\n        article.published_at = timezone.now()\n        await article.asave()\n\n        return {\n            \"message\": \"Article published successfully\",\n            \"published_at\": article.published_at\n        }\n\n    # Unpublish an article\n    @api_post(\"/{pk}/unpublish/\")\n    async def unpublish(self, request, pk: int):\n        article = await Article.objects.aget(pk=pk)\n        article.is_published = False\n        article.published_at = None\n        await article.asave()\n\n        return {\"message\": \"Article unpublished successfully\"}\n\n    # Increment view count\n    @api_post(\"/{pk}/view/\")\n    async def increment_views(self, request, pk: int):\n        article = await Article.objects.aget(pk=pk)\n        article.views += 1\n        await article.asave(update_fields=[\"views\"])\n\n        return {\"views\": article.views}\n\n    # Get article statistics\n    @api_get(\"/stats/\")\n    async def stats(self, request):\n        from django.db.models import Count, Avg, Sum\n\n        total = await Article.objects.acount()\n        published = await Article.objects.filter(is_published=True).acount()\n\n        # Use sync_to_async for aggregate\n        from asgiref.sync import sync_to_async\n\n        avg_views = await sync_to_async(\n            lambda: Article.objects.aggregate(avg=Avg(\"views\"))\n        )()\n\n        total_views = await sync_to_async(\n            lambda: Article.objects.aggregate(total=Sum(\"views\"))\n        )()\n\n        return {\n            \"total_articles\": total,\n            \"published_articles\": published,\n            \"draft_articles\": total - published,\n            \"average_views\": avg_views[\"avg\"] or 0,\n            \"total_views\": total_views[\"total\"] or 0,\n        }\n\n    # Get popular articles\n    @api_get(\"/popular/\")\n    async def popular(self, request, limit: int = 10):\n        articles = []\n        async for article in Article.objects.filter(\n            is_published=True\n        ).order_by(\"-views\")[:limit]:\n            articles.append(article)\n\n        # Serialize articles\n        from ninja_aio.models import ModelUtil\n        util = ModelUtil(Article)\n        schema = Article.generate_read_s()\n\n        results = []\n        for article in articles:\n            data = await util.read_s(request, article, schema)\n            results.append(data)\n\n        return results\n</code></pre>"},{"location":"tutorial/crud/#custom-endpoint-urls","title":"Custom Endpoint URLs","text":"<p>Your custom endpoints are now available:</p> Bash<pre><code># Publish article\nPOST /api/article/1/publish/\n\n# Unpublish article\nPOST /api/article/1/unpublish/\n\n# Increment views\nPOST /api/article/1/view/\n\n# Get statistics\nGET /api/article/stats/\n\n# Get popular articles (top 10)\nGET /api/article/popular/\n\n# Get top 20\nGET /api/article/popular/?limit=20\n</code></pre>"},{"location":"tutorial/crud/#request-context","title":"Request Context","text":"<p>Access request information in your ViewSet:</p> Python<pre><code>from ninja_aio.decorators import api_get, api_post\n\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    @api_get(\"/my-articles/\")\n    async def my_articles(self, request):\n        \"\"\"Get articles by current user\"\"\"\n        # Access authenticated user\n        user = request.auth\n\n        # Get user's articles\n        articles = []\n        async for article in Article.objects.filter(author=user):\n            articles.append(article)\n\n        # Serialize\n        from ninja_aio.models import ModelUtil\n        util = ModelUtil(Article)\n        schema = Article.generate_read_s()\n\n        results = []\n        for article in articles:\n            data = await util.read_s(request, article, schema)\n            results.append(data)\n\n        return results\n\n    @api_post(\"/\")\n    async def create_article(self, request, data: Article.generate_create_s()):\n        \"\"\"Override create to set author from request\"\"\"\n        # Set author from authenticated user\n        data.author = request.auth.id\n\n        # Use default create logic\n        from ninja_aio.models import ModelUtil\n        util = ModelUtil(Article)\n        schema = Article.generate_read_s()\n\n        return await util.create_s(request, data, schema)\n</code></pre>"},{"location":"tutorial/crud/#filtering-by-user","title":"Filtering by User","text":"<p>Automatically filter queryset based on user:</p> Python<pre><code>class Article(ModelSerializer):\n    # ... fields ...\n\n    @classmethod\n    async def queryset_request(cls, request):\n        \"\"\"Filter articles based on user\"\"\"\n        qs = cls.objects.select_related('author', 'category').prefetch_related('tags')\n\n        # If user is not authenticated, show only published\n        if not request.auth:\n            return qs.filter(is_published=True)\n\n        # If user is admin, show all\n        user = request.auth\n        if user.is_staff:\n            return qs\n\n        # Regular users see published + their own drafts\n        from django.db.models import Q\n        return qs.filter(\n            Q(is_published=True) | Q(author=user)\n        )\n\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    pass\n    # queryset_request is automatically called for all operations\n</code></pre>"},{"location":"tutorial/crud/#custom-pagination","title":"Custom Pagination","text":"<p>Override default pagination:</p> Python<pre><code>from ninja.pagination import PageNumberPagination\n\n\nclass LargePagePagination(PageNumberPagination):\n    page_size = 50  # Default 50 items per page\n    max_page_size = 200  # Allow up to 200 items\n\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    pagination_class = LargePagePagination\n</code></pre> <p>Now list endpoint uses custom pagination:</p> Bash<pre><code># Default 50 items\nGET /api/article/\n\n# Custom page size\nGET /api/article/?page_size=100\n\n# Page 2\nGET /api/article/?page=2&amp;page_size=50\n</code></pre>"},{"location":"tutorial/crud/#ordering","title":"Ordering","text":"<p>Add ordering to list endpoint:</p> Python<pre><code>@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    query_params = {\n        \"is_published\": (bool, None),\n        \"ordering\": (str, \"-created_at\"),  # Default: newest first\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        # Apply published filter\n        if filters.get(\"is_published\") is not None:\n            queryset = queryset.filter(is_published=filters[\"is_published\"])\n\n        # Apply ordering\n        ordering = filters.get(\"ordering\", \"-created_at\")\n\n        # Validate ordering field\n        valid_fields = [\n            \"created_at\", \"-created_at\",\n            \"title\", \"-title\",\n            \"views\", \"-views\",\n            \"published_at\", \"-published_at\"\n        ]\n\n        if ordering in valid_fields:\n            queryset = queryset.order_by(ordering)\n\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># Newest first (default)\nGET /api/article/\n\n# Oldest first\nGET /api/article/?ordering=created_at\n\n# By title A-Z\nGET /api/article/?ordering=title\n\n# By title Z-A\nGET /api/article/?ordering=-title\n\n# Most viewed\nGET /api/article/?ordering=-views\n\n# Recently published\nGET /api/article/?ordering=-published_at\n</code></pre>"},{"location":"tutorial/crud/#error-handling","title":"Error Handling","text":"<p>Handle errors gracefully:</p> Python<pre><code>from ninja_aio.exceptions import SerializeError, NotFoundError\nfrom ninja_aio.decorators import api_post\n\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    @api_post(\"/{pk}/publish/\")\n    async def publish(self, request, pk: int):\n        try:\n            article = await Article.objects.aget(pk=pk)\n        except Article.DoesNotExist:\n            raise NotFoundError(self.model)\n\n        # Check if already published\n        if article.is_published:\n            raise SerializeError(\n                {\"article\": \"already published\"},\n                status_code=400\n            )\n\n        # Publish\n        article.is_published = True\n        from django.utils import timezone\n        article.published_at = timezone.now()\n        await article.asave()\n\n        return {\n            \"message\": \"Article published successfully\",\n            \"published_at\": article.published_at\n        }\n</code></pre>"},{"location":"tutorial/crud/#disabling-endpoints","title":"Disabling Endpoints","text":"<p>Disable specific CRUD operations:</p> Python<pre><code>@api.viewset(model=Category)\nclass CategoryViewSet(APIViewSet):\n    # Disable delete (categories can't be deleted)\n    disable_delete = True\n\n    # Disable update (categories are immutable)\n    disable_update = True\n</code></pre> <p>Now only these endpoints are available:</p> <ul> <li><code>GET /api/category/</code> - List</li> <li><code>POST /api/category/</code> - Create</li> <li><code>GET /api/category/{id}</code> - Retrieve</li> </ul>"},{"location":"tutorial/crud/#response-customization","title":"Response Customization","text":"<p>Customize response format:</p> Python<pre><code>from ninja_aio.decorators import api_get\n\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    @api_get(\"/{pk}/\")\n    async def retrieve(self, request, pk: int):\n        \"\"\"Custom retrieve with additional data\"\"\"\n        article = await Article.objects.select_related(\n            'author', 'category'\n        ).prefetch_related('tags').aget(pk=pk)\n\n        # Serialize article\n        from ninja_aio.models import ModelUtil\n        util = ModelUtil(Article)\n        schema = Article.generate_read_s()\n        article_data = await util.read_s(request, article, schema)\n\n        # Get related articles\n        related = []\n        async for rel_article in Article.objects.filter(\n            category=article.category,\n            is_published=True\n        ).exclude(pk=pk)[:5]:\n            rel_data = await util.read_s(request, rel_article, schema)\n            related.append(rel_data)\n\n        # Get author's other articles\n        author_articles = []\n        async for auth_article in Article.objects.filter(\n            author=article.author,\n            is_published=True\n        ).exclude(pk=pk)[:5]:\n            auth_data = await util.read_s(request, auth_article, schema)\n            author_articles.append(auth_data)\n\n        return {\n            \"article\": article_data,\n            \"related_articles\": related,\n            \"author_articles\": author_articles,\n            \"meta\": {\n                \"total_views\": article.views,\n                \"author_article_count\": await Article.objects.filter(\n                    author=article.author\n                ).acount()\n            }\n        }\n</code></pre>"},{"location":"tutorial/crud/#complete-example","title":"Complete Example","text":"<p>Here's a complete ViewSet with all features:</p> Full ViewSet code (click to expand) Python<pre><code># views.py\nfrom ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom ninja.pagination import PageNumberPagination\nfrom ninja_aio.exceptions import SerializeError, NotFoundError\nfrom ninja_aio.decorators import api_get, api_post\nfrom .models import Article, Author, Category, Tag\nfrom django.db.models import Q\n\napi = NinjaAIO(\n    title=\"Blog API\",\n    version=\"1.0.0\",\n    description=\"A complete blog API\"\n)\n\n\nclass CustomPagination(PageNumberPagination):\n    page_size = 20\n    max_page_size = 100\n\n\n@api.viewset(model=Author)\nclass AuthorViewSet(APIViewSet):\n    pass\n\n\n@api.viewset(model=Category)\nclass CategoryViewSet(APIViewSet):\n    pass\n\n\n@api.viewset(model=Tag)\nclass TagViewSet(APIViewSet):\n    pass\n\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    pagination_class = CustomPagination\n\n    query_params = {\n        \"is_published\": (bool, None),\n        \"author\": (int, None),\n        \"category\": (int, None),\n        \"tag\": (int, None),\n        \"search\": (str, None),\n        \"ordering\": (str, \"-created_at\"),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        # Published filter\n        if filters.get(\"is_published\") is not None:\n            queryset = queryset.filter(is_published=filters[\"is_published\"])\n\n        # Author filter\n        if filters.get(\"author\"):\n            queryset = queryset.filter(author_id=filters[\"author\"])\n\n        # Category filter\n        if filters.get(\"category\"):\n            queryset = queryset.filter(category_id=filters[\"category\"])\n\n        # Tag filter\n        if filters.get(\"tag\"):\n            queryset = queryset.filter(tags__id=filters[\"tag\"])\n\n        # Search\n        if filters.get(\"search\"):\n            search = filters[\"search\"]\n            queryset = queryset.filter(\n                Q(title__icontains=search) |\n                Q(content__icontains=search) |\n                Q(excerpt__icontains=search)\n            )\n\n        # Ordering\n        ordering = filters.get(\"ordering\", \"-created_at\")\n        valid_orderings = [\n            \"created_at\", \"-created_at\",\n            \"title\", \"-title\",\n            \"views\", \"-views\",\n            \"published_at\", \"-published_at\"\n        ]\n        if ordering in valid_orderings:\n            queryset = queryset.order_by(ordering)\n\n        return queryset\n\n    # Publish article\n    @api_post(\"/{pk}/publish/\")\n    async def publish(self, request, pk: int):\n        try:\n            article = await Article.objects.aget(pk=pk)\n        except Article.DoesNotExist:\n            raise NotFoundError(self.model)\n\n        if article.is_published:\n            raise SerializeError(\n                {\"article\": \"already published\"},\n                status_code=400\n            )\n\n        article.is_published = True\n        from django.utils import timezone\n        article.published_at = timezone.now()\n        await article.asave()\n\n        return {\"message\": \"Article published\", \"published_at\": article.published_at}\n\n    # Unpublish article\n    @api_post(\"/{pk}/unpublish/\")\n    async def unpublish(self, request, pk: int):\n        try:\n            article = await Article.objects.aget(pk=pk)\n        except Article.DoesNotExist:\n            raise NotFoundError(self.model)\n\n        article.is_published = False\n        article.published_at = None\n        await article.asave()\n\n        return {\"message\": \"Article unpublished\"}\n\n    # Increment views\n    @api_post(\"/{pk}/view/\")\n    async def view(self, request, pk: int):\n        try:\n            article = await Article.objects.aget(pk=pk)\n        except Article.DoesNotExist:\n            raise NotFoundError(self.model)\n\n        article.views += 1\n        await article.asave(update_fields=[\"views\"])\n\n        return {\"views\": article.views}\n\n    # Statistics\n    @api_get(\"/stats/\")\n    async def stats(self, request):\n        from django.db.models import Count, Avg, Sum\n        from asgiref.sync import sync_to_async\n\n        total = await Article.objects.acount()\n        published = await Article.objects.filter(is_published=True).acount()\n\n        avg_views = await sync_to_async(\n            lambda: Article.objects.aggregate(avg=Avg(\"views\"))\n        )()\n\n        total_views = await sync_to_async(\n            lambda: Article.objects.aggregate(total=Sum(\"views\"))\n        )()\n\n        return {\n            \"total_articles\": total,\n            \"published\": published,\n            \"drafts\": total - published,\n            \"avg_views\": avg_views[\"avg\"] or 0,\n            \"total_views\": total_views[\"total\"] or 0,\n        }\n\n    # Popular articles\n    @api_get(\"/popular/\")\n    async def popular(self, request, limit: int = 10):\n        articles = []\n        async for article in Article.objects.filter(\n            is_published=True\n        ).order_by(\"-views\")[:limit]:\n            articles.append(article)\n\n        from ninja_aio.models import ModelUtil\n        util = ModelUtil(Article)\n        schema = Article.generate_read_s()\n\n        results = []\n        for article in articles:\n            data = await util.read_s(request, article, schema)\n            results.append(data)\n\n        return results\n</code></pre>"},{"location":"tutorial/crud/#testing-your-api","title":"Testing Your API","text":"<p>Test your endpoints using curl, httpie, or the Swagger UI:</p> Bash<pre><code># List articles\ncurl http://localhost:8000/api/article/\n\n# Create article\ncurl -X POST http://localhost:8000/api/article/ \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"title\": \"My Article\",\n    \"content\": \"Content here...\",\n    \"author\": 1,\n    \"category\": 2\n  }'\n\n# Get article\ncurl http://localhost:8000/api/article/1\n\n# Update article\ncurl -X PATCH http://localhost:8000/api/article/1/ \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"title\": \"Updated Title\"}'\n\n# Delete article\ncurl -X DELETE http://localhost:8000/api/article/1/\n\n# Custom endpoints\ncurl -X POST http://localhost:8000/api/article/1/publish/\ncurl http://localhost:8000/api/article/stats/\ncurl http://localhost:8000/api/article/popular/?limit=5\n</code></pre> <p>Ready for the next step?</p> <p>Now that you have CRUD operations set up, let's add authentication!</p> <p>Step 3: Add Authentication </p> <ul> <li> <p> API Reference</p> <p> APIViewSet \u00b7  Pagination \u00b7  ModelUtil</p> </li> </ul>"},{"location":"tutorial/crud/#what-youve-learned","title":"What You've Learned","text":"<ul> <li> Creating ViewSets for CRUD operations</li> <li> Understanding auto-generated endpoints</li> <li> Adding query parameters and filtering</li> <li> Creating custom endpoints</li> <li> Working with pagination</li> <li> Handling errors properly</li> <li> Customizing responses</li> </ul>"},{"location":"tutorial/filtering/","title":"Step 4: Add Filtering & Pagination","text":"<p>Step 4 of 4</p> <p>Prerequisites \u2014 Make sure you've completed Step 1: Define Your Model, Step 2: Create CRUD Views, and Step 3: Add Authentication.</p>"},{"location":"tutorial/filtering/#add-filtering-pagination","title":"Add Filtering &amp; Pagination","text":"<p> Implement advanced filtering, searching, and pagination for your API endpoints. </p>"},{"location":"tutorial/filtering/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li> Query parameter filtering</li> <li> Full-text search</li> <li> Ordering and sorting</li> <li> Custom pagination</li> <li> Filter combinations</li> <li> Performance optimization</li> </ul>"},{"location":"tutorial/filtering/#basic-filtering","title":"Basic Filtering","text":""},{"location":"tutorial/filtering/#simple-field-filters","title":"Simple Field Filters","text":"Python<pre><code># views.py\nfrom ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom .models import Article\n\napi = NinjaAIO()\n\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    query_params = {\n        \"is_published\": (bool, None),\n        \"author\": (int, None),\n        \"category\": (int, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        # Filter by published status\n        if filters.get(\"is_published\") is not None:\n            queryset = queryset.filter(is_published=filters[\"is_published\"])\n\n        # Filter by author ID\n        if filters.get(\"author\"):\n            queryset = queryset.filter(author_id=filters[\"author\"])\n\n        # Filter by category ID\n        if filters.get(\"category\"):\n            queryset = queryset.filter(category_id=filters[\"category\"])\n\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># Get published articles\nGET /api/article/?is_published=true\n\n# Get articles by author\nGET /api/article/?author=5\n\n# Get articles in category\nGET /api/article/?category=3\n\n# Combine filters\nGET /api/article/?is_published=true&amp;author=5&amp;category=3\n</code></pre>"},{"location":"tutorial/filtering/#date-range-filters","title":"Date Range Filters","text":"Python<pre><code>from datetime import datetime\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"created_after\": (str, None),   # ISO date string\n        \"created_before\": (str, None),\n        \"published_after\": (str, None),\n        \"published_before\": (str, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        # Filter by creation date\n        if filters.get(\"created_after\"):\n            date = datetime.fromisoformat(filters[\"created_after\"])\n            queryset = queryset.filter(created_at__gte=date)\n\n        if filters.get(\"created_before\"):\n            date = datetime.fromisoformat(filters[\"created_before\"])\n            queryset = queryset.filter(created_at__lte=date)\n\n        # Filter by publication date\n        if filters.get(\"published_after\"):\n            date = datetime.fromisoformat(filters[\"published_after\"])\n            queryset = queryset.filter(published_at__gte=date)\n\n        if filters.get(\"published_before\"):\n            date = datetime.fromisoformat(filters[\"published_before\"])\n            queryset = queryset.filter(published_at__lte=date)\n\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># Articles created after a date\nGET /api/article/?created_after=2024-01-01\n\n# Articles published in a date range\nGET /api/article/?published_after=2024-01-01&amp;published_before=2024-01-31\n\n# Articles from last 7 days\nGET /api/article/?created_after=2024-01-15\n</code></pre>"},{"location":"tutorial/filtering/#numeric-range-filters","title":"Numeric Range Filters","text":"Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"min_views\": (int, None),\n        \"max_views\": (int, None),\n        \"min_rating\": (float, None),\n        \"max_rating\": (float, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        # Filter by views\n        if filters.get(\"min_views\"):\n            queryset = queryset.filter(views__gte=filters[\"min_views\"])\n\n        if filters.get(\"max_views\"):\n            queryset = queryset.filter(views__lte=filters[\"max_views\"])\n\n        # Filter by rating\n        if filters.get(\"min_rating\"):\n            queryset = queryset.filter(rating__gte=filters[\"min_rating\"])\n\n        if filters.get(\"max_rating\"):\n            queryset = queryset.filter(rating__lte=filters[\"max_rating\"])\n\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># Popular articles (1000+ views)\nGET /api/article/?min_views=1000\n\n# Highly rated articles (4.5+)\nGET /api/article/?min_rating=4.5\n\n# Articles with 100-1000 views\nGET /api/article/?min_views=100&amp;max_views=1000\n</code></pre>"},{"location":"tutorial/filtering/#search-functionality","title":"Search Functionality","text":""},{"location":"tutorial/filtering/#simple-text-search","title":"Simple Text Search","text":"Python<pre><code>from django.db.models import Q\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"search\": (str, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        if filters.get(\"search\"):\n            search_term = filters[\"search\"]\n            queryset = queryset.filter(\n                Q(title__icontains=search_term) |\n                Q(content__icontains=search_term) |\n                Q(excerpt__icontains=search_term)\n            )\n\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># Search in title and content\nGET /api/article/?search=django\n\n# Search with other filters\nGET /api/article/?search=tutorial&amp;is_published=true\n</code></pre>"},{"location":"tutorial/filtering/#full-text-search-postgresql","title":"Full-Text Search (PostgreSQL)","text":"<p>For better performance with large datasets:</p> Python<pre><code>from django.contrib.postgres.search import SearchVector, SearchQuery, SearchRank\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"search\": (str, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        if filters.get(\"search\"):\n            search_term = filters[\"search\"]\n\n            # Create search vector\n            vector = SearchVector('title', weight='A') + \\\n                     SearchVector('content', weight='B')\n\n            query = SearchQuery(search_term)\n\n            # Filter and rank by relevance\n            queryset = queryset.annotate(\n                rank=SearchRank(vector, query)\n            ).filter(\n                rank__gte=0.1\n            ).order_by('-rank')\n\n        return queryset\n</code></pre>"},{"location":"tutorial/filtering/#search-with-highlights","title":"Search with Highlights","text":"Python<pre><code>from django.contrib.postgres.search import SearchVector, SearchQuery, SearchHeadline\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"search\": (str, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        if filters.get(\"search\"):\n            search_term = filters[\"search\"]\n            query = SearchQuery(search_term)\n\n            # Add highlighted excerpts\n            queryset = queryset.annotate(\n                headline=SearchHeadline(\n                    'content',\n                    query,\n                    start_sel='&lt;mark&gt;',\n                    stop_sel='&lt;/mark&gt;',\n                    max_words=50,\n                )\n            )\n\n        return queryset\n</code></pre>"},{"location":"tutorial/filtering/#ordering","title":"Ordering","text":""},{"location":"tutorial/filtering/#basic-ordering","title":"Basic Ordering","text":"Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"ordering\": (str, \"-created_at\"),  # Default: newest first\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        ordering = filters.get(\"ordering\", \"-created_at\")\n\n        # Whitelist allowed ordering fields\n        valid_orderings = [\n            \"created_at\", \"-created_at\",\n            \"updated_at\", \"-updated_at\",\n            \"title\", \"-title\",\n            \"views\", \"-views\",\n            \"rating\", \"-rating\",\n            \"published_at\", \"-published_at\",\n        ]\n\n        if ordering in valid_orderings:\n            queryset = queryset.order_by(ordering)\n\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># Newest first (default)\nGET /api/article/?ordering=-created_at\n\n# Oldest first\nGET /api/article/?ordering=created_at\n\n# By title A-Z\nGET /api/article/?ordering=title\n\n# Most viewed\nGET /api/article/?ordering=-views\n\n# Highest rated\nGET /api/article/?ordering=-rating\n</code></pre>"},{"location":"tutorial/filtering/#multiple-field-ordering","title":"Multiple Field Ordering","text":"Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"ordering\": (str, \"-created_at,title\"),  # Multiple fields\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        ordering = filters.get(\"ordering\", \"-created_at,title\")\n\n        # Parse ordering string\n        order_fields = ordering.split(',')\n\n        # Validate each field\n        valid_fields = {\n            \"created_at\", \"-created_at\",\n            \"title\", \"-title\",\n            \"views\", \"-views\",\n        }\n\n        validated_fields = [\n            field for field in order_fields\n            if field in valid_fields\n        ]\n\n        if validated_fields:\n            queryset = queryset.order_by(*validated_fields)\n\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># Order by date, then title\nGET /api/article/?ordering=-created_at,title\n\n# Order by views, then rating\nGET /api/article/?ordering=-views,-rating\n</code></pre>"},{"location":"tutorial/filtering/#advanced-filtering","title":"Advanced Filtering","text":""},{"location":"tutorial/filtering/#related-field-filters","title":"Related Field Filters","text":"Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"author_username\": (str, None),\n        \"category_slug\": (str, None),\n        \"tag_name\": (str, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        # Filter by author username\n        if filters.get(\"author_username\"):\n            queryset = queryset.filter(\n                author__username__iexact=filters[\"author_username\"]\n            )\n\n        # Filter by category slug\n        if filters.get(\"category_slug\"):\n            queryset = queryset.filter(\n                category__slug=filters[\"category_slug\"]\n            )\n\n        # Filter by tag name\n        if filters.get(\"tag_name\"):\n            queryset = queryset.filter(\n                tags__name__iexact=filters[\"tag_name\"]\n            )\n\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># By author username\nGET /api/article/?author_username=johndoe\n\n# By category slug\nGET /api/article/?category_slug=tutorials\n\n# By tag name\nGET /api/article/?tag_name=python\n</code></pre>"},{"location":"tutorial/filtering/#multiple-tags-filter","title":"Multiple Tags Filter","text":"Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"tags\": (str, None),  # Comma-separated tag IDs or names\n        \"tags_mode\": (str, \"any\"),  # \"any\" or \"all\"\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        if filters.get(\"tags\"):\n            tag_list = filters[\"tags\"].split(',')\n            mode = filters.get(\"tags_mode\", \"any\")\n\n            # Check if tags are IDs or names\n            if tag_list[0].isdigit():\n                # Filter by tag IDs\n                tag_ids = [int(t) for t in tag_list]\n\n                if mode == \"all\":\n                    # Must have ALL tags\n                    for tag_id in tag_ids:\n                        queryset = queryset.filter(tags__id=tag_id)\n                else:\n                    # Must have ANY tag\n                    queryset = queryset.filter(tags__id__in=tag_ids).distinct()\n            else:\n                # Filter by tag names\n                if mode == \"all\":\n                    for tag_name in tag_list:\n                        queryset = queryset.filter(tags__name__iexact=tag_name)\n                else:\n                    queryset = queryset.filter(\n                        tags__name__in=tag_list\n                    ).distinct()\n\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># Articles with ANY of these tags\nGET /api/article/?tags=1,2,3\n\n# Articles with ALL of these tags\nGET /api/article/?tags=python,django,tutorial&amp;tags_mode=all\n\n# Using tag IDs\nGET /api/article/?tags=1,2,3&amp;tags_mode=all\n</code></pre>"},{"location":"tutorial/filtering/#exclude-filters","title":"Exclude Filters","text":"Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"exclude_author\": (int, None),\n        \"exclude_category\": (int, None),\n        \"exclude_ids\": (str, None),  # Comma-separated IDs\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        # Exclude specific author\n        if filters.get(\"exclude_author\"):\n            queryset = queryset.exclude(author_id=filters[\"exclude_author\"])\n\n        # Exclude specific category\n        if filters.get(\"exclude_category\"):\n            queryset = queryset.exclude(category_id=filters[\"exclude_category\"])\n\n        # Exclude specific article IDs\n        if filters.get(\"exclude_ids\"):\n            ids = [int(id) for id in filters[\"exclude_ids\"].split(',')]\n            queryset = queryset.exclude(id__in=ids)\n\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># Exclude articles by specific author\nGET /api/article/?exclude_author=5\n\n# Exclude specific articles\nGET /api/article/?exclude_ids=1,2,3\n</code></pre>"},{"location":"tutorial/filtering/#pagination","title":"Pagination","text":""},{"location":"tutorial/filtering/#default-pagination","title":"Default Pagination","text":"<p>Django Ninja Aio CRUD uses page-number pagination by default:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    # Uses default PageNumberPagination\n</code></pre> <p>Usage:</p> Bash<pre><code># First page (10 items)\nGET /api/article/?page=1\n\n# Custom page size\nGET /api/article/?page=1&amp;page_size=20\n\n# Second page\nGET /api/article/?page=2&amp;page_size=20\n</code></pre> <p>Response:</p> JSON<pre><code>{\n  \"count\": 150,\n  \"next\": 3,\n  \"previous\": 1,\n  \"results\": [...]\n}\n</code></pre>"},{"location":"tutorial/filtering/#custom-pagination","title":"Custom Pagination","text":"Python<pre><code>from ninja.pagination import PageNumberPagination\n\n\nclass CustomPagination(PageNumberPagination):\n    page_size = 25  # Default items per page\n    max_page_size = 100  # Maximum allowed\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    pagination_class = CustomPagination\n</code></pre>"},{"location":"tutorial/filtering/#disable-pagination","title":"Disable Pagination","text":"Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    pagination_class = None  # Return all results\n\n\n# Or conditionally\nclass ConditionalPagination(PageNumberPagination):\n    async def apaginate_queryset(self, queryset, pagination, request=None, **params):\n        # Disable if 'all' parameter present\n        if params.get('all'):\n            items = []\n            async for item in queryset:\n                items.append(item)\n            return {\"results\": items}\n\n        return await super().apaginate_queryset(queryset, pagination, request, **params)\n</code></pre>"},{"location":"tutorial/filtering/#filter-presets","title":"Filter Presets","text":"<p>Create reusable filter combinations:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"preset\": (str, None),\n        # ... other filters\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        preset = filters.get(\"preset\")\n\n        # Apply preset filters\n        if preset == \"trending\":\n            # Popular recent articles\n            from django.utils import timezone\n            from datetime import timedelta\n\n            last_week = timezone.now() - timedelta(days=7)\n            queryset = queryset.filter(\n                created_at__gte=last_week,\n                is_published=True\n            ).order_by('-views', '-rating')\n\n        elif preset == \"featured\":\n            # Featured articles\n            queryset = queryset.filter(\n                is_published=True,\n                is_featured=True\n            ).order_by('-featured_at')\n\n        elif preset == \"recent\":\n            # Recently published\n            queryset = queryset.filter(\n                is_published=True\n            ).order_by('-published_at')[:20]\n\n        elif preset == \"popular\":\n            # All-time most viewed\n            queryset = queryset.filter(\n                is_published=True\n            ).order_by('-views')[:50]\n\n        # Apply other filters\n        # ...\n\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># Get trending articles\nGET /api/article/?preset=trending\n\n# Get featured articles\nGET /api/article/?preset=featured\n\n# Combine with other filters\nGET /api/article/?preset=recent&amp;category=1\n</code></pre>"},{"location":"tutorial/filtering/#performance-optimization","title":"Performance Optimization","text":""},{"location":"tutorial/filtering/#select-related","title":"Select Related","text":"<p>Optimize queries with foreign keys:</p> Python<pre><code>class Article(ModelSerializer):\n    # ... fields ...\n\n    @classmethod\n    async def queryset_request(cls, request):\n        # Always include related objects\n        return cls.objects.select_related(\n            'author',\n            'category'\n        ).prefetch_related(\n            'tags',\n            'comments'\n        )\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    # Queries are now optimized automatically\n</code></pre>"},{"location":"tutorial/filtering/#index-database-fields","title":"Index Database Fields","text":"Python<pre><code># models.py\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200, db_index=True)\n    slug = models.SlugField(unique=True, db_index=True)\n    is_published = models.BooleanField(default=False, db_index=True)\n    created_at = models.DateTimeField(auto_now_add=True, db_index=True)\n\n    class Meta:\n        indexes = [\n            models.Index(fields=['-created_at']),\n            models.Index(fields=['is_published', '-created_at']),\n            models.Index(fields=['author', '-created_at']),\n            models.Index(fields=['category', '-created_at']),\n        ]\n</code></pre>"},{"location":"tutorial/filtering/#limit-query-results","title":"Limit Query Results","text":"Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    async def query_params_handler(self, queryset, filters):\n        # Apply filters\n        # ...\n\n        # Limit results for expensive queries\n        if filters.get(\"search\"):\n            queryset = queryset[:1000]  # Max 1000 results for search\n\n        return queryset\n</code></pre>"},{"location":"tutorial/filtering/#complete-example","title":"Complete Example","text":"<p>Here's a comprehensive filtering implementation:</p> Python<pre><code># views.py\nfrom ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom ninja.pagination import PageNumberPagination\nfrom django.db.models import Q\nfrom datetime import datetime\nfrom .models import Article\n\napi = NinjaAIO(title=\"Blog API\", version=\"1.0.0\")\n\n\nclass ArticlePagination(PageNumberPagination):\n    page_size = 20\n    max_page_size = 100\n\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    pagination_class = ArticlePagination\n\n    query_params = {\n        # Basic filters\n        \"is_published\": (bool, None),\n        \"author\": (int, None),\n        \"category\": (int, None),\n\n        # Text search\n        \"search\": (str, None),\n\n        # Date range\n        \"created_after\": (str, None),\n        \"created_before\": (str, None),\n\n        # Numeric range\n        \"min_views\": (int, None),\n        \"max_views\": (int, None),\n\n        # Related filters\n        \"author_username\": (str, None),\n        \"category_slug\": (str, None),\n        \"tags\": (str, None),\n        \"tags_mode\": (str, \"any\"),\n\n        # Ordering\n        \"ordering\": (str, \"-created_at\"),\n\n        # Presets\n        \"preset\": (str, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        # Apply preset first\n        preset = filters.get(\"preset\")\n        if preset == \"trending\":\n            from django.utils import timezone\n            from datetime import timedelta\n            last_week = timezone.now() - timedelta(days=7)\n            queryset = queryset.filter(\n                created_at__gte=last_week,\n                is_published=True\n            )\n        elif preset == \"popular\":\n            queryset = queryset.filter(is_published=True)\n\n        # Published status\n        if filters.get(\"is_published\") is not None:\n            queryset = queryset.filter(is_published=filters[\"is_published\"])\n\n        # Author filter\n        if filters.get(\"author\"):\n            queryset = queryset.filter(author_id=filters[\"author\"])\n        elif filters.get(\"author_username\"):\n            queryset = queryset.filter(\n                author__username__iexact=filters[\"author_username\"]\n            )\n\n        # Category filter\n        if filters.get(\"category\"):\n            queryset = queryset.filter(category_id=filters[\"category\"])\n        elif filters.get(\"category_slug\"):\n            queryset = queryset.filter(category__slug=filters[\"category_slug\"])\n\n        # Tags filter\n        if filters.get(\"tags\"):\n            tag_list = filters[\"tags\"].split(',')\n            mode = filters.get(\"tags_mode\", \"any\")\n\n            if mode == \"all\":\n                for tag in tag_list:\n                    if tag.isdigit():\n                        queryset = queryset.filter(tags__id=int(tag))\n                    else:\n                        queryset = queryset.filter(tags__name__iexact=tag)\n            else:\n                if tag_list[0].isdigit():\n                    tag_ids = [int(t) for t in tag_list]\n                    queryset = queryset.filter(tags__id__in=tag_ids).distinct()\n                else:\n                    queryset = queryset.filter(tags__name__in=tag_list).distinct()\n\n        # Search\n        if filters.get(\"search\"):\n            search_term = filters[\"search\"]\n            queryset = queryset.filter(\n                Q(title__icontains=search_term) |\n                Q(content__icontains=search_term)\n            )\n\n        # Date range\n        if filters.get(\"created_after\"):\n            date = datetime.fromisoformat(filters[\"created_after\"])\n            queryset = queryset.filter(created_at__gte=date)\n\n        if filters.get(\"created_before\"):\n            date = datetime.fromisoformat(filters[\"created_before\"])\n            queryset = queryset.filter(created_at__lte=date)\n\n        # Views range\n        if filters.get(\"min_views\"):\n            queryset = queryset.filter(views__gte=filters[\"min_views\"])\n\n        if filters.get(\"max_views\"):\n            queryset = queryset.filter(views__lte=filters[\"max_views\"])\n\n        # Ordering\n        ordering = filters.get(\"ordering\", \"-created_at\")\n        valid_orderings = [\n            \"created_at\", \"-created_at\",\n            \"title\", \"-title\",\n            \"views\", \"-views\",\n            \"published_at\", \"-published_at\",\n        ]\n\n        if ordering in valid_orderings:\n            queryset = queryset.order_by(ordering)\n        elif preset == \"trending\":\n            queryset = queryset.order_by('-views', '-rating')\n        elif preset == \"popular\":\n            queryset = queryset.order_by('-views')\n\n        return queryset\n</code></pre>"},{"location":"tutorial/filtering/#testing-filters","title":"Testing Filters","text":"Bash<pre><code># Basic filtering\ncurl \"http://localhost:8000/api/article/?is_published=true\"\n\n# Search\ncurl \"http://localhost:8000/api/article/?search=django\"\n\n# Date range\ncurl \"http://localhost:8000/api/article/?created_after=2024-01-01&amp;created_before=2024-01-31\"\n\n# Multiple filters\ncurl \"http://localhost:8000/api/article/?is_published=true&amp;category=1&amp;min_views=100&amp;ordering=-views\"\n\n# Tags\ncurl \"http://localhost:8000/api/article/?tags=python,django&amp;tags_mode=all\"\n\n# Presets\ncurl \"http://localhost:8000/api/article/?preset=trending\"\n\n# Pagination\ncurl \"http://localhost:8000/api/article/?page=2&amp;page_size=50\"\n\n# Combined\ncurl \"http://localhost:8000/api/article/?search=tutorial&amp;category=1&amp;is_published=true&amp;min_views=1000&amp;ordering=-rating&amp;page=1&amp;page_size=20\"\n</code></pre>"},{"location":"tutorial/filtering/#congratulations","title":"Congratulations!","text":"<p>You've completed all tutorial steps and built a complete, production-ready API!</p>"},{"location":"tutorial/filtering/#what-youve-built","title":"What You've Built","text":"<ul> <li> Models with automatic schema generation</li> <li> Full CRUD operations</li> <li> JWT authentication</li> <li> Custom schemas and validation</li> <li> Advanced filtering and search</li> <li> Pagination</li> <li> Performance optimization</li> </ul>"},{"location":"tutorial/filtering/#next-steps","title":"Next Steps","text":"<p>Explore advanced topics:</p> <ul> <li> <p> API Reference</p> <p> Complete documentation</p> </li> <li> <p> Authentication</p> <p> Advanced auth patterns</p> </li> <li> <p> Pagination</p> <p> Custom strategies</p> </li> <li> <p> ModelUtil</p> <p> Query optimization</p> </li> </ul>"},{"location":"tutorial/model/","title":"Step 1: Define Your Model","text":"<p>Step 1 of 4</p> <p>Prerequisites \u2014 Make sure you have Django 4.1+ installed, <code>django-ninja-aio-crud</code> installed, and a Django project set up.</p>"},{"location":"tutorial/model/#define-your-model","title":"Define Your Model","text":"<p> Learn how to define Django models using <code>ModelSerializer</code> with automatic schema generation for your API. </p>"},{"location":"tutorial/model/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li> How to create a model with <code>ModelSerializer</code></li> <li> Defining serialization schemas (Create, Read, Update)</li> <li> Working with ForeignKey and ManyToMany relationships</li> <li> Adding custom computed fields</li> <li> Query optimizations with <code>QuerySet</code></li> <li> Implementing lifecycle hooks</li> </ul>"},{"location":"tutorial/model/#basic-model-definition","title":"Basic Model Definition","text":"<p>Let's create a simple blog article model:</p> Python<pre><code># models.py\nfrom django.db import models\nfrom ninja_aio.models import ModelSerializer\n\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    is_published = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    def __str__(self):\n        return self.title\n</code></pre> <p>Why ModelSerializer?</p> <p><code>ModelSerializer</code> is a powerful mixin that combines Django's <code>Model</code> with automatic schema generation capabilities. Instead of creating separate serializer classes, you define everything on the model itself.</p>"},{"location":"tutorial/model/#adding-serializer-classes","title":"Adding Serializer Classes","text":"<p>Now let's add serialization schemas to control which fields are exposed in different operations:</p>"},{"location":"tutorial/model/#readserializer","title":"ReadSerializer","text":"<p>Defines which fields appear in API responses:</p> Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    is_published = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"content\", \"is_published\", \"created_at\", \"updated_at\"]\n\n    def __str__(self):\n        return self.title\n</code></pre> <p>Result: When you retrieve an article, the API will return:</p> JSON<pre><code>{\n  \"id\": 1,\n  \"title\": \"Getting Started with Django\",\n  \"content\": \"In this article...\",\n  \"is_published\": true,\n  \"created_at\": \"2024-01-15T10:30:00Z\",\n  \"updated_at\": \"2024-01-15T11:00:00Z\"\n}\n</code></pre>"},{"location":"tutorial/model/#createserializer","title":"CreateSerializer","text":"<p>Defines which fields are required/allowed when creating:</p> Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    is_published = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"content\", \"is_published\", \"created_at\", \"updated_at\"]\n\n    class CreateSerializer:\n        fields = [\"title\", \"content\"]\n        optionals = [\n            (\"is_published\", bool),\n        ]\n\n    def __str__(self):\n        return self.title\n</code></pre> <p>Usage: When creating an article:</p> JSON<pre><code>// Required fields\n{\n  \"title\": \"My New Article\",\n  \"content\": \"Article content here...\"\n}\n\n// With optional field\n{\n  \"title\": \"My New Article\",\n  \"content\": \"Article content here...\",\n  \"is_published\": true\n}\n</code></pre> <p>Auto-generated Fields</p> <p>Fields like <code>id</code>, <code>created_at</code>, and <code>updated_at</code> are automatically handled by Django and shouldn't be in <code>CreateSerializer.fields</code>.</p>"},{"location":"tutorial/model/#updateserializer","title":"UpdateSerializer","text":"<p>Defines which fields can be updated (usually all optional for PATCH):</p> Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    is_published = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"content\", \"is_published\", \"created_at\", \"updated_at\"]\n\n    class CreateSerializer:\n        fields = [\"title\", \"content\"]\n        optionals = [(\"is_published\", bool)]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"title\", str),\n            (\"content\", str),\n            (\"is_published\", bool),\n        ]\n        excludes = [\"created_at\", \"updated_at\"]\n\n    def __str__(self):\n        return self.title\n</code></pre> <p>Usage: Partial update (PATCH):</p> JSON<pre><code>// Update only title\n{\n  \"title\": \"Updated Title\"\n}\n\n// Update multiple fields\n{\n  \"title\": \"Updated Title\",\n  \"is_published\": true\n}\n</code></pre>"},{"location":"tutorial/model/#working-with-relationships","title":"Working with Relationships","text":""},{"location":"tutorial/model/#foreignkey-relationships","title":"ForeignKey Relationships","text":"<p>Let's add an author to our articles:</p> Python<pre><code>class Author(ModelSerializer):\n    name = models.CharField(max_length=200)\n    email = models.EmailField(unique=True)\n    bio = models.TextField(blank=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"email\", \"bio\"]\n\n    class CreateSerializer:\n        fields = [\"name\", \"email\"]\n        optionals = [(\"bio\", str)]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"name\", str),\n            (\"email\", str),\n            (\"bio\", str),\n        ]\n\n    def __str__(self):\n        return self.name\n\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"articles\")\n    is_published = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"content\", \"author\", \"is_published\", \"created_at\"]\n\n    class CreateSerializer:\n        fields = [\"title\", \"content\", \"author\"]\n        optionals = [(\"is_published\", bool)]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"title\", str),\n            (\"content\", str),\n            (\"is_published\", bool),\n        ]\n        excludes = [\"author\"]  # Can't change author after creation\n\n    def __str__(self):\n        return self.title\n</code></pre> <p>Creating an article with author:</p> JSON<pre><code>{\n  \"title\": \"My Article\",\n  \"content\": \"Content here...\",\n  \"author\": 5 // Author ID\n}\n</code></pre> <p>Response includes nested author data:</p> JSON<pre><code>{\n  \"id\": 1,\n  \"title\": \"My Article\",\n  \"content\": \"Content here...\",\n  \"author\": {\n    \"id\": 5,\n    \"name\": \"John Doe\",\n    \"email\": \"john@example.com\",\n    \"bio\": \"Software developer\"\n  },\n  \"is_published\": false,\n  \"created_at\": \"2024-01-15T10:30:00Z\"\n}\n</code></pre> <p>Automatic Nested Serialization</p> <p>When <code>Author</code> is also a <code>ModelSerializer</code>, Django Ninja Aio CRUD automatically serializes it in the response!</p>"},{"location":"tutorial/model/#manytomany-relationships","title":"ManyToMany Relationships","text":"<p>Let's add tags to articles:</p> Python<pre><code>class Tag(ModelSerializer):\n    name = models.CharField(max_length=50, unique=True)\n    slug = models.SlugField(unique=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"slug\"]\n\n    class CreateSerializer:\n        fields = [\"name\", \"slug\"]\n\n    def __str__(self):\n        return self.name\n\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"articles\")\n    tags = models.ManyToManyField(Tag, related_name=\"articles\", blank=True)\n    is_published = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"content\", \"author\", \"tags\", \"is_published\", \"created_at\"]\n\n    class CreateSerializer:\n        fields = [\"title\", \"content\", \"author\"]\n        optionals = [\n            (\"is_published\", bool),\n            (\"tags\", list[int]),  # List of tag IDs\n        ]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"title\", str),\n            (\"content\", str),\n            (\"is_published\", bool),\n            (\"tags\", list[int]),\n        ]\n\n    def __str__(self):\n        return self.title\n</code></pre> <p>Creating with tags:</p> JSON<pre><code>{\n  \"title\": \"My Article\",\n  \"content\": \"Content...\",\n  \"author\": 5,\n  \"tags\": [1, 2, 3] // Tag IDs\n}\n</code></pre> <p>Response:</p> JSON<pre><code>{\n  \"id\": 1,\n  \"title\": \"My Article\",\n  \"content\": \"Content...\",\n  \"author\": {...},\n  \"tags\": [\n    {\"id\": 1, \"name\": \"python\", \"slug\": \"python\"},\n    {\"id\": 2, \"name\": \"django\", \"slug\": \"django\"},\n    {\"id\": 3, \"name\": \"tutorial\", \"slug\": \"tutorial\"}\n  ],\n  \"is_published\": false,\n  \"created_at\": \"2024-01-15T10:30:00Z\"\n}\n</code></pre>"},{"location":"tutorial/model/#adding-custom-fields","title":"Adding Custom Fields","text":"<p>Sometimes you need computed or synthetic fields in your API responses:</p> Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"articles\")\n    views = models.IntegerField(default=0)\n    is_published = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"content\", \"author\", \"views\", \"is_published\", \"created_at\"]\n        customs = [\n            (\"word_count\", int, lambda obj: len(obj.content.split())),\n            (\"reading_time\", int, lambda obj: len(obj.content.split()) // 200),  # Assume 200 words/min\n            (\"author_name\", str, lambda obj: obj.author.name),\n        ]\n\n    class CreateSerializer:\n        fields = [\"title\", \"content\", \"author\"]\n        customs = [\n            (\"notify_subscribers\", bool, True),  # Custom action flag\n            (\"schedule_publish\", str, None),  # ISO datetime string\n        ]\n\n    def __str__(self):\n        return self.title\n</code></pre> <p>Response with custom fields:</p> JSON<pre><code>{\n  \"id\": 1,\n  \"title\": \"My Article\",\n  \"content\": \"...\",\n  \"author\": {...},\n  \"views\": 150,\n  \"is_published\": true,\n  \"created_at\": \"2024-01-15T10:30:00Z\",\n  \"word_count\": 842,\n  \"reading_time\": 4,\n  \"author_name\": \"John Doe\"\n}\n</code></pre> <p>Custom Fields in CreateSerializer</p> <p>Custom fields in <code>CreateSerializer</code> are used for instructions (like flags or metadata), not stored in the database. They're passed to <code>custom_actions()</code> hook.</p>"},{"location":"tutorial/model/#query-optimizations-queryset","title":"Query Optimizations (QuerySet)","text":"<p>Configure select_related/prefetch_related for read and queryset_request hooks:</p> Python<pre><code>from ninja_aio.schemas.helpers import ModelQuerySetSchema, ModelQuerySetExtraSchema\n\nclass Article(ModelSerializer):\n    # ...existing fields...\n\n    class QuerySet:\n        read = ModelQuerySetSchema(\n            select_related=[\"author\", \"category\"],\n            prefetch_related=[\"tags\"],\n        )\n        queryset_request = ModelQuerySetSchema(\n            select_related=[],\n            prefetch_related=[\"tags\"],\n        )\n        extras = [\n            ModelQuerySetExtraSchema(\n                scope=\"cards\",\n                select_related=[\"author\"],\n                prefetch_related=[],\n            )\n        ]\n</code></pre> <p>Use the QueryUtil for custom scopes:</p> Python<pre><code>qs = Article.query_util.apply_queryset_optimizations(\n    Article.objects.all(),\n    Article.query_util.SCOPES.cards,  # from extras\n)\n</code></pre>"},{"location":"tutorial/model/#fetch-and-serialize-with-modelutil","title":"Fetch and Serialize with ModelUtil","text":"Python<pre><code>from ninja_aio.models import ModelUtil\nfrom ninja_aio.schemas.helpers import ObjectsQuerySchema, ObjectQuerySchema\n\nutil = ModelUtil(Article)\n\n# List published with default read optimizations\nitems = await util.list_read_s(\n    Article.generate_read_s(),\n    request,\n    query_data=ObjectsQuerySchema(filters={\"is_published\": True}),\n    is_for_read=True,\n)\n\n# Retrieve by slug with getters\nitem = await util.read_s(\n    Article.generate_read_s(),\n    request,\n    query_data=ObjectQuerySchema(getters={\"slug\": \"my-article\"}),\n    is_for_read=True,\n)\n</code></pre>"},{"location":"tutorial/model/#lifecycle-hooks","title":"Lifecycle Hooks","text":"<p>Add behavior at key points in the model lifecycle:</p>"},{"location":"tutorial/model/#sync-hooks","title":"Sync Hooks","text":"Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    slug = models.SlugField(unique=True, blank=True)\n    is_published = models.BooleanField(default=False)\n    published_at = models.DateTimeField(null=True, blank=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"slug\", \"is_published\", \"published_at\"]\n\n    def before_save(self):\n        \"\"\"Called before every save (create and update)\"\"\"\n        if not self.slug:\n            from django.utils.text import slugify\n            self.slug = slugify(self.title)\n\n    def on_create_before_save(self):\n        \"\"\"Called only on creation, before save\"\"\"\n        print(f\"Creating new article: {self.title}\")\n\n    def after_save(self):\n        \"\"\"Called after every save\"\"\"\n        from django.core.cache import cache\n        cache.delete(f\"article:{self.id}\")\n\n    def on_create_after_save(self):\n        \"\"\"Called only after creation\"\"\"\n        print(f\"Article created with ID: {self.id}\")\n\n    def on_delete(self):\n        \"\"\"Called after deletion\"\"\"\n        print(f\"Article deleted: {self.title}\")\n</code></pre>"},{"location":"tutorial/model/#async-hooks","title":"Async Hooks","text":"Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    author = models.ForeignKey(Author, on_delete=models.CASCADE)\n    is_published = models.BooleanField(default=False)\n\n    class CreateSerializer:\n        fields = [\"title\", \"content\", \"author\"]\n        customs = [\n            (\"notify_subscribers\", bool, True),\n            (\"schedule_publish\", str, None),\n        ]\n\n    async def post_create(self):\n        \"\"\"Called after object creation (async)\"\"\"\n        # Send notification email\n        from myapp.tasks import send_new_article_notification\n        await send_new_article_notification(self.id)\n\n        # Create activity log\n        from myapp.models import ActivityLog\n        await ActivityLog.objects.acreate(\n            action=\"article_created\",\n            article_id=self.id,\n            user_id=self.author_id\n        )\n\n    async def custom_actions(self, payload: dict):\n        \"\"\"Process custom fields from CreateSerializer\"\"\"\n        if payload.get(\"notify_subscribers\"):\n            from myapp.tasks import notify_subscribers\n            await notify_subscribers(self.id)\n\n        if payload.get(\"schedule_publish\"):\n            from datetime import datetime\n            schedule_time = datetime.fromisoformat(payload[\"schedule_publish\"])\n            from myapp.tasks import schedule_publish_task\n            await schedule_publish_task(self.id, schedule_time)\n</code></pre> <p>Execution Order</p> <p>Create: <code>on_create_before_save()</code> \u2192 <code>before_save()</code> \u2192 <code>save()</code> \u2192 <code>on_create_after_save()</code> \u2192 <code>after_save()</code> \u2192 <code>custom_actions()</code> \u2192 <code>post_create()</code></p> <p>Update: <code>before_save()</code> \u2192 <code>save()</code> \u2192 <code>after_save()</code> \u2192 <code>custom_actions()</code></p>"},{"location":"tutorial/model/#complete-example","title":"Complete Example","text":"<p>Here's a complete blog model with all features:</p> Full blog model code (click to expand) Python<pre><code># models.py\nfrom django.db import models\nfrom django.utils.text import slugify\nfrom ninja_aio.models import ModelSerializer\n\n\nclass Author(ModelSerializer):\n    name = models.CharField(max_length=200)\n    email = models.EmailField(unique=True)\n    bio = models.TextField(blank=True)\n    avatar = models.URLField(blank=True)\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"email\", \"bio\", \"avatar\", \"created_at\"]\n        customs = [\n            (\"article_count\", int, lambda obj: obj.articles.count()),\n        ]\n\n    class CreateSerializer:\n        fields = [\"name\", \"email\"]\n        optionals = [(\"bio\", str), (\"avatar\", str)]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"name\", str),\n            (\"bio\", str),\n            (\"avatar\", str),\n        ]\n        excludes = [\"email\", \"created_at\"]\n\n    def __str__(self):\n        return self.name\n\n\nclass Category(ModelSerializer):\n    name = models.CharField(max_length=100)\n    slug = models.SlugField(unique=True, blank=True)\n    description = models.TextField(blank=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"slug\", \"description\"]\n\n    class CreateSerializer:\n        fields = [\"name\"]\n        optionals = [(\"description\", str)]\n\n    def before_save(self):\n        if not self.slug:\n            self.slug = slugify(self.name)\n\n    def __str__(self):\n        return self.name\n\n\nclass Tag(ModelSerializer):\n    name = models.CharField(max_length=50, unique=True)\n    slug = models.SlugField(unique=True, blank=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"slug\"]\n\n    class CreateSerializer:\n        fields = [\"name\"]\n\n    def before_save(self):\n        if not self.slug:\n            self.slug = slugify(self.name)\n\n    def __str__(self):\n        return self.name\n\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    slug = models.SlugField(unique=True, blank=True)\n    content = models.TextField()\n    excerpt = models.TextField(max_length=300, blank=True)\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"articles\")\n    category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True, related_name=\"articles\")\n    tags = models.ManyToManyField(Tag, related_name=\"articles\", blank=True)\n    cover_image = models.URLField(blank=True)\n    is_published = models.BooleanField(default=False)\n    published_at = models.DateTimeField(null=True, blank=True)\n    views = models.IntegerField(default=0)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    class ReadSerializer:\n        fields = [\n            \"id\", \"title\", \"slug\", \"content\", \"excerpt\",\n            \"author\", \"category\", \"tags\", \"cover_image\",\n            \"is_published\", \"published_at\", \"views\",\n            \"created_at\", \"updated_at\"\n        ]\n        customs = [\n            (\"word_count\", int, lambda obj: len(obj.content.split())),\n            (\"reading_time\", int, lambda obj: max(1, len(obj.content.split()) // 200)),\n        ]\n\n    class CreateSerializer:\n        fields = [\"title\", \"content\", \"author\", \"category\"]\n        optionals = [\n            (\"excerpt\", str),\n            (\"cover_image\", str),\n            (\"tags\", list[int]),\n            (\"is_published\", bool),\n        ]\n        customs = [\n            (\"notify_subscribers\", bool, True),\n        ]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"title\", str),\n            (\"content\", str),\n            (\"excerpt\", str),\n            (\"category\", int),\n            (\"tags\", list[int]),\n            (\"cover_image\", str),\n            (\"is_published\", bool),\n        ]\n        excludes = [\"author\", \"created_at\", \"views\"]\n\n    def before_save(self):\n        # Generate slug from title\n        if not self.slug:\n            self.slug = slugify(self.title)\n\n        # Auto-generate excerpt\n        if not self.excerpt and self.content:\n            self.excerpt = self.content[:297] + \"...\"\n\n        # Set published_at when publishing\n        if self.is_published and not self.published_at:\n            from django.utils import timezone\n            self.published_at = timezone.now()\n\n    async def post_create(self):\n        # Log creation\n        from myapp.models import ActivityLog\n        await ActivityLog.objects.acreate(\n            action=\"article_created\",\n            article_id=self.id,\n            user_id=self.author_id\n        )\n\n    async def custom_actions(self, payload: dict):\n        if payload.get(\"notify_subscribers\"):\n            # Send notifications (implement your notification logic)\n            from myapp.tasks import notify_article_published\n            await notify_article_published(self.id)\n\n    def __str__(self):\n        return self.title\n</code></pre>"},{"location":"tutorial/model/#run-migrations","title":"Run Migrations","text":"<p>After defining your models, create and run migrations:</p> Bash<pre><code># Create migrations\npython manage.py makemigrations\n\n# Apply migrations\npython manage.py migrate\n</code></pre> <p>Ready for the next step?</p> <p>Now that you have your models defined, let's create CRUD views!</p> <p>Step 2: Create CRUD Views </p> <ul> <li> <p> API Reference</p> <p> ModelSerializer \u00b7  ModelUtil</p> </li> </ul>"},{"location":"tutorial/model/#what-youve-learned","title":"What You've Learned","text":"<ul> <li> Creating models with <code>ModelSerializer</code></li> <li> Defining Read, Create, and Update serializers</li> <li> Working with ForeignKey and ManyToMany relationships</li> <li> Adding custom computed fields</li> <li> Configuring query optimizations</li> <li> Implementing lifecycle hooks</li> </ul>"},{"location":"tutorial/serializer/","title":"Alternative: Define Your Serializer","text":"<p>Alternative to Step 1</p> <p>Prerequisites \u2014 Make sure you have Django 4.1+ installed, <code>django-ninja-aio-crud</code> installed, and a Django project set up.</p> <p>When to Use Serializer</p> <p>Choose <code>Serializer</code> when you have existing Django models you don't want to modify, want to keep models and API concerns separated, or when multiple teams work on models vs. API layers. If you're starting fresh, consider ModelSerializer instead.</p>"},{"location":"tutorial/serializer/#define-your-serializer","title":"Define Your Serializer","text":"<p> Use Meta-driven <code>Serializer</code> to add API functionality to existing Django models without changing their base class. </p>"},{"location":"tutorial/serializer/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li> How <code>Serializer</code> differs from <code>ModelSerializer</code></li> <li> Defining schemas with <code>SchemaModelConfig</code></li> <li> Working with relationships via <code>relations_serializers</code></li> <li> Adding custom and computed fields</li> <li> Query optimizations with <code>QuerySet</code></li> <li> Implementing lifecycle hooks</li> <li> Connecting to <code>APIViewSet</code></li> </ul>"},{"location":"tutorial/serializer/#how-it-works","title":"How It Works","text":"<p>With <code>ModelSerializer</code>, you embed schema configuration directly on the model. With <code>Serializer</code>, your models stay as plain Django models and you define everything in a separate serializer class:</p> Serializer (separated)ModelSerializer (embedded) Python<pre><code># models.py \u2014 plain Django model\nfrom django.db import models\n\nclass Article(models.Model):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    is_published = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n\n# serializers.py \u2014 API configuration\nfrom ninja_aio.models import serializers\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = Article\n        schema_in = serializers.SchemaModelConfig(\n            fields=[\"title\", \"content\"]\n        )\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"content\", \"is_published\", \"created_at\"]\n        )\n</code></pre> Python<pre><code># models.py \u2014 API config on the model\nfrom ninja_aio.models import ModelSerializer\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    is_published = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"content\", \"is_published\", \"created_at\"]\n\n    class CreateSerializer:\n        fields = [\"title\", \"content\"]\n</code></pre>"},{"location":"tutorial/serializer/#defining-schemas","title":"Defining Schemas","text":"<p>The <code>Serializer</code> uses a nested <code>Meta</code> class with <code>SchemaModelConfig</code> to configure each operation:</p>"},{"location":"tutorial/serializer/#create-schema-schema_in","title":"Create Schema (<code>schema_in</code>)","text":"<p>Defines which fields are accepted when creating an object:</p> Python<pre><code>from ninja_aio.models import serializers\nfrom .models import Article\n\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = Article\n        schema_in = serializers.SchemaModelConfig(\n            fields=[\"title\", \"content\"],\n            optionals=[(\"is_published\", bool)],\n        )\n</code></pre> <ul> <li><code>fields</code> \u2014 required fields for creation</li> <li><code>optionals</code> \u2014 optional fields as <code>(name, type)</code> tuples</li> </ul> <p>Request body:</p> JSON<pre><code>{\n  \"title\": \"My Article\",\n  \"content\": \"Content here...\",\n  \"is_published\": true  // optional\n}\n</code></pre>"},{"location":"tutorial/serializer/#read-schema-schema_out","title":"Read Schema (<code>schema_out</code>)","text":"<p>Defines which fields appear in list API responses:</p> Python<pre><code>class ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = Article\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"content\", \"is_published\", \"created_at\"]\n        )\n</code></pre> <p>Response:</p> JSON<pre><code>{\n  \"id\": 1,\n  \"title\": \"My Article\",\n  \"content\": \"Content here...\",\n  \"is_published\": false,\n  \"created_at\": \"2024-01-15T10:30:00Z\"\n}\n</code></pre>"},{"location":"tutorial/serializer/#detail-schema-schema_detail","title":"Detail Schema (<code>schema_detail</code>)","text":"<p>Optionally return more fields for the retrieve endpoint than the list endpoint:</p> Python<pre><code>class ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = Article\n        schema_out = serializers.SchemaModelConfig(\n            # List view: minimal fields\n            fields=[\"id\", \"title\", \"is_published\"]\n        )\n        schema_detail = serializers.SchemaModelConfig(\n            # Detail view: all fields\n            fields=[\"id\", \"title\", \"content\", \"is_published\", \"created_at\"],\n            customs=[(\"word_count\", int, lambda obj: len(obj.content.split()))]\n        )\n</code></pre> <p>Fallback Behavior</p> <p>If <code>schema_detail</code> is not defined, it falls back to <code>schema_out</code>. If <code>schema_detail</code> is defined, it does not inherit from <code>schema_out</code> \u2014 you must specify all fields explicitly.</p>"},{"location":"tutorial/serializer/#update-schema-schema_update","title":"Update Schema (<code>schema_update</code>)","text":"<p>Defines which fields can be updated (PATCH):</p> Python<pre><code>class ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = Article\n        schema_update = serializers.SchemaModelConfig(\n            optionals=[\n                (\"title\", str),\n                (\"content\", str),\n                (\"is_published\", bool),\n            ]\n        )\n</code></pre> <p>Request body (partial update):</p> JSON<pre><code>{\n  \"title\": \"Updated Title\"\n}\n</code></pre>"},{"location":"tutorial/serializer/#complete-schema-definition","title":"Complete Schema Definition","text":"<p>Putting it all together:</p> Python<pre><code>from ninja_aio.models import serializers\nfrom .models import Article\n\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = Article\n        schema_in = serializers.SchemaModelConfig(\n            fields=[\"title\", \"content\"],\n            optionals=[(\"is_published\", bool)],\n        )\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"content\", \"is_published\", \"created_at\"]\n        )\n        schema_update = serializers.SchemaModelConfig(\n            optionals=[\n                (\"title\", str),\n                (\"content\", str),\n                (\"is_published\", bool),\n            ]\n        )\n</code></pre>"},{"location":"tutorial/serializer/#working-with-relationships","title":"Working with Relationships","text":"<p>Unlike <code>ModelSerializer</code> which auto-resolves nested serializers, <code>Serializer</code> requires you to explicitly declare them via <code>relations_serializers</code>.</p>"},{"location":"tutorial/serializer/#foreignkey-relationships","title":"ForeignKey Relationships","text":"Python<pre><code>from ninja_aio.models import serializers\nfrom .models import Author, Article\n\n\nclass AuthorSerializer(serializers.Serializer):\n    class Meta:\n        model = Author\n        schema_in = serializers.SchemaModelConfig(\n            fields=[\"name\", \"email\"],\n            optionals=[(\"bio\", str)],\n        )\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"name\", \"email\", \"bio\"]\n        )\n        schema_update = serializers.SchemaModelConfig(\n            optionals=[(\"name\", str), (\"bio\", str)]\n        )\n\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = Article\n        schema_in = serializers.SchemaModelConfig(\n            fields=[\"title\", \"content\", \"author\"],\n        )\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"content\", \"author\", \"is_published\", \"created_at\"]\n        )\n        schema_update = serializers.SchemaModelConfig(\n            optionals=[(\"title\", str), (\"content\", str), (\"is_published\", bool)]\n        )\n        # Explicit nested serialization\n        relations_serializers = {\n            \"author\": AuthorSerializer,\n        }\n\n    class QuerySet:\n        read = serializers.ModelQuerySetSchema(\n            select_related=[\"author\"]\n        )\n</code></pre> <p>Response with nested author:</p> JSON<pre><code>{\n  \"id\": 1,\n  \"title\": \"My Article\",\n  \"content\": \"Content here...\",\n  \"author\": {\n    \"id\": 5,\n    \"name\": \"John Doe\",\n    \"email\": \"john@example.com\",\n    \"bio\": \"Software developer\"\n  },\n  \"is_published\": false,\n  \"created_at\": \"2024-01-15T10:30:00Z\"\n}\n</code></pre>"},{"location":"tutorial/serializer/#reverse-relations","title":"Reverse Relations","text":"<p>Include reverse relations (e.g., an author's articles) using <code>relations_serializers</code>:</p> Python<pre><code>class AuthorSerializer(serializers.Serializer):\n    class Meta:\n        model = Author\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"name\", \"email\", \"articles\"]  # reverse related name\n        )\n        relations_serializers = {\n            \"articles\": ArticleSerializer,\n        }\n</code></pre>"},{"location":"tutorial/serializer/#string-references-circular-dependencies","title":"String References (Circular Dependencies)","text":"<p>When two serializers reference each other, use string references to avoid import errors:</p> Python<pre><code>class AuthorSerializer(serializers.Serializer):\n    class Meta:\n        model = Author\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"name\", \"articles\"]\n        )\n        relations_serializers = {\n            \"articles\": \"ArticleSerializer\",  # String reference\n        }\n\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = Article\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"author\"]\n        )\n        relations_serializers = {\n            \"author\": \"AuthorSerializer\",  # Circular reference works!\n        }\n</code></pre> <p>You can also use absolute import paths for cross-module references:</p> Python<pre><code>relations_serializers = {\n    \"author\": \"users.serializers.UserSerializer\",\n}\n</code></pre>"},{"location":"tutorial/serializer/#relations-as-ids","title":"Relations as IDs","text":"<p>For lighter responses, serialize relations as IDs instead of nested objects:</p> Python<pre><code>class ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = Article\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"author\", \"tags\", \"category\"]\n        )\n        relations_serializers = {\n            \"author\": AuthorSerializer,      # Nested object\n            \"category\": CategorySerializer,  # Nested object\n        }\n        relations_as_id = [\"tags\"]           # Just IDs\n</code></pre> <p>Response:</p> JSON<pre><code>{\n  \"id\": 1,\n  \"title\": \"My Article\",\n  \"author\": {\"id\": 5, \"name\": \"John Doe\", \"email\": \"john@example.com\"},\n  \"category\": {\"id\": 2, \"name\": \"Tutorials\", \"slug\": \"tutorials\"},\n  \"tags\": [1, 2, 5]\n}\n</code></pre>"},{"location":"tutorial/serializer/#manytomany-relationships","title":"ManyToMany Relationships","text":"Python<pre><code>from .models import Author, Tag, Article\n\n\nclass TagSerializer(serializers.Serializer):\n    class Meta:\n        model = Tag\n        schema_in = serializers.SchemaModelConfig(fields=[\"name\", \"slug\"])\n        schema_out = serializers.SchemaModelConfig(fields=[\"id\", \"name\", \"slug\"])\n\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = Article\n        schema_in = serializers.SchemaModelConfig(\n            fields=[\"title\", \"content\", \"author\"],\n            optionals=[(\"tags\", list[int])],\n        )\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"content\", \"author\", \"tags\", \"created_at\"]\n        )\n        relations_serializers = {\n            \"author\": AuthorSerializer,\n            \"tags\": TagSerializer,\n        }\n\n    class QuerySet:\n        read = serializers.ModelQuerySetSchema(\n            select_related=[\"author\"],\n            prefetch_related=[\"tags\"],\n        )\n</code></pre>"},{"location":"tutorial/serializer/#custom-and-computed-fields","title":"Custom and Computed Fields","text":""},{"location":"tutorial/serializer/#custom-fields-in-read-schema","title":"Custom Fields in Read Schema","text":"<p>Add computed fields using <code>customs</code>:</p> Python<pre><code>class ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = Article\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"content\", \"views\", \"created_at\"],\n            customs=[\n                (\"word_count\", int, lambda obj: len(obj.content.split())),\n                (\"reading_time\", int, lambda obj: max(1, len(obj.content.split()) // 200)),\n            ]\n        )\n</code></pre>"},{"location":"tutorial/serializer/#inline-custom-fields","title":"Inline Custom Fields","text":"<p>You can also define custom fields directly in the <code>fields</code> list as tuples:</p> Python<pre><code>class ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = Article\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\n                \"id\",\n                \"title\",\n                (\"word_count\", int, 0),       # 3-tuple: (name, type, default)\n                (\"is_featured\", bool),          # 2-tuple: (name, type) \u2014 required\n            ]\n        )\n</code></pre>"},{"location":"tutorial/serializer/#custom-fields-in-create-schema","title":"Custom Fields in Create Schema","text":"<p>Use <code>customs</code> for instruction flags that aren't stored in the database:</p> Python<pre><code>class ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = Article\n        schema_in = serializers.SchemaModelConfig(\n            fields=[\"title\", \"content\", \"author\"],\n            customs=[\n                (\"notify_subscribers\", bool, True),\n                (\"schedule_publish\", str, None),\n            ],\n        )\n</code></pre> <p>These are passed to the <code>custom_actions()</code> hook.</p>"},{"location":"tutorial/serializer/#query-optimizations","title":"Query Optimizations","text":"<p>Configure <code>select_related</code> / <code>prefetch_related</code> for automatic optimization:</p> Python<pre><code>from ninja_aio.schemas.helpers import ModelQuerySetSchema, ModelQuerySetExtraSchema\n\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = Article\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"author\", \"category\"]\n        )\n        schema_detail = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"content\", \"author\", \"category\", \"tags\", \"comments\"]\n        )\n\n    class QuerySet:\n        read = ModelQuerySetSchema(\n            select_related=[\"author\", \"category\"],\n            prefetch_related=[\"tags\"],\n        )\n        detail = ModelQuerySetSchema(\n            select_related=[\"author\", \"category\"],\n            prefetch_related=[\"tags\", \"comments\", \"comments__author\"],\n        )\n        queryset_request = ModelQuerySetSchema(\n            select_related=[],\n            prefetch_related=[\"comments\"],\n        )\n        extras = [\n            ModelQuerySetExtraSchema(\n                scope=\"cards\",\n                select_related=[\"author\"],\n                prefetch_related=[],\n            )\n        ]\n</code></pre> <ul> <li><code>read</code> \u2014 applied to list operations</li> <li><code>detail</code> \u2014 applied to retrieve operations (falls back to <code>read</code> if not defined)</li> <li><code>queryset_request</code> \u2014 applied inside the <code>queryset_request</code> hook</li> <li><code>extras</code> \u2014 named scopes available via <code>QueryUtil.SCOPES</code></li> </ul>"},{"location":"tutorial/serializer/#lifecycle-hooks","title":"Lifecycle Hooks","text":"<p><code>Serializer</code> supports the same hooks as <code>ModelSerializer</code>, with one key difference: all hooks receive an <code>instance</code> parameter instead of using <code>self</code>:</p> Python<pre><code>class ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = Article\n        schema_in = serializers.SchemaModelConfig(\n            fields=[\"title\", \"content\", \"author\"],\n            customs=[(\"notify_author\", bool, True)],\n        )\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"content\", \"author\"]\n        )\n\n    @classmethod\n    async def queryset_request(cls, request):\n        \"\"\"Filter and optimize queryset per request.\"\"\"\n        return cls._meta.model.objects.select_related(\"author\")\n\n    async def custom_actions(self, payload, instance):\n        \"\"\"Execute after field assignment, before save.\"\"\"\n        if payload.get(\"notify_author\"):\n            await send_email(instance.author.email, f\"Article created: {instance.title}\")\n\n    async def post_create(self, instance):\n        \"\"\"Execute after instance creation.\"\"\"\n        await AuditLog.objects.acreate(\n            action=\"article_created\",\n            article_id=instance.id\n        )\n\n    def before_save(self, instance):\n        \"\"\"Sync hook before any save.\"\"\"\n        from django.utils.text import slugify\n        instance.slug = slugify(instance.title)\n\n    def after_save(self, instance):\n        \"\"\"Sync hook after any save.\"\"\"\n        from django.core.cache import cache\n        cache.delete(f\"article:{instance.id}\")\n\n    def on_create_before_save(self, instance):\n        \"\"\"Sync hook before creation save only.\"\"\"\n        print(f\"Creating: {instance.title}\")\n\n    def on_create_after_save(self, instance):\n        \"\"\"Sync hook after creation save only.\"\"\"\n        print(f\"Created with ID: {instance.id}\")\n\n    def on_delete(self, instance):\n        \"\"\"Sync hook after deletion.\"\"\"\n        print(f\"Deleted: {instance.title}\")\n</code></pre>"},{"location":"tutorial/serializer/#available-hooks","title":"Available Hooks","text":"Hook Type When Called Parameters <code>queryset_request(request)</code> async Before queryset building <code>request</code> <code>custom_actions(payload, i)</code> async After field assignment <code>payload</code>, <code>instance</code> <code>post_create(instance)</code> async After first save <code>instance</code> <code>before_save(instance)</code> sync Before any save <code>instance</code> <code>after_save(instance)</code> sync After any save <code>instance</code> <code>on_create_before_save(i)</code> sync Before creation save only <code>instance</code> <code>on_create_after_save(i)</code> sync After creation save only <code>instance</code> <code>on_delete(instance)</code> sync After deletion <code>instance</code> <p>Execution Order</p> <p>Create: <code>on_create_before_save()</code> \u2192 <code>before_save()</code> \u2192 <code>save()</code> \u2192 <code>on_create_after_save()</code> \u2192 <code>after_save()</code> \u2192 <code>custom_actions()</code> \u2192 <code>post_create()</code></p> <p>Update: <code>before_save()</code> \u2192 <code>save()</code> \u2192 <code>after_save()</code> \u2192 <code>custom_actions()</code></p>"},{"location":"tutorial/serializer/#connecting-to-apiviewset","title":"Connecting to APIViewSet","text":"<p>Attach your serializer to a ViewSet using <code>serializer_class</code>:</p> Python<pre><code># views.py\nfrom ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom .models import Article, Author, Tag\nfrom .serializers import ArticleSerializer, AuthorSerializer, TagSerializer\n\napi = NinjaAIO(title=\"Blog API\", version=\"1.0.0\")\n\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    serializer_class = ArticleSerializer\n\n\n@api.viewset(model=Author)\nclass AuthorViewSet(APIViewSet):\n    serializer_class = AuthorSerializer\n\n\n@api.viewset(model=Tag)\nclass TagViewSet(APIViewSet):\n    serializer_class = TagSerializer\n</code></pre> <p>That's it \u2014 full CRUD endpoints are generated automatically, using your serializer's schemas, query optimizations, and lifecycle hooks.</p>"},{"location":"tutorial/serializer/#complete-example","title":"Complete Example","text":"<p>Here's a full example with models, serializers, and views:</p> Complete blog API with Serializer (click to expand) Python<pre><code># models.py\nfrom django.db import models\n\n\nclass Author(models.Model):\n    name = models.CharField(max_length=200)\n    email = models.EmailField(unique=True)\n    bio = models.TextField(blank=True)\n\n    class Meta:\n        ordering = [\"name\"]\n\n    def __str__(self):\n        return self.name\n\n\nclass Category(models.Model):\n    name = models.CharField(max_length=100)\n    slug = models.SlugField(unique=True)\n\n    def __str__(self):\n        return self.name\n\n\nclass Tag(models.Model):\n    name = models.CharField(max_length=50, unique=True)\n\n    def __str__(self):\n        return self.name\n\n\nclass Article(models.Model):\n    title = models.CharField(max_length=200)\n    slug = models.SlugField(unique=True, blank=True)\n    content = models.TextField()\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"articles\")\n    category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True)\n    tags = models.ManyToManyField(Tag, related_name=\"articles\", blank=True)\n    is_published = models.BooleanField(default=False)\n    views = models.IntegerField(default=0)\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    class Meta:\n        ordering = [\"-created_at\"]\n\n    def __str__(self):\n        return self.title\n</code></pre> Python<pre><code># serializers.py\nfrom ninja_aio.models import serializers\nfrom ninja_aio.schemas.helpers import ModelQuerySetSchema\nfrom django.utils.text import slugify\nfrom .models import Author, Category, Tag, Article\n\n\nclass AuthorSerializer(serializers.Serializer):\n    class Meta:\n        model = Author\n        schema_in = serializers.SchemaModelConfig(\n            fields=[\"name\", \"email\"],\n            optionals=[(\"bio\", str)],\n        )\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"name\", \"email\", \"bio\"]\n        )\n        schema_update = serializers.SchemaModelConfig(\n            optionals=[(\"name\", str), (\"bio\", str)]\n        )\n\n\nclass CategorySerializer(serializers.Serializer):\n    class Meta:\n        model = Category\n        schema_in = serializers.SchemaModelConfig(fields=[\"name\", \"slug\"])\n        schema_out = serializers.SchemaModelConfig(fields=[\"id\", \"name\", \"slug\"])\n\n\nclass TagSerializer(serializers.Serializer):\n    class Meta:\n        model = Tag\n        schema_in = serializers.SchemaModelConfig(fields=[\"name\"])\n        schema_out = serializers.SchemaModelConfig(fields=[\"id\", \"name\"])\n\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = Article\n        schema_in = serializers.SchemaModelConfig(\n            fields=[\"title\", \"content\", \"author\", \"category\"],\n            optionals=[\n                (\"tags\", list[int]),\n                (\"is_published\", bool),\n            ],\n            customs=[(\"notify_subscribers\", bool, True)],\n        )\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\n                \"id\", \"title\", \"slug\", \"content\",\n                \"author\", \"category\", \"tags\",\n                \"is_published\", \"views\", \"created_at\",\n            ],\n            customs=[\n                (\"word_count\", int, lambda obj: len(obj.content.split())),\n                (\"reading_time\", int, lambda obj: max(1, len(obj.content.split()) // 200)),\n            ]\n        )\n        schema_update = serializers.SchemaModelConfig(\n            optionals=[\n                (\"title\", str),\n                (\"content\", str),\n                (\"category\", int),\n                (\"tags\", list[int]),\n                (\"is_published\", bool),\n            ]\n        )\n        relations_serializers = {\n            \"author\": AuthorSerializer,\n            \"category\": CategorySerializer,\n            \"tags\": TagSerializer,\n        }\n\n    class QuerySet:\n        read = ModelQuerySetSchema(\n            select_related=[\"author\", \"category\"],\n            prefetch_related=[\"tags\"],\n        )\n\n    def before_save(self, instance):\n        if not instance.slug:\n            instance.slug = slugify(instance.title)\n\n    async def custom_actions(self, payload, instance):\n        if payload.get(\"notify_subscribers\"):\n            # Implement your notification logic\n            pass\n\n    async def post_create(self, instance):\n        print(f\"Article created: {instance.title}\")\n</code></pre> Python<pre><code># views.py\nfrom ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom .models import Article, Author, Category, Tag\nfrom .serializers import (\n    ArticleSerializer, AuthorSerializer,\n    CategorySerializer, TagSerializer,\n)\n\napi = NinjaAIO(title=\"Blog API\", version=\"1.0.0\")\n\n\n@api.viewset(model=Author)\nclass AuthorViewSet(APIViewSet):\n    serializer_class = AuthorSerializer\n\n\n@api.viewset(model=Category)\nclass CategoryViewSet(APIViewSet):\n    serializer_class = CategorySerializer\n\n\n@api.viewset(model=Tag)\nclass TagViewSet(APIViewSet):\n    serializer_class = TagSerializer\n\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    serializer_class = ArticleSerializer\n</code></pre>"},{"location":"tutorial/serializer/#serializer-vs-modelserializer","title":"Serializer vs. ModelSerializer","text":"Feature ModelSerializer Serializer Model class Custom base class Plain Django model Configuration Nested classes on model Separate <code>Meta</code> class Lifecycle hooks Instance methods (<code>self</code>) Receives <code>instance</code> parameter Relation serializers Auto-resolved Explicit via <code>relations_serializers</code> Best for New projects Existing projects <p>Both approaches fully support nested relations, query optimization, lifecycle hooks, and <code>APIViewSet</code> integration.</p> <p>Ready to build your API?</p> <p>Now continue with CRUD views, authentication, and filtering \u2014 they work the same way!</p> <p>Step 2: Create CRUD Views </p> <ul> <li> <p> API Reference</p> <p> Serializer \u00b7  APIViewSet</p> </li> </ul>"},{"location":"tutorial/serializer/#what-youve-learned","title":"What You've Learned","text":"<ul> <li> Creating serializers with <code>SchemaModelConfig</code></li> <li> Defining create, read, detail, and update schemas</li> <li> Working with ForeignKey, M2M, and reverse relations</li> <li> Adding custom computed fields</li> <li> Configuring query optimizations</li> <li> Implementing lifecycle hooks with <code>instance</code> parameter</li> <li> Connecting serializers to <code>APIViewSet</code></li> </ul>"}]}