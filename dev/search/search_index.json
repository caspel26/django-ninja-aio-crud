{"config":{"lang":["en"],"separator":"[\\\\s\\\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83e\udd77 Django Ninja Aio CRUD","text":"<p>Django Ninja Aio CRUD is a powerful async REST framework built on top of Django Ninja. It provides automatic CRUD operations, class-based views, and built-in utilities to make API development faster and cleaner.</p>"},{"location":"#key-features","title":"\u2728 Key Features","text":"<ul> <li>\ud83d\ude80 Fully Async - Built for Django's async ORM</li> <li>\ud83d\udd04 Automatic CRUD - Generate complete REST APIs with minimal code</li> <li>\ud83d\udcdd ModelSerializer - Define schemas directly on models</li> <li>\ud83c\udfaf Class-Based Views - Clean, organized view architecture</li> <li>\ud83d\udd10 JWT Authentication - Built-in async JWT bearer authentication</li> <li>\ud83d\udcc4 Auto Documentation - OpenAPI/Swagger UI out of the box</li> <li>\ud83d\udd17 Relationship Support - Automatic nested serialization (FK, M2M, reverse relations)</li> <li>\ud83d\udcca Pagination - Built-in async pagination support</li> <li>\u26a1 Performance - Using <code>orjson</code> for fast JSON serialization</li> </ul>"},{"location":"#why-django-ninja-aio-crud","title":"\ud83c\udfaf Why Django Ninja Aio CRUD?","text":"<p>Traditional Django REST development requires:</p> <ul> <li>Separate serializer classes</li> <li>Manual CRUD view implementation</li> <li>Repetitive boilerplate code</li> <li>Complex relationship handling</li> </ul> <p>Django Ninja Aio CRUD eliminates this complexity:</p> Traditional ApproachDjango Ninja Aio CRUD Python<pre><code># schema.py\nclass UserSchemaOut(ModelSchema)\n    class Meta:\n        model = User\n        fields = ['id', 'username', 'email']\n\nclass UserSchemaIn(ModelSchema):\n    class Meta:\n        model = User\n        fields = ['username', 'email', 'password']\n\n# views.py\n@api.get(\"/users\", response={200: list[UserSchemaOut]})\nasync def list_users(request):\n    return [user async for user in User.objects.select_related().all()]\n\n@api.post(\"/users/\", response={201: UserSchemaOut})\nasync def create_user(request, data: UserSchemaIn):\n    user = await User.objects.select_related().acreate(**data.model_dump())\n    return 201, user\n\n\n# ... more views for retrieve, update, delete\n</code></pre> Python<pre><code># models.py\nclass User(ModelSerializer):\n    username = models.CharField(max_length=150)\n    email = models.EmailField()\n    password = models.CharField(max_length=128)\n\n    class ReadSerializer:\n        fields = [\"id\", \"username\", \"email\"]\n\n    class CreateSerializer:\n        fields = [\"username\", \"email\", \"password\"]\n\n    class UpdateSerializer:\n        optionals = [(\"email\", str)]\n\n# views.py\nclass UserViewSet(APIViewSet):\n    model = User\n    api = api\n\nUserViewSet().add_views_to_route()\n# Done! List, Create, Retrieve, Update, Delete endpoints ready\n</code></pre>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":"<p>Explore detailed documentation for each component:</p>"},{"location":"#models","title":"Models","text":"<ul> <li>Model Serializer - Schema generation and serialization</li> <li>Model Util - Async CRUD utilities</li> </ul>"},{"location":"#views","title":"Views","text":"<ul> <li>API View - Simple custom views</li> <li>API View Set - Complete CRUD operations</li> </ul>"},{"location":"#advanced-topics","title":"Advanced Topics","text":"<ul> <li>Authentication - JWT and custom auth</li> <li>Pagination - Customize pagination behavior</li> </ul>"},{"location":"#query-optimization-and-schemas","title":"Query optimization and schemas","text":"<ul> <li>Declare query optimizations on models via <code>class QuerySet</code> (read, queryset_request, extras).</li> <li>Use <code>QueryUtil</code> to apply scope-based <code>select_related</code> / <code>prefetch_related</code>.</li> <li>Standard query schemas:</li> <li><code>ObjectsQuerySchema(filters=..., select_related=..., prefetch_related=...)</code></li> <li><code>ObjectQuerySchema(getters=..., select_related=..., prefetch_related=...)</code></li> <li><code>QuerySchema(filters=... | getters=...)</code></li> </ul> <p>ViewSets internally use these to:</p> <ul> <li>Build optimized querysets in list/retrieve.</li> <li>Serialize via <code>list_read_s</code> and <code>read_s</code>.</li> </ul> <p>Example:</p> Python<pre><code>items = await ModelUtil(Article).list_read_s(\n    Article.generate_read_s(),\n    request,\n    query_data=ObjectsQuerySchema(filters={\"category\": 3}),\n    is_for_read=True,\n)\n</code></pre>"},{"location":"#example-complete-blog-api","title":"\ud83d\udca1 Example: Complete Blog API","text":"<p>Here's a real-world example with relationships:</p> Python<pre><code># models.py\nfrom django.db import models\nfrom ninja_aio.models import ModelSerializer\n\n\nclass Author(ModelSerializer):\n    name = models.CharField(max_length=200)\n    email = models.EmailField(unique=True)\n    bio = models.TextField(blank=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"email\", \"bio\", \"articles\"]\n\n    class CreateSerializer:\n        fields = [\"name\", \"email\"]\n        optionals = [(\"bio\", str)]\n\n\nclass Category(ModelSerializer):\n    name = models.CharField(max_length=100)\n    slug = models.SlugField(unique=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"slug\"]\n\n    class CreateSerializer:\n        fields = [\"name\", \"slug\"]\n\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    slug = models.SlugField(unique=True)\n    content = models.TextField()\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"articles\")\n    category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True)\n    tags = models.ManyToManyField('Tag', related_name=\"articles\")\n    is_published = models.BooleanField(default=False)\n    views = models.IntegerField(default=0)\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    class ReadSerializer:\n        fields = [\n            \"id\", \"title\", \"slug\", \"content\",\n            \"author\", \"category\", \"tags\",\n            \"is_published\", \"views\", \"created_at\"\n        ]\n\n    class CreateSerializer:\n        fields = [\"title\", \"slug\", \"content\", \"author\", \"category\"]\n        customs = [(\"notify_subscribers\", bool, True)]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"title\", str),\n            (\"content\", str),\n            (\"is_published\", bool),\n        ]\n\n    async def custom_actions(self, payload: dict):\n        if payload.get(\"notify_subscribers\"):\n            # Send notifications\n            await notify_new_article(self)\n\n\nclass Tag(ModelSerializer):\n    name = models.CharField(max_length=50, unique=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\"]\n\n\n# views.py\nfrom ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom .models import Author, Category, Article, Tag\n\napi = NinjaAIO(title=\"Blog API\", version=\"1.0.0\")\n\n\nclass AuthorViewSet(APIViewSet):\n    model = Author\n    api = api\n\n\nclass CategoryViewSet(APIViewSet):\n    model = Category\n    api = api\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    query_params = {\n        \"is_published\": (bool, None),\n        \"category\": (int, None),\n        \"author\": (int, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        if filters.get(\"is_published\") is not None:\n            queryset = queryset.filter(is_published=filters[\"is_published\"])\n        if filters.get(\"category\"):\n            queryset = queryset.filter(category_id=filters[\"category\"])\n        if filters.get(\"author\"):\n            queryset = queryset.filter(author_id=filters[\"author\"])\n        return queryset\n\n\nclass TagViewSet(APIViewSet):\n    model = Tag\n    api = api\n\n\n# Register all views\nAuthorViewSet().add_views_to_route()\nCategoryViewSet().add_views_to_route()\nArticleViewSet().add_views_to_route()\nTagViewSet().add_views_to_route()\n</code></pre> <p>This creates a complete blog API with:</p> <ul> <li>4 models with relationships</li> <li>Automatic nested serialization</li> <li>Query filtering</li> <li>Custom actions</li> <li>Full CRUD operations for all models</li> </ul>"},{"location":"#key-concepts","title":"\ud83c\udf1f Key Concepts","text":""},{"location":"#modelserializer","title":"ModelSerializer","text":"<p>Central to Django Ninja Aio CRUD - defines schemas directly on models:</p> Python<pre><code>class User(ModelSerializer):\n    username = models.CharField(max_length=150)\n\n    class ReadSerializer:\n        fields = [\"id\", \"username\"]  # Response schema\n\n    class CreateSerializer:\n        fields = [\"username\"]  # Input schema\n\n    class UpdateSerializer:\n        optionals = [(\"username\", str)]  # Partial update schema\n</code></pre>"},{"location":"#apiviewset","title":"APIViewSet","text":"<p>Automatically generates complete CRUD endpoints:</p> Python<pre><code>class UserViewSet(APIViewSet):\n    model = User\n    api = api\n    # Generates: List, Create, Retrieve, Update, Delete\n</code></pre>"},{"location":"#custom-views","title":"Custom Views","text":"<p>Extend with custom endpoints:</p> Python<pre><code>class UserViewSet(APIViewSet):\n    model = User\n    api = api\n\n    def views(self):\n        @self.router.post(\"/{pk}/activate/\")\n        async def activate(request, pk: int):\n            user = await User.objects.aget(pk=pk)\n            user.is_active = True\n            await user.asave()\n            return {\"message\": \"User activated\"}\n</code></pre>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"#support","title":"\u2615 Support","text":"<p>If you find Django Ninja Aio CRUD useful, consider supporting the project:</p> <p></p>"},{"location":"#links","title":"\ud83d\udd17 Links","text":"<ul> <li>Documentation: https://django-ninja-aio.com</li> <li>GitHub: https://github.com/caspel26/django-ninja-aio-crud</li> <li>PyPI: https://pypi.org/project/django-ninja-aio-crud/</li> <li>Django Ninja: https://django-ninja.dev/</li> </ul> <p>Built with \u2764\ufe0f using Django Ninja</p>"},{"location":"auth/","title":"JWT Authentication and AsyncJwtBearer","text":"<p>This page documents the JWT helpers and the <code>AsyncJwtBearer</code> class in <code>ninja_aio/auth.py</code>, including configuration, validation, and usage in Django Ninja.</p>"},{"location":"auth/#overview","title":"Overview","text":"<ul> <li><code>AsyncJwtBearer</code>: Asynchronous HTTP Bearer auth that verifies JWTs, validates claims via a registry, and delegates user resolution to <code>auth_handler</code>.</li> <li>Helpers:</li> <li><code>validate_key</code>: Ensures JWK keys are present and of the correct type.</li> <li><code>validate_mandatory_claims</code>: Ensures <code>iss</code> and <code>aud</code> are present (from settings if not provided).</li> <li><code>encode_jwt</code>: Signs a JWT with time-based claims (<code>iat</code>, <code>nbf</code>, <code>exp</code>) and mandatory <code>iss/aud</code>.</li> <li><code>decode_jwt</code>: Verifies and decodes a JWT with a public key and allowed algorithms.</li> </ul>"},{"location":"auth/#configuration-without-settings","title":"Configuration without settings","text":"<p>Settings are not required. Provide keys and claims explicitly:</p> <ul> <li>Pass <code>private_key</code> to <code>encode_jwt</code> and <code>public_key</code> to <code>decode_jwt</code>/<code>AsyncJwtBearer.jwt_public</code>.</li> <li>Include <code>iss</code> and <code>aud</code> directly in the <code>claims</code> you encode if you are not using settings.</li> </ul> <p>Example key usage without settings:</p> Python<pre><code># ...existing code...\nfrom joserfc import jwk\nfrom ninja_aio.auth import encode_jwt, decode_jwt\n\nprivate_key = jwk.RSAKey.import_key(open(\"priv.jwk\").read())\npublic_key = jwk.RSAKey.import_key(open(\"pub.jwk\").read())\n\ntoken = encode_jwt(\n    claims={\"sub\": \"123\", \"iss\": \"https://auth.example\", \"aud\": \"my-api\"},\n    duration=3600,\n    private_key=private_key,\n    algorithm=\"RS256\",\n)\n\ndecoded = decode_jwt(token=token, public_key=public_key, algorithms=[\"RS256\"])\n# ...existing code...\n</code></pre>"},{"location":"auth/#mandatory-claims","title":"Mandatory claims","text":"<p>The library enforces <code>iss</code> and <code>aud</code> via <code>JWT_MANDATORY_CLAIMS</code>. If you do not use settings, include them in the payload you pass to <code>encode_jwt</code>.</p>"},{"location":"auth/#configuration-with-settings-optional","title":"Configuration with settings (optional)","text":"<p>You can centralize configuration in Django settings and omit explicit keys/claims:</p> <ul> <li><code>JWT_PRIVATE_KEY</code>: jwk.RSAKey or jwk.ECKey for signing</li> <li><code>JWT_PUBLIC_KEY</code>: jwk.RSAKey or jwk.ECKey for verification</li> <li><code>JWT_ISSUER</code>: issuer string</li> <li><code>JWT_AUDIENCE</code>: audience string</li> </ul> <p>When present:</p> <ul> <li><code>encode_jwt</code> reads <code>JWT_PRIVATE_KEY</code> if <code>private_key</code> is not passed, and fills <code>iss</code>/<code>aud</code> via <code>validate_mandatory_claims</code> if missing.</li> <li><code>decode_jwt</code> reads <code>JWT_PUBLIC_KEY</code> if <code>public_key</code> is not passed.</li> <li><code>AsyncJwtBearer</code> can read the public key from settings by assigning <code>jwt_public = settings.JWT_PUBLIC_KEY</code>.</li> </ul> Python<pre><code># settings.py (example)\nJWT_PRIVATE_KEY = jwk.RSAKey.import_key(open(\"priv.jwk\").read())\nJWT_PUBLIC_KEY = jwk.RSAKey.import_key(open(\"pub.jwk\").read())\nJWT_ISSUER = \"https://auth.example\"\nJWT_AUDIENCE = \"my-api\"\n</code></pre> <p>Usage without passing keys/claims explicitly:</p> Python<pre><code>from ninja_aio.auth import encode_jwt, decode_jwt\n# claims missing iss/aud will be completed from settings\ntoken = encode_jwt(claims={\"sub\": \"123\"}, duration=3600)\n\ndecoded = decode_jwt(token=token)  # uses settings.JWT_PUBLIC_KEY\n</code></pre> <p>AsyncJwtBearer wired to settings:</p> Python<pre><code>from django.conf import settings\nfrom ninja_aio.auth import AsyncJwtBearer\n\nclass SettingsBearer(AsyncJwtBearer):\n    jwt_public = settings.JWT_PUBLIC_KEY\n    claims = {\n        \"iss\": {\"value\": settings.JWT_ISSUER},\n        \"aud\": {\"value\": settings.JWT_AUDIENCE},\n        # Optionally require time-based claims:\n        # \"exp\": {\"essential\": True},\n        # \"nbf\": {\"essential\": True},\n    }\n\n    async def auth_handler(self, request):\n        sub = self.dcd.claims.get(\"sub\")\n        return {\"user_id\": sub}\n</code></pre>"},{"location":"auth/#asyncjwtbearer","title":"AsyncJwtBearer","text":""},{"location":"auth/#key-points","title":"Key points","text":"<ul> <li><code>jwt_public</code>: Must be a JWK (RSA or EC) used to verify signatures.</li> <li><code>claims</code>: Dict passed to <code>jwt.JWTClaimsRegistry</code> defining validations (e.g., <code>iss</code>, <code>aud</code>, <code>exp</code>, <code>nbf</code>).</li> <li><code>algorithms</code>: Allowed algorithms (default <code>[\"RS256\"]</code>).</li> <li><code>dcd</code>: Set after successful decode; instance of <code>jwt.Token</code> containing <code>header</code> and <code>claims</code>.</li> <li><code>get_claims()</code>: Builds the claim registry from <code>claims</code>.</li> <li><code>validate_claims(claims)</code>: Validates decoded claims; raises <code>jose.errors.JoseError</code> on failure.</li> <li><code>auth_handler(request)</code>: Async hook to resolve application user given the decoded token (<code>self.dcd</code>).</li> <li><code>authenticate(request, token)</code>: Decodes, validates, and delegates to <code>auth_handler</code>. Returns user or <code>False</code>.</li> </ul>"},{"location":"auth/#example","title":"Example","text":"Python<pre><code>from joserfc import jwk\nfrom ninja import NinjaAPI\nfrom ninja_aio.auth import AsyncJwtBearer\n\nclass MyBearer(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(open(\"pub.jwk\").read())\n    claims = {\n        \"iss\": {\"value\": \"https://auth.example\"},\n        \"aud\": {\"value\": \"my-api\"},\n        # You can add time-based checks if needed:\n        # \"exp\": {\"essential\": True},\n        # \"nbf\": {\"essential\": True},\n    }\n\n    async def auth_handler(self, request):\n        sub = self.dcd.claims.get(\"sub\")\n        return {\"user_id\": sub}\n\napi = NinjaAPI()\n\n@api.get(\"/secure\", auth=MyBearer())\ndef secure_endpoint(request):\n    return {\"ok\": True}\n</code></pre>"},{"location":"auth/#claims-registry-helper","title":"Claims registry helper","text":"<p>You can construct and reuse a registry from your class-level <code>claims</code>:</p> Python<pre><code>registry = MyBearer.get_claims()\n# registry.validate(token_claims)  # raises JoseError on failure\n</code></pre>"},{"location":"auth/#encode_jwt","title":"encode_jwt","text":"<p>Signs a JWT with safe defaults:</p> <ul> <li>Adds <code>iat</code>, <code>nbf</code>, and <code>exp</code> using timezone-aware <code>timezone.now()</code>.</li> <li>Ensures <code>iss</code> and <code>aud</code> are present via <code>validate_mandatory_claims</code> (include them in <code>claims</code> if not using settings).</li> <li>Header includes <code>alg</code>, <code>typ=JWT</code>, and optional <code>kid</code>.</li> </ul> Python<pre><code>from joserfc import jwk\nfrom ninja_aio.auth import encode_jwt\n\nprivate_key = jwk.RSAKey.import_key(open(\"priv.jwk\").read())\n\nclaims = {\"sub\": \"123\", \"scope\": \"read\", \"iss\": \"https://auth.example\", \"aud\": \"my-api\"}\ntoken = encode_jwt(\n    claims=claims,\n    duration=3600,\n    private_key=private_key,\n    algorithm=\"RS256\",\n)\n</code></pre>"},{"location":"auth/#decode_jwt","title":"decode_jwt","text":"<p>Verifies and decodes a JWT with a public key and algorithm allow-list.</p> Python<pre><code>from joserfc import jwk\nfrom ninja_aio.auth import decode_jwt\n\npublic_key = jwk.RSAKey.import_key(open(\"pub.jwk\").read())\n\ndecoded = decode_jwt(\n    token=token,\n    public_key=public_key,\n    algorithms=[\"RS256\"],\n)\n\nclaims = decoded.claims\nsub = claims.get(\"sub\")\n</code></pre>"},{"location":"auth/#validate_key","title":"validate_key","text":"<p>If you do not use settings, pass keys directly. <code>validate_key</code> will raise <code>ValueError</code> only when neither an explicit key nor a configured setting is provided.</p> Python<pre><code>from ninja_aio.auth import validate_key\nfrom joserfc import jwk\n\npkey = validate_key(jwk.RSAKey.import_key(open(\"priv.jwk\").read()), \"JWT_PRIVATE_KEY\")\n</code></pre>"},{"location":"auth/#validate_mandatory_claims","title":"validate_mandatory_claims","text":"<p>Ensures <code>iss</code> and <code>aud</code> are present; if settings are not used, include them in your input claims.</p> Python<pre><code>from ninja_aio.auth import validate_mandatory_claims\n\nclaims = {\"sub\": \"123\", \"iss\": \"https://auth.example\", \"aud\": \"my-api\"}\nclaims = validate_mandatory_claims(claims)\n</code></pre>"},{"location":"auth/#error-handling","title":"Error handling","text":"<ul> <li><code>authenticate</code> returns <code>False</code> on decode (<code>ValueError</code>) or claim validation failure (<code>JoseError</code>). Map this to 401/403 in your views as needed.</li> <li><code>validate_claims</code> raises <code>jose.errors.JoseError</code> for invalid claims.</li> <li><code>encode_jwt</code> and <code>decode_jwt</code> raise <code>ValueError</code> for missing/invalid keys or configuration.</li> </ul>"},{"location":"auth/#security-notes","title":"Security notes","text":"<ul> <li>Rotate keys and use <code>kid</code> headers to support key rotation.</li> <li>Validate critical claims (<code>exp</code>, <code>nbf</code>, <code>iss</code>, <code>aud</code>) via the registry.</li> <li>Do not log raw tokens or sensitive claims.</li> </ul>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions. Ways to help:</p> <ol> <li>Report Bugs \u2013 Open an issue on GitHub.</li> <li>Suggest Features \u2013 Share ideas in issues or discussions.</li> <li>Submit PRs \u2013 Improve code, tests, or docs.</li> <li>Improve Docs \u2013 Clarify, expand, or add examples.</li> <li>Add Tests \u2013 Increase coverage and reliability.</li> <li>Review PRs \u2013 Provide constructive feedback.</li> </ol>"},{"location":"contributing/#support-the-project","title":"\u2b50 Support the Project","text":"<p>If this project helps you, please give it a GitHub star to show support.</p>"},{"location":"contributing/#buy-me-a-coffee","title":"\u2615 Buy Me a Coffee","text":"<p>Optional tip: Buy Me a Coffee.</p>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<ul> <li>Keep PRs focused and small.</li> <li>Follow existing code style.</li> <li>Add or update tests when relevant.</li> <li>Update docs for user-facing changes.</li> <li>Link related issue in the PR description.</li> </ul>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"Bash<pre><code>git clone https://github.com/caspel26/django-ninja-aio-crud.git\ncd django-ninja-aio-crud\npython -m venv .venv\nsource .venv/bin/activate\npip install -r requirements.dev.txt\n</code></pre>"},{"location":"contributing/#issue-reports","title":"Issue Reports","text":"<p>Include: - Python/Django versions - Steps to reproduce - Expected vs actual behavior - Tracebacks or logs (if any)</p> <p>Thank you for helping improve the project.</p>"},{"location":"release_notes/","title":"Release NotesRelease NotesRelease NotesRelease NotesRelease NotesRelease NotesRelease NotesRelease NotesRelease NotesRelease NotesDisable ops per relation if needed:M2MRelationSchema(model=Tag, related_name=\"tags\", add=False, remove=False, get=True)BeforeAfterBefore (v0.11.0)After (v0.11.1)ChangelogWhat's Changed","text":"VersionDateSummaryv2.1.0diff2026-01-02Release notes [2.1.0] - 2026-01-01 \u2728 Added <ul> <li>Views:</li> <li>ReadOnlyViewSet: list and retrieve-only endpoints.</li> <li>WriteOnlyViewSet: create, update, and delete-only endpoints.</li> <li>Exported via <code>ninja_aio.views.__init__</code> for cleaner imports.</li> <li>Mixins:</li> <li>New filtering mixins under <code>ninja_aio/views/mixins.py</code>: IcontainsFilterViewSetMixin, BooleanFilterViewSetMixin, NumericFilterViewSetMixin, DateFilterViewSetMixin, and specialized Greater/Less variants.</li> <li>Auth docs:</li> <li>New <code>docs/auth.md</code> with JWT helpers and <code>AsyncJwtBearer</code> usage and configuration.</li> <li>Tests:</li> <li>Extended test model with <code>age</code>, <code>active</code>, and <code>active_from</code> fields.</li> <li>Added viewset tests for mixins (icontains, boolean, numeric, date comparisons).</li> <li>Added auth tests for JWT encode/decode and AsyncJwtBearer claim validation.</li> <li>Docs navigation:</li> <li>Added Mixins page and JWT &amp; AsyncJwtBearer page to MkDocs nav.</li> <li>MkDocs <code>mike</code> config sets <code>default: latest</code>.</li> </ul> \ud83d\udee0 Changed <ul> <li>Docs workflow (<code>.github/workflows/docs.yml</code>):</li> <li>Safer deletion: requires explicit <code>delete_version</code> choice and <code>delete_confirm</code>, protects <code>latest</code>, <code>stable</code>, and current default.</li> <li><code>make_latest</code> default set to false.</li> <li>Coverage workflow:</li> <li>Bump <code>codecov/codecov-action</code> from v5.5.1 to v5.5.2.</li> <li>API helpers:</li> <li>Use <code>decorate_view</code> to compose <code>unique_view</code> and <code>paginate</code> for related GET endpoints.</li> <li>APIViewSet (imports and behavior):</li> <li>Module reorganized to <code>ninja_aio/views/api.py</code> with updated internal imports.</li> <li><code>get_schemas</code>: generates schemas only if missing when model is a <code>ModelSerializerMeta</code>, else returns explicitly set schemas.</li> <li>Hook docs clarified to allow sync or async handlers for query params.</li> <li>Auth:</li> <li><code>encode_jwt</code>: header now includes <code>kid</code> only when present (conditional merge).</li> <li>Docs:</li> <li><code>docs/api/views/api_view_set.md</code> updated to document ReadOnlyViewSet and WriteOnlyViewSet.</li> <li><code>docs/mixins.md</code> aligned with implemented mixins and examples.</li> </ul> \ud83d\udcdd Documentation <ul> <li>New:</li> <li>JWT &amp; AsyncJwtBearer guide with examples for settings and direct JWK usage.</li> <li>Updated:</li> <li>Mixins reference to match implemented classes and recommended query param types.</li> <li>APIViewSet docs extended with ReadOnly/WriteOnly usage.</li> </ul> \u26a0 Notes / Potential Impact <ul> <li>Docs deployment:</li> <li>Deletion requires explicit confirmation and cannot remove protected aliases or current default.</li> <li>Mixins:</li> <li>Date filters expect values that implement <code>isoformat</code>; prefer Pydantic <code>date</code>/<code>datetime</code> in query params.</li> </ul> \ud83d\udd0d Migration / Action <ol> <li>Update imports:</li> <li><code>from ninja_aio.views import APIViewSet, ReadOnlyViewSet, WriteOnlyViewSet</code></li> <li><code>from ninja_aio.views import mixins</code> for filter mixins.</li> <li>For related list endpoints using custom decorators, consider adopting <code>decorate_view</code> for consistent composition.</li> <li>If using JWT:</li> <li>Optionally set <code>JWT_PRIVATE_KEY</code>, <code>JWT_PUBLIC_KEY</code>, <code>JWT_ISSUER</code>, <code>JWT_AUDIENCE</code> in Django settings.</li> <li>Validate claims via <code>AsyncJwtBearer.claims</code> registry and verify allowed algorithms.</li> <li>Review docs workflow inputs before deleting versions; use <code>delete_confirm: true</code>.</li> </ol>v2.0.0diff2025-12-16Release notes [2.0.0] - 2025-12-16 \u2728 Added <ul> <li>QueryUtil and query scopes:</li> <li>New <code>QueryUtil</code> with <code>SCOPES</code> (READ, QUERYSET_REQUEST, plus extras) and <code>apply_queryset_optimizations</code>.</li> <li><code>ModelSerializer.query_util</code> bound per model via <code>__init_subclass__</code>.</li> <li><code>ModelSerializer.QuerySet</code> supports <code>read</code>, <code>queryset_request</code>, <code>extras</code>.</li> <li>Query schemas:</li> <li><code>QuerySchema</code>, <code>ObjectQuerySchema</code>, <code>ObjectsQuerySchema</code>, <code>ModelQuerySetSchema</code>, <code>ModelQuerySetExtraSchema</code>, <code>QueryUtilBaseScopesSchema</code>.</li> <li>ModelUtil:</li> <li><code>get_objects(...)</code>: optimized queryset fetching with filters and select/prefetch hints.</li> <li><code>get_object(...)</code>: single-object retrieval by pk or getters with optimizations.</li> <li><code>read_s(...)</code> and <code>list_read_s(...)</code>: serialize instances or auto-fetch via query schemas.</li> <li>Relation discovery helpers: <code>get_select_relateds()</code>, <code>get_reverse_relations()</code>.</li> <li>PK type resolution: <code>pk_field_type</code> with helpful error for unknown field types.</li> <li>ManyToManyAPI:</li> <li>GET related endpoints return <code>{items: [...], count: N}</code>.</li> <li>Relation filter handlers accept sync or async functions.</li> <li>Related items use <code>ModelUtil.list_read_s</code> for serialization.</li> <li>Per-relation single-object resolution handler for POST: <code>&lt;related_name&gt;_query_handler(...)</code>.</li> <li>Schemas modularization:</li> <li>New modules: <code>ninja_aio/schemas/api.py</code>, <code>ninja_aio/schemas/generics.py</code>, and exported names under <code>ninja_aio/schemas/__init__.py</code>.</li> <li>Decorators:</li> <li><code>decorate_view</code> utility to compose multiple decorators (sync/async), skipping <code>None</code>.</li> <li><code>APIViewSet.extra_decorators</code> via <code>DecoratorsSchema</code> for per-operation decoration.</li> <li>Renderer:</li> <li>ORJSON renderer option via <code>settings.NINJA_AIO_ORJSON_RENDERER_OPTION</code> (bitmask, supports <code>|</code>).</li> </ul> \ud83d\udee0 Changed <ul> <li>APIViewSet:</li> <li>List uses <code>ModelUtil.get_objects</code> and <code>list_read_s</code> with read optimizations; filter hooks retained.</li> <li>Retrieve uses <code>read_s</code> with <code>QuerySchema(getters={\"pk\": ...})</code>.</li> <li>Path PK schema type inferred from model PK via <code>ModelUtil.pk_field_type</code>.</li> <li>Default read query data comes from <code>ModelSerializer.QuerySet.read</code> via <code>query_util</code>.</li> <li>Built-ins and custom decorators composed with <code>decorate_view</code> (e.g., <code>paginate</code>, <code>unique_view</code>, extras).</li> <li>ModelSerializer:</li> <li>Binds <code>util = ModelUtil(cls)</code> and <code>query_util = QueryUtil(cls)</code> to subclasses.</li> <li><code>queryset_request</code> applies configured optimizations from <code>QuerySet.queryset_request</code>.</li> <li>ModelUtil internals:</li> <li>Unified <code>_apply_query_optimizations</code> merges explicit select/prefetch with auto-discovered relations when <code>is_for_read=True</code>.</li> <li>Serialization paths standardized through internal helpers; <code>read_s</code>/<code>list_read_s</code> accept <code>schema</code> first.</li> <li>Auth:</li> <li><code>AsyncJwtBearer.verify_token</code> simplifies error handling; drops explicit <code>AuthError</code>.</li> <li>Imports:</li> <li><code>ManyToManyAPI</code> consumed from <code>ninja_aio/helpers/api.py</code>.</li> <li>Runtime requirements:</li> <li>Upper bounds added: <code>django-ninja &lt;=1.5.1</code>, <code>joserfc &lt;=1.4.1</code>, <code>orjson &lt;=3.11.5</code>.</li> <li>Docs and site:</li> <li>MkDocs/mike integration for versioned docs; new workflow <code>docs.yml</code>.</li> </ul> \ud83d\udd34 Breaking Changes <ul> <li>Path PK schema type:</li> <li>PK type is inferred from the model PK. Code relying on <code>int | str</code> in path schemas may need adjustments.</li> <li>ManyToMany GET response shape:</li> <li>Response changed from a plain list to <code>{items: [...], count: N}</code>. Clients must adapt parsing.</li> <li>Import paths:</li> <li>Schema helpers moved under <code>ninja_aio/schemas/helpers.py</code> and re-exported by <code>ninja_aio/schemas/__init__.py</code>.</li> <li><code>ManyToManyAPI</code> import is now <code>from ninja_aio.helpers.api import ManyToManyAPI</code>.</li> <li>ModelUtil read API:</li> <li><code>read_s</code> and <code>list_read_s</code> signatures accept <code>schema</code> first and support <code>instance</code> or <code>query_data</code>. Code passing <code>(request, obj, schema)</code> must switch to <code>(schema, request, instance=obj)</code>.</li> </ul> \ud83d\udcdd Documentation <ul> <li>Updated:</li> <li>ModelUtil reference: QuerySet config, QueryUtil, query schemas, <code>get_objects</code>, <code>get_object</code>, <code>read_s</code>, <code>list_read_s</code>.</li> <li>APIViewSet: list/retrieve flow, PK type inference, M2M GET envelope, async/sync filter handlers, operation decorators.</li> <li>Tutorial (model): QuerySet config and <code>query_util</code> examples; fetch/serialize using query schemas.</li> <li>Index: overview of query optimizations and schemas.</li> <li>ORJSON renderer: configuration guide.</li> </ul> \u26a0 Notes / Potential Impact <p>| Area                | Observation                                                       | Impact                                                                | | ------------------- | ----------------------------------------------------------------- | --------------------------------------------------------------------- | | Query optimizations | <code>is_for_read=True</code> merges explicit and auto-discovered relations. | More joins/prefetches; re-check performance for heavy endpoints.      | | Requirements caps   | Upper bounds added for core deps.                                 | Ensure compatible versions in your environment.                       | | Decorator order     | <code>decorate_view</code> applies standard Python stacking order.           | Verify nesting with <code>paginate</code>, <code>unique_view</code>, and custom decorators. |</p> \ud83d\udd0d Migration / Action <ol> <li>Update imports:</li> <li><code>from ninja_aio.schemas.helpers import QuerySchema, ObjectQuerySchema, ObjectsQuerySchema, ModelQuerySetSchema, ModelQuerySetExtraSchema</code></li> <li><code>from ninja_aio.helpers.api import ManyToManyAPI</code></li> <li>Adjust M2M GET consumers to handle <code>{items, count}</code>.</li> <li>Update <code>read_s</code>/<code>list_read_s</code> calls to new parameter order.</li> <li>Verify path PK handling in custom routes that relied on a generic PK type.</li> <li>Review <code>QuerySet.read</code> / <code>QuerySet.queryset_request</code> for desired select/prefetch behavior.</li> <li>Optionally configure ORJSON via <code>NINJA_AIO_ORJSON_RENDERER_OPTION</code>.</li> </ol>v2.0.0-rc1diff2025-12-07Release notes [2.0.0-rc1] - 2025-12-07 \u2728 Added <ul> <li>QueryUtil and query scopes:</li> <li>New <code>QueryUtil</code> with <code>SCOPES</code> (READ, QUERYSET_REQUEST, plus extras) and <code>apply_queryset_optimizations</code>.</li> <li><code>ModelSerializer.query_util</code> bound per model via <code>__init_subclass__</code>.</li> <li><code>ModelSerializer.QuerySet</code> supports <code>read</code>, <code>queryset_request</code>, <code>extras</code>.</li> <li>Query schemas:</li> <li><code>QuerySchema</code>, <code>ObjectQuerySchema</code>, <code>ObjectsQuerySchema</code>, <code>ModelQuerySetSchema</code>, <code>ModelQuerySetExtraSchema</code>, <code>QueryUtilBaseScopesSchema</code>.</li> <li>ModelUtil:</li> <li><code>get_objects(...)</code>: optimized queryset fetching with filters and select/prefetch hints.</li> <li><code>get_object(...)</code>: single-object retrieval by pk or getters with optimizations.</li> <li><code>read_s(...)</code> and <code>list_read_s(...)</code>: serialize instances or auto-fetch via query schemas.</li> <li>Relation discovery helpers: <code>get_select_relateds()</code>, <code>get_reverse_relations()</code>.</li> <li>PK type resolution: <code>pk_field_type</code> with helpful error for unknown field types.</li> <li>ManyToManyAPI:</li> <li>GET related endpoints return <code>{items: [...], count: N}</code>.</li> <li>Relation filter handlers accept sync or async functions.</li> <li>Related items use <code>ModelUtil.list_read_s</code> for serialization.</li> <li>Schemas modularization:</li> <li>New modules: <code>ninja_aio/schemas/api.py</code>, <code>ninja_aio/schemas/generics.py</code>, and exported names under <code>ninja_aio/schemas/__init__.py</code>.</li> <li>Decorators:</li> <li>Minor hardening and docs for <code>aatomic</code> and <code>unique_view</code>.</li> </ul> \ud83d\udee0 Changed <ul> <li>APIViewSet:</li> <li>List view uses <code>ModelUtil.get_objects</code> and <code>list_read_s</code> with read optimizations; filter hooks retained.</li> <li>Retrieve view uses <code>read_s</code> with <code>QuerySchema(getters={\"pk\": ...})</code>.</li> <li>Path PK schema type inferred from model PK via <code>ModelUtil.pk_field_type</code>.</li> <li>Default read query data comes from <code>ModelSerializer.QuerySet.read</code> via <code>query_util</code>.</li> <li>ModelSerializer:</li> <li>Binds <code>util = ModelUtil(cls)</code> and <code>query_util = QueryUtil(cls)</code> to subclasses.</li> <li><code>queryset_request</code> applies configured optimizations from <code>QuerySet.queryset_request</code>.</li> <li>ModelUtil internals:</li> <li>Unified <code>_apply_query_optimizations</code> merges explicit select/prefetch with auto-discovered relations when <code>is_for_read=True</code>.</li> <li>Serialization paths standardized through internal bump helpers.</li> <li>Auth:</li> <li><code>AsyncJwtBearer.verify_token</code> simplifies error handling; drops explicit <code>AuthError</code>.</li> <li>Imports:</li> <li><code>ManyToManyAPI</code> consumed from <code>ninja_aio/helpers/api.py</code>.</li> <li>Runtime requirements:</li> <li>Pinned upper bounds for <code>django-ninja</code>, <code>joserfc</code>, <code>orjson</code>.</li> </ul> \ud83d\udcdd Documentation <ul> <li>Updated:</li> <li>ModelUtil reference: QuerySet config, QueryUtil, query schemas, <code>get_objects</code>, <code>get_object</code>, <code>read_s</code>, <code>list_read_s</code>.</li> <li>APIViewSet: list/retrieve flow, PK type inference, M2M GET envelope, async/sync filter handlers.</li> <li>Tutorial (model): QuerySet config and <code>query_util</code> examples; fetch/serialize using query schemas.</li> <li>Index: overview of query optimizations and schemas.</li> </ul> \ud83d\udd34 Breaking Changes <ul> <li>Path PK schema type:</li> <li>PK type is now inferred from the model PK. Code relying on <code>int | str</code> in path schemas may need adjustments.</li> <li>ManyToMany GET response shape:</li> <li>Response changed from a plain list to an envelope <code>{items: [...], count: N}</code>. Clients must adapt parsing.</li> <li>Import paths:</li> <li>Schema helpers moved under <code>ninja_aio/schemas/helpers.py</code> and re-exported by <code>ninja_aio/schemas/__init__.py</code>.</li> <li><code>ManyToManyAPI</code> import is now <code>from ninja_aio.helpers.api import ManyToManyAPI</code>.</li> <li>ModelUtil read API:</li> <li><code>read_s</code> and <code>list_read_s</code> signatures accept <code>schema</code> first and support <code>instance</code> or <code>query_data</code>. Code passing <code>(request, obj, schema)</code> must switch to <code>(schema, request, instance=obj)</code>.</li> </ul> \u26a0 Notes / Potential Impact <p>| Area | Observation | Impact | | ---- | ----------- | ------ | | Query optimizations | <code>is_for_read=True</code> merges explicit and auto-discovered relations. | More joins/prefetches; re-check performance for heavy endpoints. | | Requirements caps | Upper bounds added for core deps. | Ensure compatible versions in your environment. |</p> \ud83d\udd0d Migration / Action <ol> <li>Update imports:</li> <li><code>from ninja_aio.schemas.helpers import QuerySchema, ObjectQuerySchema, ObjectsQuerySchema, ModelQuerySetSchema, ModelQuerySetExtraSchema</code></li> <li><code>from ninja_aio.helpers.api import ManyToManyAPI</code></li> <li>Adjust M2M GET consumers to handle <code>{items, count}</code>.</li> <li>Update <code>read_s</code>/<code>list_read_s</code> calls to new parameter order.</li> <li>Verify path PK handling in custom routes that relied on a generic PK type.</li> <li>Review <code>QuerySet.read</code> / <code>QuerySet.queryset_request</code> for desired select/prefetch behavior.</li> </ol> \u2705 Suggested Follow-Ups <ul> <li>Add perf checks around list/retrieve with merged relations.</li> <li>Expand tests for:</li> <li>PK type inference in path schemas.</li> <li>Sync vs async relation filter handlers.</li> <li>QueryUtil extras scopes resolution and application.</li> </ul> v2.0.0-rc2diff2025-12-12Release notes [2.0.0-rc2] - 2025-12-12 \u2728 Added <ul> <li>support for django-ninja 1.5.1</li> <li>support for orjson 3.11.5</li> </ul>v2.0.0-rc3diff2025-12-12Release notes [2.0.0-rc3] - 2025-12-12 \u2728 Added <ul> <li>ManyToManyAPI:</li> <li>New per-relation POST object resolution handler: <code>&lt;related_name&gt;_query_handler(self, request, pk, instance)</code> returning a queryset, resolved via <code>.afirst()</code>.</li> <li>Endpoint registration details documented: GET without trailing slash, POST with trailing slash; operationId conventions (<code>get_{base}_{rel}</code>, <code>manage_{base}_{rel}</code>).</li> </ul> \ud83d\udee0 Changed <ul> <li>ManyToManyAPI:</li> <li>Split handlers: GET uses <code>&lt;related_name&gt;_query_params_handler(self, queryset, filters_dict)</code>; POST uses <code>&lt;related_name&gt;_query_handler(...)</code> for per-PK validation.</li> <li>Manage view uses <code>_collect_m2m(...)</code> with additional context (<code>related_name</code>, <code>instance</code>) and falls back to <code>ModelUtil.get_objects(...)</code> when query handler is absent.</li> <li>Improved docs and docstrings for concurrency, error semantics, and request/response payloads.</li> <li>Docs:</li> <li>Refined M2M section: clarified handlers, paths, operationIds, request bodies, and concurrency.</li> <li>Minor wording and formatting improvements; standardized examples.</li> <li>Version:</li> <li>Bump to <code>2.0.0-rc3</code>.</li> </ul> \ud83d\udcdd Documentation <ul> <li>APIViewSet M2M docs updated:</li> <li>Clarified GET filters vs POST per-PK resolution.</li> <li>Documented response semantics and per-PK success/error messages.</li> <li>Added an example showcasing both handlers.</li> </ul> \ud83d\udd34 Breaking Changes <ul> <li>Handler naming:</li> <li>GET filters must use <code>&lt;related_name&gt;_query_params_handler</code>; POST add/remove resolution must use <code>&lt;related_name&gt;_query_handler</code>. Existing single-handler implementations should be split accordingly.</li> <li>Endpoint paths:</li> <li>GET relation: <code>/{base}/{pk}/{rel_path}</code> (no trailing slash).</li> <li>POST relation: <code>/{base}/{pk}/{rel_path}/</code> (trailing slash).</li> </ul> \u26a0 Notes / Potential Impact <p>| Area | Observation | Impact | | ---- | ----------- | ------ | | Validation | POST uses per-PK resolution handler when present; fallback uses <code>ModelUtil.get_objects</code>. | Tighten access control and scoping per relation. | | Concurrency | <code>aadd</code> and <code>aremove</code> run concurrently via <code>asyncio.gather</code>. | Faster bulk mutations; ensure thread-safety of custom logic. |</p> \ud83d\udd0d Migration / Action <ol> <li>Implement per-relation handlers:</li> <li>GET filters: <code>def|async def &lt;rel&gt;_query_params_handler(self, qs, filters: dict) -&gt; qs</code>.</li> <li>POST resolution: <code>async def &lt;rel&gt;_query_handler(self, request, pk, instance) -&gt; queryset</code>.</li> <li>Verify clients and OpenAPI consumers against the documented endpoint paths and operationIds.</li> <li>Ensure manage responses are consumed as documented (<code>results</code>, <code>errors</code> with <code>count</code> and <code>details</code>).</li> </ol> \u2705 Suggested Follow-Ups <ul> <li>Add tests for:</li> <li>Presence/absence of <code>&lt;related_name&gt;_query_handler</code> fallback behavior.</li> <li>Sync vs async GET filter handlers.</li> <li>Per-PK error and success detail aggregation.</li> </ul>v2.0.0-rc4diff2025-12-12Release notes [2.0.0-rc4] - 2025-12-12 \u2728 Added <ul> <li>possibility to override router tag in APIViewSet</li> </ul> v2.0.0-rc5diff2025-12-12Release notes [2.0.0-rc5] - 2025-12-12 \ud83d\udee0 Changed <ul> <li>fix: update log messages to use 'pk' instead of 'id' for consistency in ManyToManyAPI</li> </ul> v2.0.0-rc6diff2025-12-12Release notes [2.0.0-rc6] - 2025-12-12 \u2728 Added <ul> <li>ORJSONRenderer:</li> <li>Configurable orjson option via Django settings: <code>NINJA_AIO_ORJSON_RENDERER_OPTION</code>.</li> <li>New <code>dumps</code> classmethod applying the configured option to all JSON responses.</li> </ul> \ud83d\udee0 Changed <ul> <li>Version bump:</li> <li><code>__version__</code> updated from <code>2.0.0-rc5</code> to <code>2.0.0-rc6</code>.</li> <li>Rendering internals:</li> <li><code>render</code> now calls <code>self.dumps(...)</code> instead of <code>orjson.dumps(...)</code> directly.</li> </ul> \ud83d\udcdd Documentation <ul> <li>Mention <code>NINJA_AIO_ORJSON_RENDERER_OPTION</code> in setup/config docs with example values (e.g., <code>orjson.OPT_NAIVE_UTC</code>, <code>orjson.OPT_SERIALIZE_DATACLASS</code>).</li> </ul> \ud83d\udd0d Migration / Action <ol> <li>If you need specific JSON encoding behavior, set in Django settings:</li> <li><code>NINJA_AIO_ORJSON_RENDERER_OPTION = orjson.OPT_NAIVE_UTC | orjson.OPT_SERIALIZE_NUMPY</code> (example).</li> <li>No code changes required for consumers; behavior is backward compatible when the setting is absent.</li> </ol> \u26a0 Notes / Potential Impact <p>| Area | Observation | Impact | | ---- | ----------- | ------ | | JSON options | Renderer honors global orjson options. | Unified behavior across endpoints; verify compatibility with clients. |</p> v2.0.0-rc7diff2025-12-16Release notes [2.0.0-rc7] - 2025-12-16 \u2728 Added <ul> <li>Decorators:</li> <li><code>decorate_view</code>: compose multiple decorators (sync/async), preserves normal stacking order, skips <code>None</code>.</li> <li><code>APIViewSet.extra_decorators</code>: declarative per-operation decorators.</li> <li><code>DecoratorsSchema</code> in <code>ninja_aio.schemas.helpers</code> to configure per-op decorators.</li> </ul> \ud83d\udee0 Changed <ul> <li>APIViewSet:</li> <li><code>create</code>, <code>list</code>, <code>retrieve</code>, <code>update</code>, <code>delete</code> compose built-ins (<code>unique_view</code>, <code>paginate</code>) and user-provided extras via <code>decorate_view</code> for consistent ordering.</li> </ul> \ud83d\udcdd Documentation <ul> <li>New:</li> <li><code>docs/api/views/decorators.md</code>: <code>decorate_view</code> usage, conditional decoration, and <code>extra_decorators</code> with <code>DecoratorsSchema</code>.</li> <li><code>docs/api/renderers/orjson_renderer.md</code>: how to configure ORJSON options in <code>settings.py</code>.</li> </ul> \u26a0 Notes / Potential Impact <ul> <li>Decorator order:</li> <li><code>decorate_view</code> applies decorators in standard Python stacking semantics. If you relied on a specific nesting between <code>paginate</code>, <code>unique_view</code>, and custom decorators, verify behavior.</li> </ul> \ud83d\udd0d Migration / Action <ol> <li>Optionally move per-operation decorators to <code>APIViewSet.extra_decorators = DecoratorsSchema(...)</code>.</li> <li>If desired, configure ORJSON behavior via <code>NINJA_AIO_ORJSON_RENDERER_OPTION</code> in <code>settings.py</code>.</li> </ol>v1.0.5diff2025-12-07Release notes[1.0.5] - 2025-12-07 \ud83d\udee0 Changed <ul> <li>limited support up to django ninja 1.4.5</li> </ul>v1.0.4diff2025-11-03Release notes[1.0.4] - 2025-11-03 \u2728 Added <ul> <li><code>ModelUtil._rewrite_nested_foreign_keys</code>: reintroduced helper to rename nested FK keys from <code>&lt;field&gt;</code> to <code>&lt;field&gt;_id</code> inside nested dicts (currently invoked conditionally in <code>parse_output_data</code>).</li> </ul> \ud83d\udee0 Changed <ul> <li><code>ModelUtil._extract_field_obj</code> converted to async; now uses <code>agetattr</code> for safer async attribute access.</li> <li><code>ModelUtil.parse_output_data</code>:</li> <li>Awaits the new async <code>_extract_field_obj</code>.</li> <li>Fetches related instance first, then (conditionally) calls <code>_rewrite_nested_foreign_keys</code> when the outer field is a <code>ForeignKey</code>.</li> </ul> \ud83d\udcdd Documentation <ul> <li>Table in <code>docs/api/models/model_serializer.md</code> (CreateSerializer attributes) reformatted:</li> <li>Condensed multiline description for <code>customs</code> into a single line with semicolons.</li> <li>Adjusted column widths / alignment for cleaner diff footprint.</li> </ul> \u26a0 Note / Potential Issue <p>| Area | Observation | Impact | | ---- | ----------- | ------ | | <code>parse_output_data</code> | Result of <code>_rewrite_nested_foreign_keys</code> is assigned to local <code>v</code> but not reattached to <code>payload</code> (final output still sets <code>payload[k] = rel_instance</code>). | FK key rewriting may be a no-op for consumers; behavior might not match intent. |</p> \ud83d\udd0d Migration / Action <ol> <li>If you relied on the absence of FK key rewriting (1.0.3), verify whether the restored helper actually affects payloads (it likely does not yet).</li> <li>If rewriting is desired, ensure the transformed dict (or additional metadata) is surfaced in the serialized output or adjust logic accordingly.</li> </ol> \u2705 Suggested Follow-Ups <ul> <li>Add a test asserting expected presence (or absence) of <code>&lt;field&gt;_id</code> keys in nested output.</li> <li>Decide whether payload should expose both the related object and rewritten key map, or deprecate the helper again if not needed.</li> </ul> v1.0.3diff2025-11-03Release notes[1.0.3] - 2025-11-03 \u2728 Added <ul> <li><code>M2MRelationSchema</code>: New optional field <code>related_schema</code> documented (auto-generated when using a <code>ModelSerializer</code>).</li> </ul> \ud83d\udee0 Changed <ul> <li>Documentation tables (CRUD, Core Attributes, Auth, M2M Endpoints, Hooks) reformatted for alignment &amp; readability.</li> <li>Extra blank lines inserted to improve Markdown rendering clarity.</li> <li><code>ModelUtil.parse_output_data</code>: simplified nested relation handling (direct instance assignment).</li> </ul> \ud83d\uddd1 Removed <ul> <li><code>ModelUtil._rewrite_nested_foreign_keys</code> helper.</li> <li>Foreign key nested dict rewriting logic (<code>&lt;field&gt;</code> \u2192 <code>&lt;field&gt;_id</code>) during output serialization.</li> </ul> \ud83d\udcc4 Documentation <ul> <li>Added warning block describing support for plain Django <code>Model</code> in <code>M2MRelationSchema.model</code> and mandatory <code>related_schema</code> when used.</li> <li>Added <code>related_schema</code> bullet to M2M relation capabilities list.</li> <li>Ensured file ends with a trailing newline.</li> </ul> \u26a0 Breaking Change <p>| Change | Impact | | ------ | ------ | | Removal of FK key rewriting in nested outputs | Clients expecting <code>&lt;nested_fk&gt;_id</code> keys must adjust parsing logic |</p> \ud83d\udd0d Migration Notes <ol> <li>If consumers relied on <code>&lt;nested_fk&gt;_id</code> keys, add a post-serialization adapter to inject them, or reintroduce prior logic.</li> <li>When declaring M2M relations with plain Django models, always provide <code>related_schema</code>; omission now results in validation errors.</li> </ol> \ud83d\udccc Highlights <ul> <li>Cleaner docs + explicit M2M plain model guidance.</li> <li>Leaner serialization path (less mutation, clearer intent).</li> </ul> \ud83e\uddea Suggested Follow\u2011Ups <ul> <li>Add regression test ensuring nested FK dicts are no longer rewritten.</li> <li>Consider exposing an optional flag to restore legacy FK key rewriting if demand appears.</li> </ul>v1.0.2diff2025-11-01Release notes[1.0.2] - 2025-11-01 \u2728 Added <ul> <li>SonarCloud Quality Gate badge (README + docs index).</li> <li>Custom domain support (docs/CNAME).</li> <li>Release Notes page with dynamic macros (<code>docs/release_notes.md</code> + <code>mkdocs-macros-plugin</code>).</li> <li>Release automation script (<code>main.py</code>) generating tables, full changelog, and cards.</li> <li>ManyToManyAPI helper (<code>ninja_aio/helpers/api.py</code>) with dynamic GET / ADD / REMOVE endpoints, filter schemas, concurrent operations, and query handler support.</li> <li>Helpers package export (<code>helpers/__init__.py</code>).</li> <li>Extended schema support in <code>M2MRelationSchema</code> (auto <code>related_schema</code> via validator).</li> <li>Refactored M2M integration in <code>APIViewSet</code> (now uses <code>ManyToManyAPI</code>).</li> <li>New test suites: decorators, exceptions/API, renderer/parser, many-to-many API.</li> <li>Centralized literal for \u201cnot found\u201d (<code>tests/generics/literals.py</code>).</li> </ul> \ud83d\udee0 Changed <ul> <li><code>NotFoundError</code>: error key now uses underscored verbose name.</li> <li><code>ORJSONRenderer</code>: replaced nested mutation with recursive <code>transform</code>.</li> <li><code>ModelUtil</code> / <code>ModelSerializer</code>: added comprehensive docstrings, normalized custom field tuples, improved FK and nested output handling.</li> <li>Removed inline M2M view logic from <code>APIViewSet</code>.</li> <li>Enriched model serializer docs (tables, normalization, error cases).</li> <li><code>M2MRelationSchema</code>: validation for related schema generation.</li> </ul> \ud83e\uddfe Documentation <ul> <li>Major rewrite of <code>docs/api/models/model_serializer.md</code>: normalization workflow, error cases, best practices, expanded examples.</li> <li>Added Release Notes navigation in <code>mkdocs.yml</code>.</li> <li>Inline internal-use warning for <code>ManyToManyAPI</code>.</li> <li>Improved readability (spacing, tables, JSON formatting).</li> </ul> \u2705 Tests <ul> <li>Coverage for:</li> <li>ORJSON transformations (bytes\u2192base64, IP\u2192string).</li> <li><code>unique_view</code> name suffix logic.</li> <li>Exception parsing and API defaults.</li> <li>M2M add/remove flows + duplicate/error handling.</li> <li>Updated NotFoundError key format.</li> <li>Reused shared literal for 404 assertions.</li> </ul> \ud83d\udce6 Tooling <ul> <li>Added <code>mkdocs-macros-plugin</code>.</li> <li>Automated release visualization (HTML tables, cards).</li> <li>Cleaner MkDocs theme (font configuration).</li> </ul> \u26a0 Impact <p>| Change | Potential Effect | | ------ | ---------------- | | Underscored error keys | Clients parsing old keys must adjust | | Extracted M2M logic | Custom subclasses relying on internals must migrate | | 2\u2011tuple customs now required | Missing values trigger validation errors |</p> \ud83d\udd0d Upgrade Notes <ol> <li>Update error handling for new 404 key shape.</li> <li>Migrate any manual M2M endpoint wiring to <code>ManyToManyAPI</code>.</li> <li>Review custom field tuples\u2014add defaults if optional behavior desired.</li> </ol> \ud83e\uddea Follow\u2011Ups <ul> <li>Tag release (<code>git tag -a vX.Y.Z -m \"Release vX.Y.Z\" &amp;&amp; git push --tags</code>).</li> <li>Optionally add top-level <code>CHANGELOG.md</code>.</li> <li>Decide on public stability of <code>ManyToManyAPI</code> (remove warning when ready).</li> </ul> \ud83d\udccc Release Template <p>```markdown</p> vX.Y.Z (YYYY-MM-DD) <p>Highlights: - ...</p> <p>Full release table: /release_notes/</p>v1.0.1diff2025-10-30Release notes1.0.1 - 2025-10-30 Added <ul> <li>Docs: New dev dependencies file <code>requirements.dev.txt</code>.</li> <li>MkDocs: Additional plugins (<code>mkdocstrings</code>, <code>section-index</code>, <code>autorefs</code>) and extended <code>markdown_extensions</code>.</li> <li>Theme extras: social links, analytics stub, version metadata.</li> <li>CSS: Logo sizing rules in <code>docs/extra.css</code>.</li> </ul> Changed <ul> <li>README: Reduced length, modernized intro, added concise feature + quick start sections.</li> <li>Pagination docs: Reformatted tables, spacing, clarified examples.</li> <li>Contributing docs: Expanded with setup, PR guidelines, issue template hints.</li> <li>Tutorial (CRUD &amp; Filtering): Table formatting, spacing normalization, improved examples.</li> <li>Favicon path moved <code>docs/img/favicon.ico</code> \u2192 <code>docs/images/favicon.ico</code>; logo updated.</li> <li>Index docs: Documentation URL switched to custom domain.</li> <li>MkDocs config:</li> <li><code>site_url</code> updated to <code>https://django-ninja-aio.com/</code>.</li> <li>Added logo/favicon references and rich navigation features.</li> <li>Expanded palette + features (search, code copy/select, tooltips, etc.).</li> <li>PyProject metadata: Documentation URL updated to new domain.</li> <li>Pagination imports switched to <code>from ninja.pagination</code> instead of local alias in examples.</li> <li>Refactor: <code>_m2m_views</code> now takes a single <code>M2MRelationSchema</code> and is invoked in a loop (improves clarity).</li> <li>Minor docstring spacing added before CRUD endpoint decorators.</li> <li>M2M registration: Logic unchanged functionally but simplified iteration pattern.</li> </ul> Removed <ul> <li>Legacy automatic loop inside <code>_m2m_views</code> (replaced by external loop in <code>_add_views</code>).</li> <li>Redundant long README sections (old serializer deep examples, extended auth/pagination prose).</li> </ul> Internal <ul> <li><code>_add_views</code> now iterates <code>self.m2m_relations</code> and calls <code>_m2m_views(relation)</code> for each.</li> <li>Consistent path/auth resolution maintained; no schema changes to public API.</li> <li>Added <code>use_directory_urls: true</code> explicitly in <code>mkdocs.yml</code>.</li> </ul> Impact <ul> <li>No breaking API changes.</li> <li>Documentation structure improved; search indexing benefits from new plugins.</li> <li>M2M internals slightly cleaner; external behavior stable.</li> </ul> Migration Notes <p>No action required for existing users.</p>v1.0.0diff2025-10-28Release notes1.0.0 - 2025-10-28 Added <ul> <li>Per\u2011relation M2M configuration via <code>M2MRelationSchema</code> (replaces tuples).</li> <li>Per\u2011relation flags: <code>add</code>, <code>remove</code>, <code>get</code>.</li> <li>Per\u2011relation <code>filters</code> with dynamic schema generation and hook <code>&lt;related_name&gt;_query_params_handler</code>.</li> <li>Method <code>_generate_m2m_filters_schemas</code> to build all M2M filter schemas.</li> <li>Query param injection for M2M GET: <code>filters: Query[filters_schema] = None</code>.</li> <li>Extended docstrings for <code>APIViewSet</code> and internal helper methods.</li> <li>Overridable hooks documented in docs (<code>query_params_handler</code>, per\u2011relation handlers).</li> <li>Changelog: version bump to <code>__version__ = \"1.0.0\"</code>.</li> </ul> Changed <ul> <li><code>api_view_set.md</code> rewritten: tuple-based M2M section replaced with <code>M2MRelationSchema</code> docs, new sections for filters, hooks, examples.</li> <li>CRUD table wording (schema_out formatting, notes clarified).</li> <li>Auth resolution notes now include M2M fallback logic.</li> <li>Internal view registration: per-relation flags extracted (<code>m2m_add/remove/get</code> replaced by schema attributes).</li> <li>Error message spacing adjusted in <code>_check_m2m_objs</code>.</li> <li>Refactored internal function docs (more concise, purpose-focused).</li> <li>Dynamic filter/path schemas built through unified <code>_generate_schema</code>.</li> </ul> Removed <ul> <li>Class attributes: <code>m2m_add</code>, <code>m2m_remove</code>, <code>m2m_get</code>.</li> <li>Tuple-based <code>m2m_relations</code> formats.</li> <li>Legacy verbose examples inside <code>views()</code> docstring.</li> <li>Redundant <code>m2m_auth</code> entry in auth table (moved to core attributes table).</li> </ul> Internal <ul> <li>Added per-method docstrings (<code>create_view</code>, <code>list_view</code>, <code>retrieve_view</code>, <code>update_view</code>, <code>delete_view</code>, <code>_m2m_views</code>, <code>_add_views</code>, etc.).</li> <li><code>_crud_views</code> now described as a mapping.</li> <li>Added storage of <code>self.m2m_filters_schemas</code> during init.</li> <li>GET M2M handler applies optional per-relation filter hook if present.</li> <li>Manage M2M handler chooses input schema dynamically (<code>M2MSchemaIn</code> / <code>M2MAddSchemaIn</code> / <code>M2MRemoveSchemaIn</code>).</li> </ul> Migration Notes <p>Old: <code>python m2m_relations = [     (Tag, \"tags\"),     (Category, \"categories\", \"article-categories\"),     (Author, \"authors\", \"co-authors\", [AdminAuth()]) ] m2m_add = True m2m_remove = True m2m_get = True</code></p> <p>New: ```python from ninja_aio.schemas import M2MRelationSchema</p> <p>m2m_relations = [     M2MRelationSchema(model=Tag, related_name=\"tags\"),     M2MRelationSchema(model=Category, related_name=\"categories\", path=\"article-categories\"),     M2MRelationSchema(model=Author, related_name=\"authors\", path=\"co-authors\", auth=[AdminAuth()]) ]</p> <p>```</p> <p>Per\u2011relation filters: ```python M2MRelationSchema(     model=Tag,     related_name=\"tags\",     filters={\"name\": (str, \"\")} )</p> <p>async def tags_query_params_handler(self, queryset, filters):     if filters.get(\"name\"):         queryset = queryset.filter(name__icontains=filters[\"name\"])     return queryset ```</p> Breaking Changes <ul> <li><code>m2m_relations</code> must use <code>M2MRelationSchema</code> (no tuples).</li> <li>Removed <code>m2m_add</code>, <code>m2m_remove</code>, <code>m2m_get</code> (use per-relation flags).</li> <li>Any code unpacking relation tuples must be updated to attribute access.</li> </ul> Summary <p>Release focuses on granular M2M configuration, per\u2011relation filtering, cleaner internals, and clearer documentation for extensibility.</p>v0.11.4diff2025-10-28Release notes0.11.4 - 2025-10-28 Changed <ul> <li>Documentation heading renamed from <code># API ViewSet</code> to <code># APIViewSet</code>.</li> <li>Docs rewritten: long examples replaced with concise endpoint table and structured attribute sections.</li> <li>Core attributes table expanded (added <code>pagination_class</code>, <code>query_params</code>, <code>disable</code>, endpoint doc strings).</li> <li>Clarified authentication resolution; explicit mention of <code>m2m_auth</code>.</li> </ul> Added <ul> <li>Per-relation M2M configuration: support for 3- and 4-element tuples in <code>m2m_relations</code>.</li> <li>3 elements: <code>(model, related_name, custom_path)</code></li> <li>4 elements: <code>(model, related_name, custom_path, per_relation_auth)</code></li> <li>Per-relation auth override (local <code>m2m_auth</code> inside <code>_m2m_views</code> loop).</li> <li>Documentation of M2M path/auth resolution rules.</li> </ul> Removed <ul> <li>Global <code>m2m_path</code> attribute (replaced by per-relation path tuple element).</li> <li>Old <code>m2m_relations</code> signature <code>list[tuple[ModelSerializer | Model, str]]</code>.</li> </ul> Internal Implementation <ul> <li>M2M loop updated: <code>for m2m_data in self.m2m_relations:</code> with dynamic tuple length parsing.</li> <li>Path resolution:   <code>python   rel_path = rel_util.verbose_name_path_resolver() if not m2m_path else m2m_path</code></li> <li>Auth passed to decorators as <code>auth=m2m_auth</code> instead of <code>auth=self.m2m_auth</code>.</li> <li>Continued use of <code>@unique_view(...)</code> for stable handler naming.</li> </ul> Migration Notes <p>```python</p> <p>m2m_relations = [(Tag, \"tags\")] m2m_path = \"custom-tags\"  # no longer supported</p> <p>m2m_relations = [     (Tag, \"tags\"),                                 # auto path + fallback auth     (Category, \"categories\", \"custom-categories\"), # custom path     (Author, \"authors\", \"article-authors\", [AdminAuth()])  # custom path + custom auth ] <code>`` - Remove any</code>m2m_path` usage. - 2-element tuples remain valid (no breaking change).</p> Summary <p>Improved flexibility and granularity for M2M relation configuration and streamlined documentation.</p>v0.11.3diff2025-10-28Release notes[0.11.3] - 2025-10-28 Added <ul> <li>M2M Path Customization: Added <code>m2m_path</code> attribute to <code>APIViewSet</code> for custom many-to-many relationship endpoint paths</li> <li>Default: empty string (uses auto-generated path from model verbose name)</li> <li>Allows overriding the default path resolution for M2M endpoints</li> </ul> Changed APIViewSet Class Attributes <ul> <li>m2m_relations type annotation: Changed from <code>tuple[ModelSerializer | Model, str]</code> to <code>list[tuple[ModelSerializer | Model, str]]</code></li> <li>More flexible and mutable data structure</li> <li>Allows dynamic modification of M2M relations at runtime</li> </ul> Code Quality &amp; Formatting <ul> <li>Consistent blank lines: Added blank lines after function returns for better code readability</li> <li>Applied to: <code>create_view()</code>, <code>list_view()</code>, <code>retrieve_view()</code>, <code>update_view()</code>, <code>delete_view()</code></li> <li>Removed extra blank line: Cleaned up unnecessary blank line in <code>delete_view()</code> method</li> <li>M2M views refactoring: Improved code structure for many-to-many relationship views</li> <li>Applied <code>@unique_view</code> decorator to M2M endpoints (<code>get_related</code>, <code>manage_related</code>)</li> <li>Removed manual <code>__name__</code> assignment in favor of decorator pattern</li> <li>Better separation of concerns between GET and POST operations</li> <li>Moved conditional M2M add/remove logic outside of the GET endpoint block</li> </ul> M2M Endpoint Generation <ul> <li>Dynamic path resolution: M2M endpoints now respect custom <code>m2m_path</code> attribute   ```python   rel_path = (       rel_util.verbose_name_path_resolver()       if not self.m2m_path       else self.m2m_path   )</li> </ul>v0.11.1diff2025-10-28Release notes[0.11.1] - 2025-10-28 Fixed <ul> <li>Fixed typo in module name: renamed <code>decoratos.py</code> to <code>decorators.py</code></li> <li>Updated import statement in <code>views.py</code> to use correct <code>decorators</code> module name</li> </ul> Changed Documentation <ul> <li>Homepage Examples - Updated traditional approach comparison</li> <li>Changed from Django REST Framework serializers to Django Ninja ModelSchema</li> <li>Simplified example from <code>UserSerializer</code> to <code>UserSchemaOut</code></li> <li>Simplified example from <code>UserCreateSerializer</code> to <code>UserSchemaIn</code></li> <li>Updated view examples to use Django Ninja's <code>@api.get()</code> and <code>@api.post()</code> decorators</li> <li>Replaced class-based views (<code>UserListView</code>, <code>UserCreateView</code>) with function-based views</li> <li>Removed <code>sync_to_async</code> wrapper calls in favor of native async Django ORM operations</li> <li>Simplified user creation with direct <code>acreate()</code> usage</li> <li>Updated response format to use tuple-based status code returns <code>(201, user)</code></li> <li>Made code examples more concise and modern</li> </ul> Technical Details Module Renaming <p>```python</p> <p>from .decoratos import unique_view</p> <p>from .decorators import unique_view</p>v0.11.0diff2025-10-26Release notes[0.11.0] - 2025-10-26 Added Documentation <ul> <li>Complete documentation website with MkDocs Material theme</li> <li>Custom domain configuration (ninja-aio.dev) via CNAME</li> <li>Getting Started Guide</li> <li>Installation instructions</li> <li>Quick start tutorial with screenshots</li> <li>Auto-generated Swagger UI examples</li> <li>Tutorial Series (4 comprehensive steps)</li> <li>Step 1: Define Your Model - Complete guide to ModelSerializer with relationships, custom fields, and lifecycle hooks</li> <li>Step 2: Create CRUD Views - APIViewSet usage, custom endpoints, query parameters, and error handling</li> <li>Step 3: Add Authentication - JWT setup with RSA keys, role-based access control, and ownership validation</li> <li>Step 4: Add Filtering &amp; Pagination - Advanced filtering, full-text search, ordering, and performance optimization</li> <li>API Reference Documentation</li> <li>Authentication guide (965 lines) covering AsyncJwtBearer, JWT validation, RBAC, and integrations</li> <li>ModelSerializer reference (806 lines) with schema generation and relationship handling</li> <li>ModelUtil reference (1,066 lines) detailing CRUD operations and data transformations</li> <li>APIView documentation for custom endpoints</li> <li>APIViewSet documentation (327 lines) for complete CRUD operations</li> <li>Pagination guide (750 lines) with custom pagination examples</li> <li>Contributing guidelines</li> <li>Logo and branding assets</li> <li>Extra CSS styling for code blocks</li> </ul> Core Features <ul> <li>NotFoundError Exception</li> <li>New exception class for 404 errors with model-aware error messages</li> <li>Automatically includes model verbose name in error response</li> <li>Status code 404 with structured error format</li> </ul> Utilities <ul> <li>Decorators Module (<code>ninja_aio/decoratos.py</code>)</li> <li><code>aatomic</code> decorator for asynchronous atomic transactions</li> <li><code>AsyncAtomicContextManager</code> for async transaction context management</li> <li><code>unique_view</code> decorator for generating unique view names based on model metadata</li> <li>Support for both singular and plural model naming conventions</li> </ul> Examples <ul> <li>Example 1 (<code>examples/ex_1/</code>)</li> <li>Basic User model without relationships</li> <li>Simple ViewSet implementation</li> <li>Basic URL configuration</li> <li>Example 2 (<code>examples/ex_2/</code>)</li> <li>User and Customer models with ForeignKey relationship</li> <li>JWT authentication setup with RSA keys</li> <li>Complete auth configuration with mandatory claims</li> <li>Related field serialization examples</li> </ul> Development Tools <ul> <li>MkDocs configuration (<code>mkdocs.yml</code>)</li> <li>Material theme with deep purple color scheme</li> <li>Dark/light mode support with auto-detection</li> <li>Navigation tabs and integrated TOC</li> <li>Code highlighting with Pygments</li> <li>Admonitions and superfences support</li> <li>Documentation requirements file</li> <li>Custom CSS for documentation styling</li> </ul> Changed Core Models <ul> <li>ModelSerializer</li> <li>Enhanced docstring (113 lines) with comprehensive API documentation</li> <li>Detailed explanation of schema generation and relationship handling</li> <li>Examples for CreateSerializer, ReadSerializer, and UpdateSerializer</li> <li>Documented sync and async lifecycle hooks</li> <li>ModelUtil</li> <li>Enhanced docstring (79 lines) documenting all CRUD operations</li> <li>Detailed method documentation for <code>parse_input_data</code>, <code>parse_output_data</code>, and CRUD methods</li> <li>Performance notes and error handling documentation</li> <li>Updated to use <code>NotFoundError</code> instead of generic <code>SerializeError</code> for 404 cases</li> </ul> Views <ul> <li>APIViewSet</li> <li>Applied <code>@unique_view</code> decorator to all generated CRUD methods (create, list, retrieve, update, delete)</li> <li>Removed manual <code>__name__</code> assignment in favor of decorator-based approach</li> <li>Cleaner method definitions without post-definition name mutations</li> <li>APIView</li> <li>Added comprehensive docstring explaining base class functionality</li> </ul> Authentication <ul> <li>AsyncJwtBearer</li> <li>Enhanced docstring (71 lines) with detailed attribute and method documentation</li> <li>Security considerations and best practices</li> <li>Integration examples with Auth0, Keycloak, and Firebase</li> </ul> Project Structure <ul> <li>Reorganized documentation structure with clear separation of concerns</li> </ul> Fixed <ul> <li>Consistent error handling using <code>NotFoundError</code> for object not found scenarios</li> <li>Proper async context management for database transactions</li> </ul> Documentation Improvements Tutorial Content <ul> <li>4,435 total lines of tutorial content</li> <li>120+ code examples across all tutorials</li> <li>50+ API usage examples with curl commands</li> <li>Comprehensive error handling examples</li> <li>Performance optimization tips and best practices</li> </ul> API Reference <ul> <li>3,994 total lines of API reference documentation</li> <li>Complete method signatures with parameter descriptions</li> <li>Return type documentation</li> <li>Error handling specifications</li> <li>Integration examples</li> </ul> Visual Assets <ul> <li>Swagger UI screenshots for all CRUD operations</li> <li>Logo and branding images</li> <li>Diagram examples (where applicable)</li> </ul> Notes Breaking Changes <p>None - This is a documentation and enhancement release</p> Migration Required <p>None - All changes are backward compatible</p> Known Issues <p>None reported</p> Links <ul> <li>Documentation: https://caspel26.github.io/django-ninja-aio-crud/</li> </ul>v0.10.3diff2025-09-23Release notes[0.10.3] - 2025-09-23 \ud83d\udd27 Changed <ul> <li>ModelUtil Refactoring: Extracted model field handling logic into separate property</li> <li>Added <code>model_fields</code> property to encapsulate <code>[field.name for field in self.model._meta.get_fields()]</code></li> <li>Updated <code>serializable_fields</code> property to use new <code>model_fields</code> property for non-ModelSerializerMeta models</li> </ul> \ud83d\udee0\ufe0f Fixed <ul> <li>Custom Field Filtering: Enhanced custom field detection logic to prevent conflicts with actual model fields</li> <li>Custom fields are now filtered to exclude fields that exist in the actual Django model</li> <li>Added <code>k not in self.model_fields</code> condition to both custom field dictionary comprehension and iteration logic</li> <li>Prevents custom serializer fields from overriding or conflicting with real model fields</li> </ul> \ud83d\udcc8 Improvements <ul> <li>Code Organization: Better separation of concerns with dedicated <code>model_fields</code> property</li> <li>Field Conflict Prevention: More robust handling of custom vs model field distinction</li> <li>Code Readability: Improved maintainability by reducing code duplication in field name extraction</li> </ul> \ud83d\udd04 Technical Details <ul> <li>The <code>customs</code> dictionary now only includes truly custom fields that don't exist on the model</li> <li>Custom field processing in the main loop now respects model field boundaries</li> <li>Better encapsulation of model introspection logic</li> </ul>v0.10.2diff2025-09-18Release notes[0.10.2] - 2025-09-18 \u2728 Added <ul> <li>Pagination Support for M2M Relations: Added <code>@paginate(self.pagination_class)</code> decorator to M2M <code>get_related</code> endpoints for better performance with large datasets</li> </ul> \ud83d\udd27 Changed <ul> <li>Code Quality Improvements:</li> <li>Cleaned up response schema formatting in M2M GET endpoints (removed unnecessary line breaks)</li> <li>Fixed spacing inconsistency in <code>self.error_codes</code> assignment</li> <li>Improved variable initialization readability in M2M management function</li> <li> <p>Added proper line spacing for better code organization</p> </li> <li> <p>Dynamic M2M Endpoint Documentation: </p> </li> <li>Enhanced summary and description generation for M2M endpoints based on available operations</li> <li>Summary now dynamically shows \"Add\", \"Remove\", or \"Add or Remove\" based on configuration</li> <li> <p>More intuitive endpoint descriptions that reflect actual capabilities</p> </li> <li> <p>Function Naming Convention:</p> </li> <li>Renamed <code>add_and_remove_related</code> to <code>manage_related</code> for better semantic clarity</li> <li> <p>Updated function name assignment to <code>manage_{model_name}_{relation_path}</code> pattern</p> </li> <li> <p>Schema Selection Logic: Refactored conditional schema assignment using ternary operators for better readability</p> </li> </ul> \ud83d\udee0\ufe0f Technical Improvements <ul> <li>Variable Declaration: Simplified tuple unpacking for M2M operation variables</li> <li>Code Formatting: Improved consistency in code spacing and line breaks</li> <li>Function Organization: Better separation of logic blocks with appropriate whitespace</li> </ul> \ud83d\udcc8 Performance <ul> <li>M2M related object listing now supports pagination, reducing memory usage and improving response times for large relationship sets</li> </ul>v0.10.1diff2025-09-18Release notes[0.10.1] - 2025-09-18 \u2728 Added <ul> <li>Pagination Support for M2M Relations: Added <code>@paginate(self.pagination_class)</code> decorator to M2M <code>get_related</code> endpoints for better performance with large datasets</li> </ul> \ud83d\udd27 Changed <ul> <li>Code Quality Improvements:</li> <li>Cleaned up response schema formatting in M2M GET endpoints (removed unnecessary line breaks)</li> <li>Fixed spacing inconsistency in <code>self.error_codes</code> assignment</li> <li>Improved variable initialization readability in M2M management function</li> <li> <p>Added proper line spacing for better code organization</p> </li> <li> <p>Dynamic M2M Endpoint Documentation: </p> </li> <li>Enhanced summary and description generation for M2M endpoints based on available operations</li> <li>Summary now dynamically shows \"Add\", \"Remove\", or \"Add or Remove\" based on configuration</li> <li> <p>More intuitive endpoint descriptions that reflect actual capabilities</p> </li> <li> <p>Function Naming Convention:</p> </li> <li>Renamed <code>add_and_remove_related</code> to <code>manage_related</code> for better semantic clarity</li> <li> <p>Updated function name assignment to <code>manage_{model_name}_{relation_path}</code> pattern</p> </li> <li> <p>Schema Selection Logic: Refactored conditional schema assignment using ternary operators for better readability</p> </li> </ul> \ud83d\udee0\ufe0f Technical Improvements <ul> <li>Variable Declaration: Simplified tuple unpacking for M2M operation variables</li> <li>Code Formatting: Improved consistency in code spacing and line breaks</li> <li>Function Organization: Better separation of logic blocks with appropriate whitespace</li> </ul> \ud83d\udcc8 Performance <ul> <li>M2M related object listing now supports pagination, reducing memory usage and improving response times for large relationship sets</li> </ul>v0.10.0diff2025-09-15Release notes[0.10.0] - 2025-09-15 \ud83d\ude80 Added <ul> <li>Many-to-Many Relations Support: Complete M2M relationship management system</li> <li>Added <code>M2MDetailSchema</code>, <code>M2MSchemaOut</code>, <code>M2MSchemaIn</code>, <code>M2MAddSchemaIn</code>, <code>M2MRemoveSchemaIn</code> schemas</li> <li>New <code>m2m_relations</code> configuration for defining M2M relationships to manage</li> <li><code>m2m_add</code>, <code>m2m_remove</code>, <code>m2m_get</code> boolean flags to control M2M operations</li> <li><code>m2m_auth</code> parameter for M2M-specific authentication</li> <li>Auto-generated M2M endpoints for getting, adding, and removing related objects</li> <li>Enhanced ModelUtil: Added return type annotations for better IDE support</li> <li>Async Support: Added <code>asyncio</code> import for concurrent M2M operations</li> </ul> \ud83d\udd27 Changed <ul> <li>BREAKING: Enhanced JWT authentication error handling in <code>AsyncJwtBearer</code></li> <li>Now returns <code>False</code> instead of raising <code>AuthError</code> for invalid tokens</li> <li>Added proper exception handling for <code>JoseError</code> during claims validation</li> <li>Improved authentication flow with better error recovery</li> <li>ModelUtil.get_object(): Enhanced to return QuerySet when no primary key is provided</li> <li>APIViewSet Documentation: Updated class docstring with M2M configuration options</li> </ul> \ud83d\udee0\ufe0f Fixed <ul> <li>JWT Error Handling: More graceful handling of JWT decode and validation errors</li> <li>Import Organization: Added missing <code>errors</code> import from <code>joserfc</code></li> </ul> \ud83d\udcda Technical Details <ul> <li>Added <code>_check_m2m_objs()</code> helper method for M2M object validation</li> <li>Added <code>_m2m_views()</code> method for automatic M2M endpoint generation</li> <li>M2M operations use <code>asyncio.gather()</code> for concurrent add/remove operations</li> <li>Dynamic function naming for M2M endpoints to avoid conflicts</li> <li>Comprehensive error reporting for M2M operations with detailed success/failure counts</li> </ul> \ud83d\udd04 Migration Notes <ul> <li>Update JWT error handling if you were catching <code>AuthError</code> exceptions</li> <li>Configure <code>m2m_relations</code> if you want to use the new M2M management features</li> <li>Review authentication flows as JWT validation now returns <code>False</code> instead of raising errors</li> </ul>0.9.2diff2025-08-25Release notes[0.9.2] - 2025-08-25 Changed <ul> <li>BREAKING: Refactored route registration system in <code>APIViewSet</code></li> <li>All CRUD views now use <code>@self.router</code> decorators instead of <code>@self.api</code> </li> <li>Simplified path handling by using class properties (<code>self.path</code>, <code>self.get_path</code>, etc.) instead of string concatenation</li> <li>Removed explicit <code>tags</code> parameter from individual view decorators (now handled at router level)</li> <li>Streamlined <code>add_views_to_route()</code> method to directly return router registration</li> </ul> Removed <ul> <li>Removed manual <code>tags=[self.router_tag]</code> from all CRUD view decorators (create, list, retrieve, update, delete)</li> </ul> Added <ul> <li>Added comprehensive <code>test_crud_routes()</code> test method to validate:</li> <li>Correct route paths are registered</li> <li>Proper handling of excluded views</li> <li>Path names are correctly assigned for all CRUD operations</li> </ul> Technical Details <ul> <li>Route paths now use dynamic properties instead of hardcoded string formatting</li> <li>Router registration is now more efficient with inline view addition</li> <li>Improved test coverage for route validation and exclusion scenarios</li> </ul>v0.9.1diff2025-08-25Release notes[0.9.1] - 2025-08-25 Changed <ul> <li>Bumped version from 0.9.0 to 0.9.1 by @caspel26 </li> </ul> Removed <ul> <li>Removed <code>test_crud_routes()</code> method from test suite in <code>tests/generics/views.py</code> by @caspel26 </li> </ul> Fixed <ul> <li>Fixed missing API assignment in <code>_create_relation()</code> method - added <code>cls.relation_viewset.api = cls.api</code> before view creation by @caspel26</li> </ul> Technical Details <ul> <li>Cleaned up test code by removing redundant route testing logic by @caspel26 </li> <li>Improved test reliability by ensuring proper API context in relation creation helper method by @caspel26</li> </ul>v0.9.0diff2025-07-18Release notes [0.9.0] - 2025-07-18 Changed <ul> <li>Removed trailing slashes from base API routes by @caspel26 </li> <li>Renamed <code>add_views()</code> to <code>_add_views()</code> (now private implementation method) by @caspel26 </li> <li>Added comprehensive docstrings to <code>APIViewSet</code> class by @caspel26 </li> <li>Added view-specific documentation properties by @caspel26 :</li> <li><code>list_docs</code></li> <li><code>create_docs</code></li> <li><code>retrieve_docs</code></li> <li><code>update_docs</code></li> <li><code>delete_docs</code></li> <li>Added automatic endpoint summaries and descriptions based on model metadata by @caspel26 </li> <li>Improved path handling with new properties by @caspel26 :</li> <li><code>get_path</code></li> <li><code>get_path_retrieve</code></li> <li>Added <code>model_verbose_name</code> property for consistent naming by @caspel26 </li> <li>Updated test paths to match new URL structure by @caspel26 </li> <li>Added trailing slash to <code>api_route_path</code> in test view classes by @caspel26</li> </ul>v0.8.4diff2025-06-20Release notes[0.8.4] - 2025-06-20 Changes to <code>ninja_aio/views.py</code> Refactoring <ul> <li>Updated <code>self.router_tag</code> assignment:</li> <li>Before: <code>self.router_tag = self.model_util.model_name.capitalize()</code></li> <li>After: <code>self.router_tag = \" \".join(self.model._meta.verbose_name.capitalize().split(\" \"))</code></li> <li>This change improves the readability of the router tag by using the model's <code>verbose_name</code>, preserving spacing between words. by @caspel26 </li> </ul> Minor Fixes <ul> <li>Removed unnecessary trailing spaces in <code>*_view_auth()</code> methods (<code>get_view_auth</code>, <code>post_view_auth</code>, <code>patch_view_auth</code>, <code>delete_view_auth</code>). by @caspel26</li> </ul>v0.8.3diff2025-06-18Release notes[0.8.3] - 2025-06-18 Changed <ul> <li>Updated version number from <code>0.8.2</code> to <code>0.8.3</code>. by @caspel26 </li> </ul> Fixed <ul> <li>Improved the <code>_auth_view</code> method in <code>APIViewSet</code> to avoid potential <code>AttributeError</code> by using <code>getattr(..., None)</code> with a default value. by @caspel26</li> </ul>v0.8.2diff2025-06-18Release notes[0.8.2] - 2025-06-18 Added <ul> <li>Introduced per-method authentication options to <code>APIViewSet</code>:</li> <li><code>get_auth</code></li> <li><code>post_auth</code></li> <li><code>patch_auth</code></li> <li><code>delete_auth</code> by @caspel26 </li> <li>Added helper methods to resolve per-method auth:</li> <li><code>get_view_auth()</code></li> <li><code>post_view_auth()</code></li> <li><code>patch_view_auth()</code></li> <li><code>delete_view_auth()</code> by @caspel26 </li> </ul> Changed <ul> <li>All route decorators (<code>@router.get</code>, <code>@router.post</code>, etc.) now use the new per-method auth resolution instead of the global <code>auth</code> attribute. by @caspel26 </li> <li>Minor type ignore hints (<code># type: ignore</code>) added for compatibility and typing support. by @caspel26 </li> </ul> Fixed <ul> <li>Ensured route-specific authentication is configurable and overrides the global <code>auth</code> setting properly when defined. by @caspel26</li> </ul>v0.8.1diff2025-06-18Release notes News: <ul> <li>Added support for IPAddress serialization by @caspel26 </li> </ul> <p>Full Changelog: https://github.com/caspel26/django-ninja-aio-crud/compare/v0.8.0...v0.8.1</p>v0.8.0diff2025-05-15-Release notes<p>No release notes.</p>v0.7.8diff2025-03-21-Release notes<p>No release notes.</p>v0.7.7diff2025-03-05-Release notes<p>No release notes.</p>v0.7.6diff2025-02-24-Release notes<p>No release notes.</p>v0.7.5diff2025-02-22-Release notes<p>No release notes.</p>v0.7.4diff2025-02-20-Release notes<p>No release notes.</p>v0.7.3diff2025-02-19-Release notes<p>No release notes.</p>v0.7.2diff2025-01-30-Release notes<p>No release notes.</p>v0.7.1diff2025-01-29-Release notes<p>No release notes.</p>v0.7.0diff2025-01-29-Release notes<p>No release notes.</p>v0.6.4diff2025-01-22-Release notes<p>No release notes.</p>v0.6.3diff2025-01-22-Release notes<p>No release notes.</p>v0.6.2diff2025-01-19-Release notes<p>No release notes.</p>v0.6.1diff2025-01-13-Release notes<p>No release notes.</p>v0.6.0diff2025-01-12-Release notes<p>No release notes.</p>v0.5.0diff2025-01-09-Release notes<p>No release notes.</p>v0.4.0diff2025-01-08-Release notes<p>No release notes.</p>v0.3.1diff2024-11-07-Release notes<p>No release notes.</p>v0.3.0diff2024-10-10-Release notes<p>No release notes.</p>v0.2.2diff2024-10-03-Release notes<p>No release notes.</p>v0.2.1diff2024-10-02-Release notes<p>No release notes.</p>v0.2.0diff2024-10-01-Release notes<p>No release notes.</p>v0.1.4diff2024-09-29-Release notes<p>No release notes.</p>v0.1.3diff2024-09-28-Release notes<p>No release notes.</p>v0.1.2diff2024-09-26-Release notes<p>No release notes.</p>v0.1.1diff2024-09-26-Release notes<p>No release notes.</p>"},{"location":"api/authentication/","title":"Authentication","text":"<p>Django Ninja Aio CRUD provides built-in async JWT authentication support with flexible configuration and easy integration with your API endpoints.</p>"},{"location":"api/authentication/#overview","title":"Overview","text":"<p>Authentication in Django Ninja Aio CRUD: - Fully Async - No blocking operations - JWT-Based - Industry-standard JSON Web Tokens - Type-Safe - Proper type hints and validation - Flexible - Per-endpoint or global authentication - Customizable - Override default behavior - RSA/HMAC Support - Multiple signing algorithms</p>"},{"location":"api/authentication/#quick-start","title":"Quick Start","text":""},{"location":"api/authentication/#1-create-authentication-class","title":"1. Create Authentication Class","text":"Python<pre><code># auth.py\nfrom ninja_aio.auth import AsyncJwtBearer\nfrom joserfc import jwk\n\nPUBLIC_KEY = \"\"\"-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...\n-----END PUBLIC KEY-----\"\"\"\n\n\nclass JWTAuth(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(PUBLIC_KEY)\n    claims = {\n        \"iss\": {\"essential\": True, \"value\": \"https://your-issuer.com\"},\n        \"aud\": {\"essential\": True, \"value\": \"your-api\"}\n    }\n\n    async def auth_handler(self, request):\n        user_id = self.dcd.claims.get(\"sub\")\n        user = await User.objects.aget(id=user_id)\n        return user\n</code></pre>"},{"location":"api/authentication/#2-apply-to-viewset","title":"2. Apply to ViewSet","text":"Python<pre><code># views.py\nfrom ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom .models import Article\nfrom .auth import JWTAuth\n\napi = NinjaAIO()\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    auth = [JWTAuth()]  # Apply to all endpoints\n\n\nArticleViewSet().add_views_to_route()\n</code></pre>"},{"location":"api/authentication/#3-make-authenticated-request","title":"3. Make Authenticated Request","text":"Bash<pre><code>curl -H \"Authorization: Bearer eyJhbGciOiJSUzI1NiIs...\" \\\n     http://localhost:8000/api/article/\n</code></pre>"},{"location":"api/authentication/#asyncjwtbearer","title":"AsyncJwtBearer","text":"<p>Base class for JWT authentication.</p>"},{"location":"api/authentication/#class-definition","title":"Class Definition","text":"Python<pre><code>from ninja_aio.auth import AsyncJwtBearer\nfrom joserfc import jwk\n\nclass MyAuth(AsyncJwtBearer):\n    jwt_public: jwk.RSAKey | jwk.OctKey  # Public key for verification\n    jwt_alg: str = \"RS256\"  # Signing algorithm\n    claims: dict = {}  # Required claims\n\n    async def auth_handler(self, request):\n        # Return user object or custom auth context\n        pass\n</code></pre>"},{"location":"api/authentication/#required-attributes","title":"Required Attributes","text":""},{"location":"api/authentication/#jwt_public","title":"<code>jwt_public</code>","text":"<p>Public key for JWT verification.</p> <p>RSA Key (Recommended):</p> Python<pre><code>from joserfc import jwk\n\nPUBLIC_KEY = \"\"\"-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...\n-----END PUBLIC KEY-----\"\"\"\n\nclass JWTAuth(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(PUBLIC_KEY)\n    jwt_alg = \"RS256\"\n</code></pre> <p>HMAC Key (Shared Secret):</p> Python<pre><code>from joserfc import jwk\n\nSECRET = \"your-secret-key\"\n\nclass JWTAuth(AsyncJwtBearer):\n    jwt_public = jwk.OctKey.import_key(SECRET)\n    jwt_alg = \"HS256\"\n</code></pre> <p>From JWK (JSON Web Key):</p> Python<pre><code>import json\nfrom joserfc import jwk\n\njwk_data = {\n    \"kty\": \"RSA\",\n    \"n\": \"xGOr-H7A-PWgPZ...\",\n    \"e\": \"AQAB\",\n    \"alg\": \"RS256\",\n    \"use\": \"sig\"\n}\n\nclass JWTAuth(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(jwk_data)\n</code></pre>"},{"location":"api/authentication/#jwt_alg","title":"<code>jwt_alg</code>","text":"<p>JWT signing algorithm (optional, default: <code>\"RS256\"</code>).</p> <p>Supported Algorithms:</p> Algorithm Type Description <code>RS256</code> RSA RSA Signature with SHA-256 (recommended) <code>RS384</code> RSA RSA Signature with SHA-384 <code>RS512</code> RSA RSA Signature with SHA-512 <code>HS256</code> HMAC HMAC with SHA-256 <code>HS384</code> HMAC HMAC with SHA-384 <code>HS512</code> HMAC HMAC with SHA-512 <code>ES256</code> ECDSA ECDSA with SHA-256 <code>ES384</code> ECDSA ECDSA with SHA-384 <code>ES512</code> ECDSA ECDSA with SHA-512 Python<pre><code>class JWTAuth(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(PUBLIC_KEY)\n    jwt_alg = \"RS512\"  # Use RS512 instead of default RS256\n</code></pre>"},{"location":"api/authentication/#claims","title":"<code>claims</code>","text":"<p>Dictionary of required JWT claims for validation.</p> <p>Claim Options:</p> Key Type Description <code>essential</code> <code>bool</code> Claim must be present <code>value</code> <code>Any</code> Exact value required <code>values</code> <code>list</code> One of the values required <p>Examples:</p> Python<pre><code>class JWTAuth(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(PUBLIC_KEY)\n    claims = {\n        # Issuer must be exact match\n        \"iss\": {\n            \"essential\": True,\n            \"value\": \"https://auth.example.com\"\n        },\n        # Audience must be one of these\n        \"aud\": {\n            \"essential\": True,\n            \"values\": [\"api-prod\", \"api-staging\"]\n        },\n        # Subject must be present (any value)\n        \"sub\": {\n            \"essential\": True\n        },\n        # Optional claim with default\n        \"scope\": {\n            \"essential\": False,\n            \"value\": \"read\"\n        }\n    }\n</code></pre>"},{"location":"api/authentication/#required-methods","title":"Required Methods","text":""},{"location":"api/authentication/#auth_handler","title":"<code>auth_handler()</code>","text":"<p>Process authenticated request and return user/auth context.</p> <p>Signature:</p> Python<pre><code>async def auth_handler(self, request: HttpRequest) -&gt; Any\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>request</code> <code>HttpRequest</code> Django HTTP request <p>Return Value:</p> <p>Object attached to <code>request.auth</code> (typically User instance).</p> <p>Access to JWT Data:</p> <ul> <li><code>self.dcd</code> - Decoded JWT claims</li> <li><code>self.dcd.claims</code> - Claims dictionary</li> <li><code>self.dcd.header</code> - JWT header</li> </ul> <p>Examples:</p> <p>Return User Object:</p> Python<pre><code>async def auth_handler(self, request):\n    user_id = self.dcd.claims.get(\"sub\")\n    user = await User.objects.aget(id=user_id)\n    return user\n\n# In view\nasync def my_view(request):\n    user = request.auth  # User instance\n    print(user.username)\n</code></pre> <p>Return Custom Context:</p> Python<pre><code>async def auth_handler(self, request):\n    return {\n        \"user_id\": self.dcd.claims.get(\"sub\"),\n        \"email\": self.dcd.claims.get(\"email\"),\n        \"roles\": self.dcd.claims.get(\"roles\", []),\n        \"scopes\": self.dcd.claims.get(\"scope\", \"\").split()\n    }\n\n# In view\nasync def my_view(request):\n    context = request.auth\n    print(context[\"user_id\"])\n    print(context[\"roles\"])\n</code></pre> <p>With Additional Validation:</p> Python<pre><code>async def auth_handler(self, request):\n    user_id = self.dcd.claims.get(\"sub\")\n\n    # Check if user exists and is active\n    try:\n        user = await User.objects.aget(id=user_id, is_active=True)\n    except User.DoesNotExist:\n        return False\n\n    # Check subscription status\n    if not await user.has_active_subscription():\n        return False\n\n    return user\n</code></pre> <p>With Caching:</p> Python<pre><code>from django.core.cache import cache\n\nasync def auth_handler(self, request):\n    user_id = self.dcd.claims.get(\"sub\")\n\n    # Try cache first\n    cache_key = f\"user:{user_id}\"\n    user = cache.get(cache_key)\n\n    if user is None:\n        user = await User.objects.aget(id=user_id)\n        cache.set(cache_key, user, 300)  # Cache 5 minutes\n\n    return user\n</code></pre>"},{"location":"api/authentication/#authentication-levels","title":"Authentication Levels","text":""},{"location":"api/authentication/#global-authentication","title":"Global Authentication","text":"<p>Apply authentication to all endpoints in a ViewSet:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    auth = [JWTAuth()]  # All endpoints require auth\n</code></pre> <p>Generated Endpoints:</p> Method Endpoint Auth Required GET <code>/article/</code> \u2713 POST <code>/article/</code> \u2713 GET <code>/article/{id}</code> \u2713 PATCH <code>/article/{id}/</code> \u2713 DELETE <code>/article/{id}/</code> \u2713"},{"location":"api/authentication/#per-method-authentication","title":"Per-Method Authentication","text":"<p>Apply authentication to specific HTTP methods:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    get_auth = None  # GET endpoints public\n    post_auth = [JWTAuth()]  # POST requires auth\n    patch_auth = [JWTAuth()]  # PATCH requires auth\n    delete_auth = [JWTAuth()]  # DELETE requires auth\n</code></pre> <p>Generated Endpoints:</p> Method Endpoint Auth Required GET <code>/article/</code> \u2717 (public) POST <code>/article/</code> \u2713 GET <code>/article/{id}</code> \u2717 (public) PATCH <code>/article/{id}/</code> \u2713 DELETE <code>/article/{id}/</code> \u2713"},{"location":"api/authentication/#custom-view-authentication","title":"Custom View Authentication","text":"<p>Apply authentication to custom views:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    auth = None  # CRUD endpoints public\n\n    def views(self):\n        # Authenticated custom endpoint\n        @self.router.post(\"/publish/{pk}/\", auth=JWTAuth())\n        async def publish(request, pk: int):\n            article = await Article.objects.aget(pk=pk)\n            article.is_published = True\n            await article.asave()\n            return {\"message\": \"Article published\"}\n\n        # Public custom endpoint\n        @self.router.get(\"/stats/\")\n        async def stats(request):\n            total = await Article.objects.acount()\n            return {\"total\": total}\n</code></pre>"},{"location":"api/authentication/#mixed-authentication","title":"Mixed Authentication","text":"<p>Combine different authentication strategies:</p> Python<pre><code>class AdminAuth(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(PUBLIC_KEY)\n\n    async def auth_handler(self, request):\n        user_id = self.dcd.claims.get(\"sub\")\n        user = await User.objects.aget(id=user_id)\n        if not user.is_staff:\n            return False\n        return user\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    get_auth = None  # Public read\n    post_auth = [JWTAuth()]  # Regular user can create\n    patch_auth = [JWTAuth()]  # Regular user can edit own\n    delete_auth = [AdminAuth()]  # Only admin can delete\n</code></pre>"},{"location":"api/authentication/#advanced-usage","title":"Advanced Usage","text":""},{"location":"api/authentication/#role-based-access-control-rbac","title":"Role-Based Access Control (RBAC)","text":"Python<pre><code>class RoleAuth(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(PUBLIC_KEY)\n    required_roles: list[str] = []\n\n    async def auth_handler(self, request):\n        user_id = self.dcd.claims.get(\"sub\")\n        user = await User.objects.aget(id=user_id)\n\n        # Check roles\n        user_roles = self.dcd.claims.get(\"roles\", [])\n        if self.required_roles:\n            if not any(role in user_roles for role in self.required_roles):\n                return False\n\n        request.user_roles = user_roles\n        return user\n\n\nclass AdminAuth(RoleAuth):\n    required_roles = [\"admin\"]\n\n\nclass EditorAuth(RoleAuth):\n    required_roles = [\"editor\", \"admin\"]\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    get_auth = None\n    post_auth = [EditorAuth()]  # Editors and admins\n    delete_auth = [AdminAuth()]  # Only admins\n</code></pre>"},{"location":"api/authentication/#permission-based-access","title":"Permission-Based Access","text":"Python<pre><code>class PermissionAuth(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(PUBLIC_KEY)\n    required_permissions: list[str] = []\n\n    async def auth_handler(self, request):\n        user_id = self.dcd.claims.get(\"sub\")\n        user = await User.objects.select_related('role').aget(id=user_id)\n\n        # Get user permissions\n        permissions = await sync_to_async(list)(\n            user.role.permissions.values_list('code', flat=True)\n        )\n\n        # Check permissions\n        if self.required_permissions:\n            missing = set(self.required_permissions) - set(permissions)\n            if missing:\n                return False\n        request.permissions = permissions\n        return user\n\n\nclass ArticleCreateAuth(PermissionAuth):\n    required_permissions = [\"article.create\"]\n\n\nclass ArticleDeleteAuth(PermissionAuth):\n    required_permissions = [\"article.delete\"]\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    post_auth = [ArticleCreateAuth()]\n    delete_auth = [ArticleDeleteAuth()]\n</code></pre>"},{"location":"api/authentication/#tenantorganization-isolation","title":"Tenant/Organization Isolation","text":"Python<pre><code>class TenantAuth(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(PUBLIC_KEY)\n\n    async def auth_handler(self, request):\n        user_id = self.dcd.claims.get(\"sub\")\n        tenant_id = self.dcd.claims.get(\"tenant_id\")\n\n        if not tenant_id:\n            return False\n\n        user = await User.objects.aget(\n            id=user_id,\n            tenant_id=tenant_id,\n            is_active=True\n        )\n\n        request.tenant_id = tenant_id\n        return user\n\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    tenant = models.ForeignKey(Tenant, on_delete=models.CASCADE)\n\n    @classmethod\n    async def queryset_request(cls, request):\n        # Automatically filter by tenant\n        qs = cls.objects.all()\n        if hasattr(request, 'tenant_id'):\n            qs = qs.filter(tenant_id=request.tenant_id)\n        return qs\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    auth = [TenantAuth()]\n</code></pre>"},{"location":"api/authentication/#scope-based-access","title":"Scope-Based Access","text":"Python<pre><code>class ScopeAuth(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(PUBLIC_KEY)\n    required_scopes: list[str] = []\n\n    async def auth_handler(self, request):\n        # Get scopes from token\n        scope_str = self.dcd.claims.get(\"scope\", \"\")\n        scopes = scope_str.split()\n\n        # Check required scopes\n        if self.required_scopes:\n            missing = set(self.required_scopes) - set(scopes)\n            if missing:\n                return False\n\n        user_id = self.dcd.claims.get(\"sub\")\n        user = await User.objects.aget(id=user_id)\n\n        request.scopes = scopes\n        return user\n\n\nclass ReadAuth(ScopeAuth):\n    required_scopes = [\"read\"]\n\n\nclass WriteAuth(ScopeAuth):\n    required_scopes = [\"write\"]\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    get_auth = [ReadAuth()]  # read scope\n    post_auth = [WriteAuth()]  # write scope\n    patch_auth = [WriteAuth()]  # write scope\n    delete_auth = [WriteAuth()]  # write scope\n</code></pre>"},{"location":"api/authentication/#api-key-authentication","title":"API Key Authentication","text":"<p>For machine-to-machine communication:</p> Python<pre><code>from ninja.security import APIKeyHeader\n\n\nclass APIKeyAuth(APIKeyHeader):\n    param_name = \"X-API-Key\"\n\n    async def authenticate(self, request, key):\n        try:\n            api_key = await APIKey.objects.select_related('user').aget(\n                key=key,\n                is_active=True\n            )\n\n            # Check expiration\n            if api_key.expires_at and api_key.expires_at &lt; timezone.now():\n                return None\n\n            # Update last used\n            api_key.last_used_at = timezone.now()\n            await api_key.asave(update_fields=['last_used_at'])\n\n            return api_key.user\n        except APIKey.DoesNotExist:\n            return None\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    auth = [APIKeyAuth()]\n</code></pre> <p>Usage:</p> Bash<pre><code>curl -H \"X-API-Key: your-api-key-here\" \\\n     http://localhost:8000/api/article/\n</code></pre>"},{"location":"api/authentication/#multiple-authentication-methods","title":"Multiple Authentication Methods","text":"<p>Support both JWT and API Key:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    auth = [JWTAuth(), APIKeyAuth()]  # Either JWT or API Key\n</code></pre> <p>Django Ninja will try both methods; if either succeeds, the request is authenticated.</p>"},{"location":"api/authentication/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Use RSA (asymmetric) keys for production: Python<pre><code>jwt_public = jwk.RSAKey.import_key(PUBLIC_KEY)\njwt_alg = \"RS256\"\n</code></pre></p> </li> <li> <p>Validate essential claims: Python<pre><code>claims = {\n    \"iss\": {\"essential\": True, \"value\": \"your-issuer\"},\n    \"aud\": {\"essential\": True, \"value\": \"your-api\"},\n    \"sub\": {\"essential\": True}\n}\n</code></pre></p> </li> <li> <p>Keep tokens short-lived: Python<pre><code># In your token issuer\nexp = datetime.utcnow() + timedelta(minutes=15)  # 15 min access token\n</code></pre></p> </li> <li> <p>Cache user objects: Python<pre><code>async def auth_handler(self, request):\n    user_id = self.dcd.claims.get(\"sub\")\n    cache_key = f\"user:{user_id}\"\n    user = cache.get(cache_key)\n    if not user:\n        user = await User.objects.aget(id=user_id)\n        cache.set(cache_key, user, 300)\n    return user\n</code></pre></p> </li> <li> <p>Log authentication failures: Python<pre><code>async def auth_handler(self, request):\n    try:\n        user = await User.objects.aget(id=user_id)\n        return user\n    except User.DoesNotExist:\n        logger.warning(f\"Auth failed for user_id: {user_id}\")\n        return False\n</code></pre></p> </li> <li> <p>Use different auth for different operations: Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    get_auth = None  # Public read\n    post_auth = [UserAuth()]  # User can create\n    delete_auth = [AdminAuth()]  # Only admin can delete\n</code></pre></p> </li> <li> <p>Implement rate limiting for auth endpoints: Python<pre><code>from ninja.throttling import AnonRateThrottle\n\n@api.post(\"/login/\", throttle=[AnonRateThrottle('5/minute')])\nasync def login(request, credentials: LoginSchema):\n    # Login logic\n    pass\n</code></pre></p> </li> </ol>"},{"location":"api/authentication/#integration-examples","title":"Integration Examples","text":""},{"location":"api/authentication/#with-auth0","title":"With Auth0","text":"Python<pre><code>import httpx\nfrom joserfc import jwk\n\n\nclass Auth0JWT(AsyncJwtBearer):\n    jwt_alg = \"RS256\"\n\n    def __init__(self):\n        super().__init__()\n        # Fetch JWKS from Auth0\n        self.domain = \"your-domain.auth0.com\"\n        self.audience = \"your-api-identifier\"\n\n    async def get_jwks(self):\n        async with httpx.AsyncClient() as client:\n            response = await client.get(\n                f\"https://{self.domain}/.well-known/jwks.json\"\n            )\n            return response.json()\n\n    claims = {\n        \"iss\": {\"essential\": True, \"value\": \"https://your-domain.auth0.com/\"},\n        \"aud\": {\"essential\": True, \"value\": \"your-api-identifier\"}\n    }\n\n    async def auth_handler(self, request):\n        user_id = self.dcd.claims.get(\"sub\")\n        # Extract user info from token or fetch from database\n        return {\"user_id\": user_id, \"email\": self.dcd.claims.get(\"email\")}\n</code></pre>"},{"location":"api/authentication/#with-keycloak","title":"With Keycloak","text":"Python<pre><code>class KeycloakJWT(AsyncJwtBearer):\n    jwt_alg = \"RS256\"\n\n    def __init__(self):\n        super().__init__()\n        self.realm_url = \"https://keycloak.example.com/realms/your-realm\"\n\n    async def get_public_key(self):\n        async with httpx.AsyncClient() as client:\n            response = await client.get(f\"{self.realm_url}\")\n            data = response.json()\n            return jwk.RSAKey.import_key(data[\"public_key\"])\n\n    claims = {\n        \"iss\": {\"essential\": True, \"value\": \"https://keycloak.example.com/realms/your-realm\"},\n        \"azp\": {\"essential\": True, \"value\": \"your-client-id\"}\n    }\n\n    async def auth_handler(self, request):\n        user_id = self.dcd.claims.get(\"sub\")\n        roles = self.dcd.claims.get(\"realm_access\", {}).get(\"roles\", [])\n        return {\n            \"user_id\": user_id,\n            \"roles\": roles,\n            \"email\": self.dcd.claims.get(\"email\")\n        }\n</code></pre>"},{"location":"api/authentication/#with-firebase","title":"With Firebase","text":"Python<pre><code>import google.auth.transport.requests\nfrom google.oauth2 import id_token\n\n\nclass FirebaseAuth(HttpBearer):\n    def __init__(self):\n        self.project_id = \"your-firebase-project\"\n\n    async def authenticate(self, request, token):\n        try:\n            # Verify Firebase ID token\n            decoded_token = id_token.verify_firebase_token(\n                token,\n                google.auth.transport.requests.Request(),\n                audience=self.project_id\n            )\n\n            user_id = decoded_token[\"uid\"]\n            user = await User.objects.aget(firebase_uid=user_id)\n            return user\n        except Exception as e:\n            return None\n</code></pre>"},{"location":"api/authentication/#see-also","title":"See Also","text":"<ul> <li>API ViewSet - Applying auth to ViewSets</li> <li>Tutorial: Authentication - Step-by-step guide</li> <li>Model Serializer - Filtering by authenticated user</li> </ul>"},{"location":"api/pagination/","title":"Pagination","text":"<p>Django Ninja Aio CRUD provides built-in async pagination support for efficiently handling large datasets in your API responses.</p>"},{"location":"api/pagination/#overview","title":"Overview","text":"<p>Pagination in Django Ninja Aio CRUD:</p> <ul> <li>Fully async - No blocking database queries</li> <li>Customizable - Override default behavior per ViewSet</li> <li>Type-safe - Proper type hints and validation</li> <li>Automatic - Works out of the box with APIViewSet</li> <li>Flexible - Support for multiple pagination styles</li> </ul>"},{"location":"api/pagination/#default-pagination","title":"Default Pagination","text":""},{"location":"api/pagination/#pagenumberpagination","title":"PageNumberPagination","text":"<p>The default pagination class used by <code>APIViewSet</code>.</p> <p>Features:</p> <ul> <li>Page-based navigation</li> <li>Configurable page size</li> <li>Total count included</li> <li>Next/previous page info</li> </ul> <p>Default Configuration:</p> Parameter Default Description <code>page</code> <code>1</code> Current page number <code>page_size</code> <code>10</code> Items per page <code>max_page_size</code> <code>100</code> Maximum allowed page size"},{"location":"api/pagination/#response-format","title":"Response Format","text":"JSON<pre><code>{\n  \"count\": 45,\n  \"next\": 3,\n  \"previous\": 1,\n  \"results\": [\n    {\n      \"id\": 11,\n      \"title\": \"Article 11\",\n      \"created_at\": \"2024-01-15T10:30:00Z\"\n    },\n    {\n      \"id\": 12,\n      \"title\": \"Article 12\",\n      \"created_at\": \"2024-01-15T11:00:00Z\"\n    }\n  ]\n}\n</code></pre> <p>Response Fields:</p> Field Type Description <code>count</code> <code>int</code> Total number of items <code>next</code> <code>int \\| None</code> Next page number (null if last page) <code>previous</code> <code>int \\| None</code> Previous page number (null if first page) <code>results</code> <code>list</code> Array of items for current page"},{"location":"api/pagination/#basic-usage","title":"Basic Usage","text":""},{"location":"api/pagination/#with-apiviewset","title":"With APIViewSet","text":"<p>Pagination is automatically applied to list endpoints:</p> Python<pre><code>from ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom .models import Article\n\napi = NinjaAIO()\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n\nArticleViewSet().add_views_to_route()\n</code></pre> <p>Generated endpoint:</p> Text Only<pre><code>GET /article/?page=1&amp;page_size=10\n</code></pre>"},{"location":"api/pagination/#manual-usage","title":"Manual Usage","text":"Python<pre><code>from ninja.pagination import PageNumberPagination\nfrom django.http import HttpRequest\n\nasync def my_view(request: HttpRequest):\n    # Get queryset\n    queryset = Article.objects.all()\n\n    # Create paginator\n    paginator = PageNumberPagination()\n\n    # Paginate (accepts query params from request)\n    result = await paginator.apaginate_queryset(\n        queryset=queryset,\n        pagination=paginator,\n        request=request\n    )\n\n    return result\n</code></pre>"},{"location":"api/pagination/#query-parameters","title":"Query Parameters","text":""},{"location":"api/pagination/#page","title":"page","text":"<p>Current page number (1-indexed).</p> Bash<pre><code>GET /article/?page=2\n</code></pre> <p>Validation:</p> <ul> <li>Must be &gt;= 1</li> <li>Returns 404 if page doesn't exist</li> </ul>"},{"location":"api/pagination/#page_size","title":"page_size","text":"<p>Number of items per page.</p> Bash<pre><code>GET /article/?page=1&amp;page_size=20\n</code></pre> <p>Validation:</p> <ul> <li>Must be &gt;= 1</li> <li>Cannot exceed <code>max_page_size</code></li> <li>Defaults to pagination class default</li> </ul>"},{"location":"api/pagination/#examples","title":"Examples","text":"<p>First page with 10 items:</p> Bash<pre><code>GET /article/?page=1&amp;page_size=10\n</code></pre> <p>Second page with 25 items:</p> Bash<pre><code>GET /article/?page=2&amp;page_size=25\n</code></pre> <p>Maximum items per page:</p> Bash<pre><code>GET /article/?page=1&amp;page_size=100\n</code></pre>"},{"location":"api/pagination/#custom-pagination","title":"Custom Pagination","text":""},{"location":"api/pagination/#override-default-page-size","title":"Override Default Page Size","text":"Python<pre><code>from ninja.pagination import PageNumberPagination\n\n\nclass LargePagePagination(PageNumberPagination):\n    page_size = 50  # Default 50 items per page\n    max_page_size = 200  # Allow up to 200 items\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    pagination_class = LargePagePagination\n</code></pre>"},{"location":"api/pagination/#small-page-size-for-mobile","title":"Small Page Size for Mobile","text":"Python<pre><code>class MobilePagination(PageNumberPagination):\n    page_size = 5\n    max_page_size = 20\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    pagination_class = MobilePagination\n</code></pre>"},{"location":"api/pagination/#asyncpaginationbase","title":"AsyncPaginationBase","text":"<p>Base class for creating custom pagination.</p>"},{"location":"api/pagination/#class-definition","title":"Class Definition","text":"Python<pre><code>from ninja.pagination import AsyncPaginationBase\n\nclass MyPagination(AsyncPaginationBase):\n    page_size: int = 10\n    max_page_size: int = 100\n\n    async def apaginate_queryset(\n        self,\n        queryset,\n        pagination,\n        request=None,\n        **params\n    ):\n        # Custom pagination logic\n        pass\n</code></pre>"},{"location":"api/pagination/#required-methods","title":"Required Methods","text":""},{"location":"api/pagination/#apaginate_queryset","title":"<code>apaginate_queryset()</code>","text":"<p>Main pagination method that processes the queryset.</p> <p>Signature:</p> Python<pre><code>async def apaginate_queryset(\n    self,\n    queryset: QuerySet,\n    pagination: AsyncPaginationBase,\n    request: HttpRequest = None,\n    **params\n) -&gt; dict\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>queryset</code> <code>QuerySet</code> Django queryset to paginate <code>pagination</code> <code>AsyncPaginationBase</code> Pagination instance <code>request</code> <code>HttpRequest</code> HTTP request object <code>**params</code> <code>dict</code> Additional parameters <p>Returns:</p> <p>Dictionary with pagination metadata and results.</p>"},{"location":"api/pagination/#custom-pagination-examples","title":"Custom Pagination Examples","text":""},{"location":"api/pagination/#cursor-based-pagination","title":"Cursor-Based Pagination","text":"Python<pre><code>from ninja.pagination import AsyncPaginationBase\nfrom ninja import Schema\n\n\nclass CursorPaginationSchema(Schema):\n    cursor: str | None = None\n    page_size: int = 10\n\n\nclass CursorPagination(AsyncPaginationBase):\n    page_size = 10\n    max_page_size = 100\n\n    async def apaginate_queryset(self, queryset, pagination, request=None, **params):\n        cursor = params.get('cursor')\n        page_size = min(params.get('page_size', self.page_size), self.max_page_size)\n\n        # Apply cursor filtering\n        if cursor:\n            queryset = queryset.filter(id__gt=cursor)\n\n        # Fetch items + 1 to check if there's next page\n        items = []\n        async for item in queryset[:page_size + 1]:\n            items.append(item)\n\n        has_next = len(items) &gt; page_size\n        results = items[:page_size]\n\n        next_cursor = None\n        if has_next and results:\n            next_cursor = str(results[-1].id)\n\n        return {\n            \"next_cursor\": next_cursor,\n            \"results\": results\n        }\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    pagination_class = CursorPagination\n</code></pre> <p>Usage:</p> Bash<pre><code># First page\nGET /article/?page_size=10\n\n# Next page\nGET /article/?cursor=10&amp;page_size=10\n</code></pre> <p>Response:</p> JSON<pre><code>{\n  \"next_cursor\": \"20\",\n  \"results\": [...]\n}\n</code></pre>"},{"location":"api/pagination/#offset-based-pagination","title":"Offset-Based Pagination","text":"Python<pre><code>class OffsetPagination(AsyncPaginationBase):\n    page_size = 10\n    max_page_size = 100\n\n    async def apaginate_queryset(self, queryset, pagination, request=None, **params):\n        offset = params.get('offset', 0)\n        limit = min(params.get('limit', self.page_size), self.max_page_size)\n\n        # Get total count\n        total_count = await queryset.acount()\n\n        # Slice queryset\n        items = []\n        async for item in queryset[offset:offset + limit]:\n            items.append(item)\n\n        return {\n            \"count\": total_count,\n            \"offset\": offset,\n            \"limit\": limit,\n            \"results\": items\n        }\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    pagination_class = OffsetPagination\n</code></pre> <p>Usage:</p> Bash<pre><code># First 10 items\nGET /article/?offset=0&amp;limit=10\n\n# Next 10 items\nGET /article/?offset=10&amp;limit=10\n\n# Skip 20, get 15\nGET /article/?offset=20&amp;limit=15\n</code></pre> <p>Response:</p> JSON<pre><code>{\n  \"count\": 100,\n  \"offset\": 20,\n  \"limit\": 15,\n  \"results\": [...]\n}\n</code></pre>"},{"location":"api/pagination/#link-header-pagination","title":"Link Header Pagination","text":"Python<pre><code>from django.http import HttpResponse\n\n\nclass LinkHeaderPagination(AsyncPaginationBase):\n    page_size = 10\n    max_page_size = 100\n\n    async def apaginate_queryset(self, queryset, pagination, request=None, **params):\n        page = params.get('page', 1)\n        page_size = min(params.get('page_size', self.page_size), self.max_page_size)\n\n        total_count = await queryset.acount()\n        total_pages = (total_count + page_size - 1) // page_size\n\n        start = (page - 1) * page_size\n        end = start + page_size\n\n        items = []\n        async for item in queryset[start:end]:\n            items.append(item)\n\n        # Build Link header\n        base_url = request.build_absolute_uri(request.path)\n        links = []\n\n        if page &gt; 1:\n            links.append(f'&lt;{base_url}?page={page-1}&amp;page_size={page_size}&gt;; rel=\"prev\"')\n        if page &lt; total_pages:\n            links.append(f'&lt;{base_url}?page={page+1}&amp;page_size={page_size}&gt;; rel=\"next\"')\n\n        links.append(f'&lt;{base_url}?page=1&amp;page_size={page_size}&gt;; rel=\"first\"')\n        links.append(f'&lt;{base_url}?page={total_pages}&amp;page_size={page_size}&gt;; rel=\"last\"')\n\n        return {\n            \"results\": items,\n            \"_links\": \", \".join(links)\n        }\n</code></pre> <p>Response Headers:</p> Text Only<pre><code>Link: &lt;http://api.example.com/article/?page=1&amp;page_size=10&gt;; rel=\"first\",\n      &lt;http://api.example.com/article/?page=2&amp;page_size=10&gt;; rel=\"prev\",\n      &lt;http://api.example.com/article/?page=4&amp;page_size=10&gt;; rel=\"next\",\n      &lt;http://api.example.com/article/?page=10&amp;page_size=10&gt;; rel=\"last\"\n</code></pre>"},{"location":"api/pagination/#disable-pagination","title":"Disable Pagination","text":""},{"location":"api/pagination/#for-specific-viewset","title":"For Specific ViewSet","text":"Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    pagination_class = None  # Disable pagination\n</code></pre> <p>Now the list endpoint returns all items without pagination:</p> Bash<pre><code>GET /article/\n</code></pre> JSON<pre><code>[\n  {\"id\": 1, \"title\": \"Article 1\"},\n  {\"id\": 2, \"title\": \"Article 2\"},\n  ...\n]\n</code></pre>"},{"location":"api/pagination/#conditional-pagination","title":"Conditional Pagination","text":"Python<pre><code>class ConditionalPagination(PageNumberPagination):\n    async def apaginate_queryset(self, queryset, pagination, request=None, **params):\n        # Disable pagination if 'all' parameter is present\n        if params.get('all'):\n            items = []\n            async for item in queryset:\n                items.append(item)\n            return {\"results\": items}\n\n        # Otherwise use default pagination\n        return await super().apaginate_queryset(queryset, pagination, request, **params)\n</code></pre> <p>Usage:</p> Bash<pre><code># Paginated\nGET /article/?page=1&amp;page_size=10\n\n# All items\nGET /article/?all=true\n</code></pre>"},{"location":"api/pagination/#integration-with-filtering","title":"Integration with Filtering","text":"<p>Pagination works seamlessly with query parameter filtering:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    query_params = {\n        \"is_published\": (bool, None),\n        \"category\": (int, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        if filters.get(\"is_published\") is not None:\n            queryset = queryset.filter(is_published=filters[\"is_published\"])\n        if filters.get(\"category\"):\n            queryset = queryset.filter(category_id=filters[\"category\"])\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># Filter + pagination\nGET /article/?is_published=true&amp;category=5&amp;page=2&amp;page_size=20\n</code></pre> <p>The filtering is applied first, then pagination is applied to the filtered queryset.</p>"},{"location":"api/pagination/#performance-optimization","title":"Performance Optimization","text":""},{"location":"api/pagination/#count-optimization","title":"Count Optimization","text":"<p>For large datasets, counting can be expensive. Cache the count:</p> Python<pre><code>from django.core.cache import cache\n\n\nclass OptimizedPagination(PageNumberPagination):\n    async def apaginate_queryset(self, queryset, pagination, request=None, **params):\n        page = params.get('page', 1)\n        page_size = min(params.get('page_size', self.page_size), self.max_page_size)\n\n        # Try to get cached count\n        cache_key = f\"count_{queryset.model.__name__}\"\n        total_count = cache.get(cache_key)\n\n        if total_count is None:\n            total_count = await queryset.acount()\n            cache.set(cache_key, total_count, 300)  # Cache for 5 minutes\n\n        # Rest of pagination logic\n        start = (page - 1) * page_size\n        end = start + page_size\n\n        items = []\n        async for item in queryset[start:end]:\n            items.append(item)\n\n        return {\n            \"count\": total_count,\n            \"page\": page,\n            \"page_size\": page_size,\n            \"results\": items\n        }\n</code></pre>"},{"location":"api/pagination/#select-related-prefetch-related","title":"Select Related / Prefetch Related","text":"<p>Optimize queries when paginating related data:</p> Python<pre><code>class Article(ModelSerializer):\n    author = models.ForeignKey(User, on_delete=models.CASCADE)\n    category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True)\n    tags = models.ManyToManyField(Tag, related_name=\"articles\")\n\n    @classmethod\n    async def queryset_request(cls, request):\n        # Optimize queries before pagination\n        return cls.objects.select_related(\n            'author',\n            'category'\n        ).prefetch_related(\n            'tags'\n        )\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n</code></pre> <p>Now pagination queries are optimized:</p> SQL<pre><code>-- Single query with joins instead of N+1\nSELECT article.*, user.*, category.*\nFROM article\nLEFT JOIN user ON article.author_id = user.id\nLEFT JOIN category ON article.category_id = category.id\nLIMIT 10 OFFSET 0;\n</code></pre>"},{"location":"api/pagination/#approximate-counts","title":"Approximate Counts","text":"<p>For very large tables, use approximate counts:</p> Python<pre><code>class ApproximatePagination(PageNumberPagination):\n    async def apaginate_queryset(self, queryset, pagination, request=None, **params):\n        from django.db import connection\n\n        # Get approximate count from PostgreSQL statistics\n        with connection.cursor() as cursor:\n            cursor.execute(\n                \"SELECT reltuples::bigint FROM pg_class WHERE relname = %s\",\n                [queryset.model._meta.db_table]\n            )\n            approximate_count = cursor.fetchone()[0]\n\n        # Rest of pagination logic using approximate_count\n        # ...\n</code></pre>"},{"location":"api/pagination/#error-handling","title":"Error Handling","text":""},{"location":"api/pagination/#invalid-page-number","title":"Invalid Page Number","text":"Python<pre><code># Request\nGET /article/?page=999&amp;page_size=10\n\n# Response (404)\n{\n  \"detail\": \"Invalid page.\"\n}\n</code></pre>"},{"location":"api/pagination/#invalid-page-size","title":"Invalid Page Size","text":"Python<pre><code># Request\nGET /article/?page=1&amp;page_size=1000\n\n# Automatically clamped to max_page_size (100)\n# Response\n{\n  \"count\": 45,\n  \"page\": 1,\n  \"page_size\": 100,\n  \"results\": [...]\n}\n</code></pre>"},{"location":"api/pagination/#custom-error-handling","title":"Custom Error Handling","text":"Python<pre><code>class StrictPagination(PageNumberPagination):\n    async def apaginate_queryset(self, queryset, pagination, request=None, **params):\n        page_size = params.get('page_size', self.page_size)\n\n        if page_size &gt; self.max_page_size:\n            raise ValueError(\n                f\"page_size cannot exceed {self.max_page_size}\"\n            )\n\n        # Continue with pagination\n        # ...\n</code></pre>"},{"location":"api/pagination/#testing-pagination","title":"Testing Pagination","text":"Python<pre><code>import pytest\nfrom ninja.testing import TestAsyncClient\nfrom myapp.views import api\n\n\n@pytest.mark.asyncio\nasync def test_pagination():\n    client = TestAsyncClient(api)\n\n    # Create test data\n    for i in range(25):\n        await Article.objects.acreate(title=f\"Article {i}\")\n\n    # Test first page\n    response = await client.get(\"/article/?page=1&amp;page_size=10\")\n    assert response.status_code == 200\n    data = response.json()\n    assert data[\"count\"] == 25\n    assert len(data[\"results\"]) == 10\n    assert data[\"next\"] == 2\n    assert data[\"previous\"] is None\n\n    # Test middle page\n    response = await client.get(\"/article/?page=2&amp;page_size=10\")\n    data = response.json()\n    assert len(data[\"results\"]) == 10\n    assert data[\"next\"] == 3\n    assert data[\"previous\"] == 1\n\n    # Test last page\n    response = await client.get(\"/article/?page=3&amp;page_size=10\")\n    data = response.json()\n    assert len(data[\"results\"]) == 5\n    assert data[\"next\"] is None\n    assert data[\"previous\"] == 2\n\n\n@pytest.mark.asyncio\nasync def test_invalid_page():\n    client = TestAsyncClient(api)\n\n    response = await client.get(\"/article/?page=999\")\n    assert response.status_code == 404\n\n\n@pytest.mark.asyncio\nasync def test_page_size_limit():\n    client = TestAsyncClient(api)\n\n    # Request exceeds max_page_size\n    response = await client.get(\"/article/?page=1&amp;page_size=1000\")\n    data = response.json()\n    assert len(data[\"results\"]) &lt;= 100  # Clamped to max_page_size\n</code></pre>"},{"location":"api/pagination/#best-practices","title":"Best Practices","text":"<ol> <li>Choose appropriate page size:</li> </ol> Python<pre><code># Mobile API\npage_size = 10\n\n# Desktop/Web API\npage_size = 25\n\n# Admin/Internal API\npage_size = 100\n</code></pre> <ol> <li>Set reasonable max_page_size:</li> </ol> Python<pre><code># Prevent excessive data transfer\nmax_page_size = 100\n</code></pre> <ol> <li>Cache expensive counts:</li> </ol> Python<pre><code># For large, slowly-changing datasets\ncache.set(f\"count_{model}\", count, timeout=300)\n</code></pre> <ol> <li>Optimize queries:</li> </ol> Python<pre><code>queryset = queryset.select_related(...).prefetch_related(...)\n</code></pre> <ol> <li>Use cursor pagination for infinite scroll:</li> </ol> Python<pre><code># Better for real-time feeds\nclass FeedPagination(CursorPagination):\n    page_size = 20\n</code></pre> <ol> <li>Consider approximate counts for huge tables: Python<pre><code># Faster than exact count for millions of rows\nuse_approximate = queryset.count() &gt; 1_000_000\n</code></pre></li> </ol>"},{"location":"api/pagination/#see-also","title":"See Also","text":"<ul> <li>API ViewSet - Using pagination with ViewSets</li> <li>Model Util - Query optimization</li> <li>Authentication - Securing paginated endpoints</li> </ul> <p>Next: Learn about Authentication to secure your API endpoints.</p>"},{"location":"api/models/model_serializer/","title":"Model Serializer","text":"<p><code>ModelSerializer</code> is a powerful abstract mixin for Django models that centralizes schema generation and serialization configuration directly on the model class.</p>"},{"location":"api/models/model_serializer/#overview","title":"Overview","text":"<p>Goals:</p> <ul> <li>Eliminate duplication between Model and separate serializer classes</li> <li>Provide clear extension points (sync + async hooks, custom synthetic fields)</li> <li>Auto-generate Ninja schemas from model metadata</li> <li>Support nested serialization for relationships</li> </ul> <p>Key Features:</p> <ul> <li>Declarative schema configuration via inner classes</li> <li>Automatic CRUD schema generation</li> <li>Nested relationship handling</li> <li>Sync and async lifecycle hooks</li> <li>Custom field support (computed/synthetic fields)</li> </ul>"},{"location":"api/models/model_serializer/#quick-start","title":"Quick Start","text":"Python<pre><code>from django.db import models\nfrom ninja_aio.models import ModelSerializer\n\nclass User(ModelSerializer):\n    username = models.CharField(max_length=150, unique=True)\n    email = models.EmailField(unique=True)\n\n    class CreateSerializer:\n        fields = [\"username\", \"email\"]\n\n    class ReadSerializer:\n        fields = [\"id\", \"username\", \"email\"]\n\n    def __str__(self):\n        return self.username\n</code></pre>"},{"location":"api/models/model_serializer/#inner-configuration-classes","title":"Inner Configuration Classes","text":""},{"location":"api/models/model_serializer/#createserializer","title":"CreateSerializer","text":"<p>Describes how to build a create (input) schema for a model.</p> <p>Attributes:</p> Attribute Type Description <code>fields</code> <code>list[str]</code> REQUIRED model field names for creation <code>optionals</code> <code>list[tuple[str, type]]</code> Optional model fields: <code>(field_name, python_type)</code> <code>customs</code> <code>list[tuple]</code> Synthetic inputs. Tuple forms: <code>(name, type)</code> = required (no default); <code>(name, type, default)</code> = optional (literal or callable) <code>excludes</code> <code>list[str]</code> Field names rejected on create <p>Example:</p> Python<pre><code>class User(ModelSerializer):\n    username = models.CharField(max_length=150)\n    email = models.EmailField()\n    password = models.CharField(max_length=128)\n    bio = models.TextField(blank=True)\n\n    class CreateSerializer:\n        fields = [\"username\", \"email\", \"password\"]\n        optionals = [\n            (\"bio\", str),\n        ]\n        customs = [\n            (\"password_confirm\", str),          # required (no default) equivalent of (\"password_confirm\", str, ...)\n            (\"send_welcome_email\", bool, True), # optional with default\n        ]\n        excludes = [\"id\", \"created_at\"]\n</code></pre> <p>Resolution Order for <code>customs</code>:</p> <ol> <li>Payload value (if provided)</li> <li>If default present and callable \u2192 invoked</li> <li>Literal default (if provided)</li> <li>If tuple was only (name, type) and no value supplied \u2192 validation error (required)</li> </ol> <p>Conceptual Equivalent (django-ninja):</p> Python<pre><code># Without ModelSerializer\nfrom ninja import ModelSchema\n\nclass UserIn(ModelSchema):\n    class Meta:\n        model = User\n        fields = [\"username\", \"email\"]\n</code></pre>"},{"location":"api/models/model_serializer/#readserializer","title":"ReadSerializer","text":"<p>Describes how to build a read (output) schema for a model.</p> <p>Attributes</p> Attribute Type Description <code>fields</code> <code>list[str]</code> REQUIRED. Model fields / related names explicitly included in the read (output) schema. <code>excludes</code> <code>list[str]</code> Fields / related names to always omit (takes precedence over <code>fields</code> and <code>optionals</code>). Use for sensitive or noisy data (e.g., passwords, internal flags). <code>customs</code> <code>list[tuple]</code> Computed / synthetic output values. Tuple formats:\u2022 <code>(name, type)</code> = required resolvable attribute (object attribute or property). Serialization error if not resolvable.\u2022 <code>(name, type, default)</code> = optional; default may be a callable (<code>lambda obj: ...</code>) or a literal value. <p>Example:</p> Python<pre><code>class User(ModelSerializer):\n    first_name = models.CharField(max_length=150)\n    last_name = models.CharField(max_length=150)\n    email = models.EmailField()\n    password = models.CharField(max_length=128)\n\n    class ReadSerializer:\n        fields = [\"id\", \"first_name\", \"last_name\", \"email\", \"created_at\"]\n        excludes = [\"password\"]\n        customs = [\n            (\"full_name\", str, lambda obj: f\"{obj.first_name} {obj.last_name}\".strip()),\n            (\"is_premium\", bool, lambda obj: obj.subscription.is_active if hasattr(obj, 'subscription') else False),\n        ]\n</code></pre> <p>Resolution Order for <code>customs</code>:</p> <ol> <li>Attribute / property on instance</li> <li>Callable default (if provided)</li> <li>Literal default</li> <li>If required (2\u2011tuple) and still unresolved \u2192 error</li> </ol> <p>Generated Output:</p> JSON<pre><code>{\n  \"id\": 1,\n  \"first_name\": \"John\",\n  \"last_name\": \"Doe\",\n  \"email\": \"john@example.com\",\n  \"created_at\": \"2024-01-15T10:30:00Z\",\n  \"full_name\": \"John Doe\",\n  \"is_premium\": true\n}\n</code></pre>"},{"location":"api/models/model_serializer/#updateserializer","title":"UpdateSerializer","text":"<p>Describes how to build an update (partial/full) input schema.</p> <p>Attributes:</p> Attribute Type Description <code>fields</code> <code>list[str]</code> REQUIRED fields for update (rarely used) <code>optionals</code> <code>list[tuple[str, type]]</code> Updatable optional fields (typical for PATCH) <code>customs</code> <code>list[tuple]</code> Instruction fields: <code>(name, type)</code> required; <code>(name, type, default)</code> optional <code>excludes</code> <code>list[str]</code> Immutable fields that cannot be updated <p>Example:</p> Python<pre><code>class User(ModelSerializer):\n    username = models.CharField(max_length=150, unique=True)\n    email = models.EmailField()\n    bio = models.TextField(blank=True)\n    is_active = models.BooleanField(default=True)\n\n    class UpdateSerializer:\n        optionals = [\n            (\"email\", str),\n            (\"bio\", str),\n            (\"is_active\", bool),\n        ]\n        customs = [\n            (\"reset_password\", bool, False),  # optional flag\n            (\"rotate_token\", bool),          # required instruction\n        ]\n        excludes = [\"username\", \"created_at\", \"id\"]\n</code></pre> <p>Usage (PATCH request):</p> JSON<pre><code>{\n  \"email\": \"newemail@example.com\",\n  \"bio\": \"Updated bio\",\n  \"reset_password\": true\n}\n</code></pre>"},{"location":"api/models/model_serializer/#schema-generation","title":"Schema Generation","text":""},{"location":"api/models/model_serializer/#auto-generated-schemas","title":"Auto-Generated Schemas","text":"<p>ModelSerializer automatically generates four schema types:</p> Method Schema Type Purpose <code>generate_create_s()</code> Input (\"In\") POST endpoint payload <code>generate_update_s()</code> Input (\"Patch\") PATCH/PUT endpoint payload <code>generate_read_s(depth=1)</code> Output (\"Out\") Response with nested relations <code>generate_related_s()</code> Output (\"Related\") Compact nested representation <p>Example:</p> Python<pre><code>class User(ModelSerializer):\n    username = models.CharField(max_length=150)\n    email = models.EmailField()\n\n    class CreateSerializer:\n        fields = [\"username\", \"email\"]\n\n    class ReadSerializer:\n        fields = [\"id\", \"username\", \"email\"]\n\n# Auto-generate schemas\nUserCreateSchema = User.generate_create_s()\nUserReadSchema = User.generate_read_s()\nUserUpdateSchema = User.generate_update_s()\nUserRelatedSchema = User.generate_related_s()\n</code></pre>"},{"location":"api/models/model_serializer/#nested-relationship-handling","title":"Nested Relationship Handling","text":"<p>ModelSerializer automatically serializes relationships if the related model is also a ModelSerializer.</p>"},{"location":"api/models/model_serializer/#foreignkey-forward","title":"ForeignKey (Forward)","text":"Python<pre><code>class Profile(ModelSerializer):\n    bio = models.TextField()\n\n    class ReadSerializer:\n        fields = [\"id\", \"bio\"]\n\nclass User(ModelSerializer):\n    username = models.CharField(max_length=150)\n    profile = models.ForeignKey(Profile, on_delete=models.CASCADE)\n\n    class ReadSerializer:\n        fields = [\"id\", \"username\", \"profile\"]\n</code></pre> <p>Output:</p> JSON<pre><code>{\n  \"id\": 1,\n  \"username\": \"john_doe\",\n  \"profile\": {\n    \"id\": 10,\n    \"bio\": \"Software developer\"\n  }\n}\n</code></pre>"},{"location":"api/models/model_serializer/#manytomany","title":"ManyToMany","text":"Python<pre><code>class Tag(ModelSerializer):\n    name = models.CharField(max_length=50)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\"]\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    tags = models.ManyToManyField(Tag, related_name=\"articles\")\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"tags\"]\n</code></pre> <p>Output:</p> JSON<pre><code>{\n  \"id\": 1,\n  \"title\": \"Getting Started\",\n  \"tags\": [\n    { \"id\": 1, \"name\": \"python\" },\n    { \"id\": 2, \"name\": \"django\" }\n  ]\n}\n</code></pre>"},{"location":"api/models/model_serializer/#reverse-relationships","title":"Reverse Relationships","text":"Python<pre><code>class Author(ModelSerializer):\n    name = models.CharField(max_length=200)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"books\"]  # Reverse FK\n\nclass Book(ModelSerializer):\n    title = models.CharField(max_length=200)\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"books\")\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\"]\n</code></pre> <p>Output:</p> JSON<pre><code>{\n  \"id\": 1,\n  \"name\": \"J.K. Rowling\",\n  \"books\": [\n    { \"id\": 1, \"title\": \"Harry Potter\" },\n    { \"id\": 2, \"title\": \"Fantastic Beasts\" }\n  ]\n}\n</code></pre>"},{"location":"api/models/model_serializer/#async-extension-points","title":"Async Extension Points","text":""},{"location":"api/models/model_serializer/#queryset_requestrequest","title":"<code>queryset_request(request)</code>","text":"<p>Filter queryset based on request context (user, permissions, tenant, etc.).</p> Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    author = models.ForeignKey(User, on_delete=models.CASCADE)\n    is_published = models.BooleanField(default=False)\n\n    @classmethod\n    async def queryset_request(cls, request):\n        qs = cls.objects.select_related('author').all()\n\n        # Non-authenticated users see only published\n        if not request.auth:\n            return qs.filter(is_published=True)\n\n        # Authors see their own + published\n        return qs.filter(\n            models.Q(author=request.auth) | models.Q(is_published=True)\n        )\n</code></pre>"},{"location":"api/models/model_serializer/#post_create","title":"<code>post_create()</code>","text":"<p>Execute async logic after object creation.</p> Python<pre><code>class User(ModelSerializer):\n    email = models.EmailField()\n\n    async def post_create(self):\n        # Send welcome email\n        from myapp.tasks import send_welcome_email\n        await send_welcome_email(self.email)\n\n        # Create related objects\n        await Profile.objects.acreate(user=self)\n\n        # Log creation\n        await AuditLog.objects.acreate(\n            action=\"user_created\",\n            user_id=self.id\n        )\n</code></pre>"},{"location":"api/models/model_serializer/#custom_actionspayload","title":"<code>custom_actions(payload)</code>","text":"<p>React to synthetic/custom fields from the payload.</p> Python<pre><code>class User(ModelSerializer):\n    password = models.CharField(max_length=128)\n\n    class CreateSerializer:\n        fields = [\"username\", \"email\", \"password\"]\n        customs = [\n            (\"password_confirm\", str, None),\n            (\"send_welcome_email\", bool, True),\n        ]\n\n    async def custom_actions(self, payload: dict):\n        # Validate password confirmation\n        if \"password_confirm\" in payload:\n            if payload[\"password_confirm\"] != self.password:\n                raise ValueError(\"Passwords do not match\")\n\n        # Send welcome email if requested\n        if payload.get(\"send_welcome_email\", True):\n            await send_email(self.email, \"Welcome!\")\n</code></pre>"},{"location":"api/models/model_serializer/#sync-lifecycle-hooks","title":"Sync Lifecycle Hooks","text":""},{"location":"api/models/model_serializer/#save-hooks","title":"Save Hooks","text":"Python<pre><code>class User(ModelSerializer):\n    username = models.CharField(max_length=150)\n    slug = models.SlugField(unique=True, blank=True)\n\n    def before_save(self):\n        \"\"\"Executed before every save (create + update)\"\"\"\n        if not self.slug:\n            self.slug = slugify(self.username)\n\n    def on_create_before_save(self):\n        \"\"\"Executed only on creation, before save\"\"\"\n        self.set_password(self.password)  # Hash password\n\n    def after_save(self):\n        \"\"\"Executed after every save\"\"\"\n        cache.delete(f\"user:{self.id}\")\n\n    def on_create_after_save(self):\n        \"\"\"Executed only after creation\"\"\"\n        send_welcome_email_sync(self.email)\n</code></pre> <p>Execution Order:</p> Text Only<pre><code>CREATE:\n1. on_create_before_save()\n2. before_save()\n3. super().save()\n4. on_create_after_save()\n5. after_save()\n\nUPDATE:\n1. before_save()\n2. super().save()\n3. after_save()\n</code></pre>"},{"location":"api/models/model_serializer/#delete-hook","title":"Delete Hook","text":"Python<pre><code>class User(ModelSerializer):\n\n    def on_delete(self):\n        \"\"\"Executed after object deletion\"\"\"\n        # Clean up related data\n        logger.info(f\"User {self.username} deleted\")\n\n        # Remove from cache\n        cache.delete(f\"user:{self.id}\")\n\n        # Archive data\n        ArchivedUser.objects.create(\n            username=self.username,\n            deleted_at=timezone.now()\n        )\n</code></pre>"},{"location":"api/models/model_serializer/#utility-methods","title":"Utility Methods","text":""},{"location":"api/models/model_serializer/#has_changedfield","title":"<code>has_changed(field)</code>","text":"<p>Check if a field value has changed compared to database.</p> Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    status = models.CharField(max_length=20)\n\n    def before_save(self):\n        if self.has_changed('status'):\n            if self.status == 'published':\n                self.published_at = timezone.now()\n                notify_subscribers(self)\n</code></pre>"},{"location":"api/models/model_serializer/#verbose_name_path_resolver","title":"<code>verbose_name_path_resolver()</code>","text":"<p>Get slugified plural verbose name for URL routing.</p> Python<pre><code>class BlogPost(ModelSerializer):\n    class Meta:\n        verbose_name_plural = \"blog posts\"\n\n# Returns: \"blog-posts\"\npath = BlogPost.verbose_name_path_resolver()\n</code></pre>"},{"location":"api/models/model_serializer/#modelutil","title":"ModelUtil","text":"<p>Helper class for async CRUD operations with ModelSerializer.</p>"},{"location":"api/models/model_serializer/#overview_1","title":"Overview","text":"Python<pre><code>from ninja_aio.models import ModelUtil\n\nutil = ModelUtil(User)\n</code></pre> <p>Key Responsibilities:</p> <ul> <li>Introspect model metadata</li> <li>Normalize inbound/outbound payloads</li> <li>Handle FK resolution and base64 decoding</li> <li>Prefetch reverse relations</li> <li>Invoke serializer hooks</li> </ul>"},{"location":"api/models/model_serializer/#key-methods","title":"Key Methods","text":""},{"location":"api/models/model_serializer/#get_objectrequest-pknone-filtersnone-gettersnone","title":"<code>get_object(request, pk=None, filters=None, getters=None)</code>","text":"<p>Fetch single object or queryset with optimized queries.</p> Python<pre><code># Get single object\nuser = await util.get_object(request, pk=1)\n\n# Get with filters\nactive_users = await util.get_object(\n    request,\n    filters={\"is_active\": True}\n)\n\n# Get with custom lookup\nuser = await util.get_object(\n    request,\n    getters={\"email\": \"john@example.com\"}\n)\n</code></pre> <p>Features:</p> <ul> <li>Automatic <code>select_related()</code> and <code>prefetch_related()</code></li> <li>Respects <code>queryset_request()</code> filtering</li> <li>Raises <code>SerializeError</code> (404) if not found</li> </ul>"},{"location":"api/models/model_serializer/#parse_input_datarequest-data","title":"<code>parse_input_data(request, data)</code>","text":"<p>Convert incoming schema to model-ready dict.</p> <p>Transformations:</p> <ol> <li>Strips custom fields (stored separately)</li> <li>Removes optional fields with <code>None</code> value</li> <li>Decodes BinaryField (base64 \u2192 bytes)</li> <li>Resolves FK IDs to model instances</li> </ol> Python<pre><code>from ninja import Schema\n\nclass UserCreateSchema(Schema):\n    username: str\n    email: str\n    profile_id: int\n    avatar: str  # base64 for BinaryField\n    send_welcome: bool  # custom field\n\ndata = UserCreateSchema(\n    username=\"john\",\n    email=\"john@example.com\",\n    profile_id=5,\n    avatar=\"iVBORw0KG...\",  # base64\n    send_welcome=True\n)\n\npayload, customs = await util.parse_input_data(request, data)\n\n# payload = {\n#     \"username\": \"john\",\n#     \"email\": \"john@example.com\",\n#     \"profile\": &lt;Profile instance&gt;,\n#     \"avatar\": b'\\x89PNG\\r\\n...'\n# }\n# customs = {\"send_welcome\": True}\n</code></pre>"},{"location":"api/models/model_serializer/#parse_output_datarequest-data","title":"<code>parse_output_data(request, data)</code>","text":"<p>Post-process serialized output for consistency.</p> <p>Transformations:</p> <ol> <li>Replaces nested FK dicts with actual instances</li> <li>Rewrites nested FK keys to <code>&lt;field&gt;_id</code> format</li> </ol> Python<pre><code># Before\n{\n    \"id\": 1,\n    \"author\": {\"id\": 10, \"profile\": {\"id\": 5}}\n}\n\n# After parse_output_data\n{\n    \"id\": 1,\n    \"author\": &lt;Author instance&gt;,\n    \"author_id\": 10,\n    \"profile_id\": 5\n}\n</code></pre>"},{"location":"api/models/model_serializer/#crud-operations","title":"CRUD Operations","text":""},{"location":"api/models/model_serializer/#create_srequest-data-obj_schema","title":"<code>create_s(request, data, obj_schema)</code>","text":"Python<pre><code>user_data = UserCreateSchema(username=\"john\", email=\"john@example.com\")\nresult = await util.create_s(request, user_data, UserReadSchema)\n\n# Executes:\n# 1. parse_input_data (normalize)\n# 2. Model.objects.acreate()\n# 3. custom_actions(customs)\n# 4. post_create()\n# 5. read_s (serialize response)\n</code></pre>"},{"location":"api/models/model_serializer/#read_srequest-obj-obj_schema","title":"<code>read_s(request, obj, obj_schema)</code>","text":"Python<pre><code>user = await User.objects.aget(id=1)\nresult = await util.read_s(request, user, UserReadSchema)\n# Returns parsed dict ready for API response\n</code></pre>"},{"location":"api/models/model_serializer/#update_srequest-data-pk-obj_schema","title":"<code>update_s(request, data, pk, obj_schema)</code>","text":"Python<pre><code>update_data = UserUpdateSchema(email=\"newemail@example.com\")\nresult = await util.update_s(request, update_data, 1, UserReadSchema)\n\n# Executes:\n# 1. get_object(pk)\n# 2. parse_input_data\n# 3. Update changed fields\n# 4. custom_actions(customs)\n# 5. obj.asave()\n# 6. read_s (serialize updated object)\n</code></pre>"},{"location":"api/models/model_serializer/#delete_srequest-pk","title":"<code>delete_s(request, pk)</code>","text":"Python<pre><code>await util.delete_s(request, 1)\n# Returns None\n</code></pre>"},{"location":"api/models/model_serializer/#error-handling","title":"Error Handling","text":"Python<pre><code>from ninja_aio.exceptions import SerializeError\n\ntry:\n    user = await util.get_object(request, pk=999)\nexcept SerializeError as e:\n    # e.details = {\"user\": \"not found\"}\n    # e.status_code = 404\n    pass\n\ntry:\n    await util.create_s(request, bad_data, UserReadSchema)\nexcept SerializeError as e:\n    # e.details = {\"avatar\": \"Invalid base64\"}\n    # e.status_code = 400\n    pass\n</code></pre>"},{"location":"api/models/model_serializer/#complete-example","title":"Complete Example","text":"Python<pre><code>from django.db import models\nfrom ninja_aio.models import ModelSerializer\nfrom django.utils.text import slugify\n\nclass Category(ModelSerializer):\n    name = models.CharField(max_length=100)\n    slug = models.SlugField(unique=True, blank=True)\n\n    class CreateSerializer:\n        fields = [\"name\"]\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"slug\"]\n\n    class UpdateSerializer:\n        optionals = [(\"name\", str)]\n\n    def before_save(self):\n        if not self.slug:\n            self.slug = slugify(self.name)\n\nclass Author(ModelSerializer):\n    name = models.CharField(max_length=200)\n    email = models.EmailField(unique=True)\n    bio = models.TextField(blank=True)\n\n    class CreateSerializer:\n        fields = [\"name\", \"email\"]\n        optionals = [(\"bio\", str)]\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"email\", \"bio\"]\n        customs = [\n            (\"post_count\", int, lambda obj: obj.articles.count()),\n        ]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"name\", str),\n            (\"email\", str),\n            (\"bio\", str),\n        ]\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    slug = models.SlugField(unique=True)\n    content = models.TextField()\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"articles\")\n    category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True)\n    tags = models.ManyToManyField('Tag', related_name=\"articles\")\n    is_published = models.BooleanField(default=False)\n    views = models.IntegerField(default=0)\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    class CreateSerializer:\n        fields = [\"title\", \"slug\", \"content\", \"author\", \"category\"]\n        customs = [\n            (\"notify_subscribers\", bool, True),\n        ]\n\n    class ReadSerializer:\n        fields = [\n            \"id\", \"title\", \"slug\", \"content\",\n            \"author\", \"category\", \"tags\",\n            \"is_published\", \"views\", \"created_at\"\n        ]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"title\", str),\n            (\"content\", str),\n            (\"category\", int),\n            (\"is_published\", bool),\n        ]\n        excludes = [\"slug\", \"author\", \"created_at\"]\n\n    @classmethod\n    async def queryset_request(cls, request):\n        qs = cls.objects.select_related('author', 'category').prefetch_related('tags')\n\n        if not request.auth:\n            return qs.filter(is_published=True)\n\n        return qs.filter(\n            models.Q(author=request.auth) | models.Q(is_published=True)\n        )\n\n    async def post_create(self):\n        await AuditLog.objects.acreate(\n            action=\"article_created\",\n            article_id=self.id,\n            author_id=self.author_id\n        )\n\n    async def custom_actions(self, payload: dict):\n        if payload.get(\"notify_subscribers\"):\n            await notify_new_article(self)\n\n    def before_save(self):\n        if self.has_changed('is_published') and self.is_published:\n            self.published_at = timezone.now()\n\nclass Tag(ModelSerializer):\n    name = models.CharField(max_length=50, unique=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\"]\n</code></pre>"},{"location":"api/models/model_serializer/#custom-fields-normalization","title":"Custom Fields Normalization","text":"<p>Custom tuples are normalized by <code>ModelSerializer.get_custom_fields()</code> to <code>(name, python_type, default)</code>.</p> <p>Accepted forms:</p> <ul> <li><code>(name, type)</code> -&gt; stored with <code>default = Ellipsis</code> (treated as required)</li> <li><code>(name, type, default)</code> -&gt; default kept (callable or literal)</li> </ul> <p>Invalid lengths raise <code>ValueError</code>.</p> <p>Example mix:</p> Python<pre><code>class CreateSerializer:\n    customs = [\n        (\"password_confirm\", str),           # required\n        (\"send_welcome\", bool, True),        # optional\n        (\"initial_quota\", int, lambda: 100)  # optional callable\n    ]\n</code></pre> <p>At runtime:</p> Python<pre><code># Normalized\n[\n  (\"password_confirm\", str, Ellipsis),\n  (\"send_welcome\", bool, True),\n  (\"initial_quota\", int, &lt;function ...&gt;)\n]\n</code></pre> <p>Required customs (Ellipsis) must be provided in input (create/update) or resolvable (read) or an error is raised.</p>"},{"location":"api/models/model_serializer/#error-cases","title":"Error Cases","text":"Situation Result 1\u2011item or 4\u2011item tuple ValueError Missing required custom (2\u2011tuple) in payload Validation error Unresolvable required read custom Serialization error"},{"location":"api/models/model_serializer/#best-practices","title":"Best Practices","text":"<ol> <li>Always exclude sensitive fields:</li> </ol> Python<pre><code>class ReadSerializer:\n    excludes = [\"password\", \"secret_key\", \"internal_id\"]\n</code></pre> <ol> <li>Use optionals for PATCH operations:</li> </ol> Python<pre><code>class UpdateSerializer:\n    optionals = [(\"email\", str), (\"bio\", str)]  # Partial updates\n</code></pre> <ol> <li>Leverage customs for computed data:</li> </ol> Python<pre><code>customs = [\n    (\"full_name\", str, lambda obj: f\"{obj.first_name} {obj.last_name}\"),\n]\n</code></pre> <ol> <li>Optimize queries in queryset_request:</li> </ol> Python<pre><code>@classmethod\nasync def queryset_request(cls, request):\n    return cls.objects.select_related('author').prefetch_related('tags')\n</code></pre> <ol> <li>Keep hooks focused: Python<pre><code>async def post_create(self):\n    # Do ONE thing well\n    await send_welcome_email(self.email)\n</code></pre></li> </ol>"},{"location":"api/models/model_serializer/#see-also","title":"See Also","text":"<ul> <li>Model Util - Deep dive into ModelUtil</li> <li>API ViewSet - Using ModelSerializer with ViewSets</li> <li>Authentication - Securing endpoints</li> </ul>"},{"location":"api/models/model_util/","title":"Model Util","text":"<p><code>ModelUtil</code> is an async utility class that provides high-level CRUD operations and serialization management for Django models and ModelSerializer instances.</p>"},{"location":"api/models/model_util/#overview","title":"Overview","text":"<p>ModelUtil acts as a bridge between Django Ninja schemas and Django ORM, handling:</p> <ul> <li>Data normalization (input/output)</li> <li>Relationship resolution (FK/M2M)</li> <li>Binary field handling (base64 encoding/decoding)</li> <li>Query optimization (select_related/prefetch_related)</li> <li>Lifecycle hook invocation (custom_actions, post_create, queryset_request)</li> </ul>"},{"location":"api/models/model_util/#class-definition","title":"Class Definition","text":"Python<pre><code>from ninja_aio.models import ModelUtil\n\nutil = ModelUtil(model)\n</code></pre> <p>Parameters:</p> <ul> <li><code>model</code> (<code>type[ModelSerializer] | models.Model</code>): Django model or ModelSerializer subclass</li> </ul>"},{"location":"api/models/model_util/#properties","title":"Properties","text":""},{"location":"api/models/model_util/#model_pk_name","title":"<code>model_pk_name</code>","text":"<p>Returns the primary key field name.</p> Python<pre><code>util = ModelUtil(User)\nprint(util.model_pk_name)  # \"id\"\n</code></pre>"},{"location":"api/models/model_util/#model_fields","title":"<code>model_fields</code>","text":"<p>Returns a list of all model field names.</p> Python<pre><code>util = ModelUtil(User)\nprint(util.model_fields)\n# [\"id\", \"username\", \"email\", \"created_at\", \"is_active\"]\n</code></pre>"},{"location":"api/models/model_util/#schema_out_fields","title":"<code>schema_out_fields</code>","text":"<p>Returns serializable fields (ReadSerializer fields or all model fields).</p> Python<pre><code>class User(ModelSerializer):\n    username = models.CharField(max_length=150)\n    password = models.CharField(max_length=128)\n    email = models.EmailField()\n\n    class ReadSerializer:\n        fields = [\"id\", \"username\", \"email\"]\n\nutil = ModelUtil(User)\nprint(util.schema_out_fields)\n# [\"id\", \"username\", \"email\"]  (password excluded)\n</code></pre>"},{"location":"api/models/model_util/#serializer_meta","title":"<code>serializer_meta</code>","text":"<p>Returns the ModelSerializerMeta instance if model uses ModelSerializer.</p> Python<pre><code>if util.serializer_meta:\n    fields = util.serializer_meta.get_fields(\"create\")\n</code></pre>"},{"location":"api/models/model_util/#queryset-configuration-on-modelserializer","title":"QuerySet configuration on ModelSerializer","text":"<p>You can declare query optimizations directly on your ModelSerializer via a nested QuerySet:</p> Python<pre><code>from ninja_aio.models import ModelSerializer\nfrom ninja_aio.schemas.helpers import ModelQuerySetSchema, ModelQuerySetExtraSchema\n\nclass Book(ModelSerializer):\n    # ...existing fields...\n\n    class QuerySet:\n        read = ModelQuerySetSchema(\n            select_related=[\"author\", \"category\"],\n            prefetch_related=[\"tags\"],\n        )\n        queryset_request = ModelQuerySetSchema(\n            select_related=[],\n            prefetch_related=[\"related_items\"],\n        )\n        extras = [\n            ModelQuerySetExtraSchema(\n                scope=\"detail_cards\",\n                select_related=[\"author\"],\n                prefetch_related=[\"tags\"],\n            )\n        ]\n</code></pre> <ul> <li>read: applied to read operations (list/retrieve).</li> <li>queryset_request: applied inside queryset_request hook.</li> <li>extras: named configurations available via QueryUtil.SCOPES.</li> </ul>"},{"location":"api/models/model_util/#queryutil","title":"QueryUtil","text":"<p>Each ModelSerializer now exposes a query_util helper:</p> Python<pre><code>util = MyModel.query_util\nqs = util.apply_queryset_optimizations(MyModel.objects.all(), util.SCOPES.READ)\n</code></pre> <ul> <li>SCOPES: includes READ, QUERYSET_REQUEST, plus any extras you've defined.</li> <li>apply_queryset_optimizations: applies select_related/prefetch_related for a scope.</li> </ul>"},{"location":"api/models/model_util/#query-schemas","title":"Query schemas","text":"<p>New helper schemas standardize filters and getters:</p> Python<pre><code>from ninja_aio.schemas.helpers import (\n    QuerySchema,           # generic: filters or getters\n    ObjectQuerySchema,     # getters + select/prefetch\n    ObjectsQuerySchema,    # filters + select/prefetch\n    ModelQuerySetSchema,   # select/prefetch only\n)\n</code></pre>"},{"location":"api/models/model_util/#core-methods","title":"Core Methods","text":""},{"location":"api/models/model_util/#get_objects","title":"<code>get_objects</code>","text":"<p>Fetch an optimized queryset with optional filters and select/prefetch hints:</p> Python<pre><code>from ninja_aio.models import ModelUtil\nfrom ninja_aio.schemas.helpers import ObjectsQuerySchema\n\nqs = await ModelUtil(Book).get_objects(\n    request,\n    query_data=ObjectsQuerySchema(\n        filters={\"is_published\": True},\n        select_related=[\"author\"],\n        prefetch_related=[\"tags\"],\n    ),\n    is_for_read=True,  # union with auto-discovered relations\n)\n</code></pre>"},{"location":"api/models/model_util/#get_object","title":"<code>get_object</code>","text":"<p>Fetch a single object by pk or getters with optimizations:</p> Python<pre><code>from ninja_aio.schemas.helpers import ObjectQuerySchema, QuerySchema\n\n# by pk + select/prefetch\nobj = await ModelUtil(Book).get_object(\n    request,\n    pk=42,\n    query_data=ObjectQuerySchema(select_related=[\"author\"]),\n    is_for_read=True,\n)\n\n# by getters (required if pk omitted)\nobj = await ModelUtil(Book).get_object(\n    request,\n    query_data=QuerySchema(getters={\"slug\": \"my-book-slug\"}),\n)\n</code></pre> <p>Errors:</p> <ul> <li>ValueError if neither pk nor getters provided.</li> <li>NotFoundError if no match.</li> </ul>"},{"location":"api/models/model_util/#read_s-and-list_read_s","title":"<code>read_s</code> and <code>list_read_s</code>","text":"<p>Uniform serialization methods that accept either instances or query data:</p> Python<pre><code>schema = Book.generate_read_s()\n\n# single instance\ndata = await ModelUtil(Book).read_s(schema, request, instance=obj)\n\n# single via getters\ndata = await ModelUtil(Book).read_s(\n    schema,\n    request,\n    query_data=ObjectQuerySchema(getters={\"pk\": 42}),\n    is_for_read=True,\n)\n\n# list from queryset\nitems = await ModelUtil(Book).list_read_s(schema, request, instances=qs)\n\n# list via filters\nitems = await ModelUtil(Book).list_read_s(\n    schema,\n    request,\n    query_data=ObjectsQuerySchema(filters={\"is_published\": True}),\n    is_for_read=True,\n)\n</code></pre> <p>Behavior:</p> <ul> <li>When is_for_read=True, select_related and prefetch_related are merged with model-discovered relations.</li> <li>Passing instances skips fetching; passing query_data fetches automatically.</li> </ul>"},{"location":"api/models/model_util/#get_reverse_relations","title":"<code>get_reverse_relations()</code>","text":"<p>Discovers reverse relationship field names for prefetch optimization.</p>"},{"location":"api/models/model_util/#signature","title":"Signature","text":"Python<pre><code>def get_reverse_relations() -&gt; list[str]\n</code></pre>"},{"location":"api/models/model_util/#return-value","title":"Return Value","text":"<p>List of reverse relation accessor names.</p>"},{"location":"api/models/model_util/#example","title":"Example","text":"Python<pre><code>class Author(ModelSerializer):\n    name = models.CharField(max_length=200)\n\nclass Book(ModelSerializer):\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"books\")\n\nutil = ModelUtil(Author)\nreverse_rels = util.get_reverse_relations()\nprint(reverse_rels)  # [\"books\"]\n</code></pre>"},{"location":"api/models/model_util/#detected-relation-types","title":"Detected Relation Types","text":"Django Descriptor Example Detected <code>ReverseManyToOneDescriptor</code> <code>author.books</code> \u2713 <code>ReverseOneToOneDescriptor</code> <code>user.profile</code> \u2713 <code>ManyToManyDescriptor</code> <code>article.tags</code> \u2713 <code>ForwardManyToOneDescriptor</code> <code>book.author</code> \u2717 <code>ForwardOneToOneDescriptor</code> <code>profile.user</code> \u2717"},{"location":"api/models/model_util/#use-case","title":"Use Case","text":"Python<pre><code># Avoid N+1 queries when serializing reverse relations\nrelations = util.get_reverse_relations()\nqueryset = Author.objects.prefetch_related(*relations)\n\n# Now iterating over authors won't trigger additional queries for books\nasync for author in queryset:\n    books = await sync_to_async(list)(author.books.all())  # No query!\n</code></pre>"},{"location":"api/models/model_util/#parse_input_data","title":"<code>parse_input_data()</code>","text":"<p>Normalize incoming schema data into model-ready dictionary.</p>"},{"location":"api/models/model_util/#signature_1","title":"Signature","text":"Python<pre><code>async def parse_input_data(\n    request: HttpRequest,\n    data: Schema\n) -&gt; tuple[dict, dict]\n</code></pre>"},{"location":"api/models/model_util/#parameters","title":"Parameters","text":"Parameter Type Description <code>request</code> <code>HttpRequest</code> Current HTTP request <code>data</code> <code>Schema</code> Ninja schema instance"},{"location":"api/models/model_util/#return-value_1","title":"Return Value","text":"<p><code>(payload, customs)</code> where:</p> <ul> <li><code>payload</code> (<code>dict</code>): Model-ready data with resolved relationships</li> <li><code>customs</code> (<code>dict</code>): Custom/synthetic fields stripped from payload</li> </ul>"},{"location":"api/models/model_util/#transformations","title":"Transformations","text":"<ol> <li>Strip custom fields \u2192 Move to <code>customs</code> dict</li> <li>Remove optional None values \u2192 Don't update if not provided</li> <li>Decode BinaryField \u2192 Convert base64 string to bytes</li> <li>Resolve FK IDs \u2192 Fetch related instances</li> </ol>"},{"location":"api/models/model_util/#examples","title":"Examples","text":"<p>Basic transformation:</p> Python<pre><code>from ninja import Schema\n\nclass UserCreateSchema(Schema):\n    username: str\n    email: str\n    bio: str | None = None\n\ndata = UserCreateSchema(\n    username=\"john_doe\",\n    email=\"john@example.com\",\n    bio=None  # Optional, not provided\n)\n\npayload, customs = await util.parse_input_data(request, data)\n\nprint(payload)\n# {\"username\": \"john_doe\", \"email\": \"john@example.com\"}\n# bio is omitted (None stripped)\n\nprint(customs)\n# {}\n</code></pre> <p>With custom fields:</p> Python<pre><code>class User(ModelSerializer):\n    username = models.CharField(max_length=150)\n    email = models.EmailField()\n\n    class CreateSerializer:\n        fields = [\"username\", \"email\"]\n        customs = [\n            (\"password_confirm\", str, None),\n            (\"send_welcome_email\", bool, True),\n        ]\n\n# Schema includes custom fields\ndata = UserCreateSchema(\n    username=\"john\",\n    email=\"john@example.com\",\n    password_confirm=\"secret123\",\n    send_welcome_email=False\n)\n\npayload, customs = await util.parse_input_data(request, data)\n\nprint(payload)\n# {\"username\": \"john\", \"email\": \"john@example.com\"}\n\nprint(customs)\n# {\"password_confirm\": \"secret123\", \"send_welcome_email\": False}\n</code></pre> <p>With ForeignKey resolution:</p> Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    author = models.ForeignKey(User, on_delete=models.CASCADE)\n    category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True)\n\n# Input schema expects IDs\ndata = ArticleCreateSchema(\n    title=\"Getting Started\",\n    author=5,      # User ID\n    category=10    # Category ID\n)\n\npayload, customs = await util.parse_input_data(request, data)\n\nprint(payload)\n# {\n#     \"title\": \"Getting Started\",\n#     \"author\": &lt;User instance with id=5&gt;,\n#     \"category\": &lt;Category instance with id=10&gt;\n# }\n</code></pre> <p>With BinaryField (base64):</p> Python<pre><code>class Document(ModelSerializer):\n    name = models.CharField(max_length=200)\n    file_data = models.BinaryField()\n\ndata = DocumentCreateSchema(\n    name=\"report.pdf\",\n    file_data=\"iVBORw0KGgoAAAANSUhEUgA...\"  # base64 string\n)\n\npayload, customs = await util.parse_input_data(request, data)\n\nprint(payload)\n# {\n#     \"name\": \"report.pdf\",\n#     \"file_data\": b'\\x89PNG\\r\\n\\x1a\\n...'  # decoded bytes\n# }\n</code></pre> <p>Error handling:</p> Python<pre><code>try:\n    payload, customs = await util.parse_input_data(request, bad_data)\nexcept SerializeError as e:\n    print(e.status_code)  # 400\n    print(e.details)\n    # {\"file_data\": \"Invalid base64 encoding\"}\n    # or {\"author\": \"User with id 999 not found\"}\n</code></pre>"},{"location":"api/models/model_util/#parse_output_data","title":"<code>parse_output_data()</code>","text":"<p>Post-process serialized output for consistency.</p>"},{"location":"api/models/model_util/#signature_2","title":"Signature","text":"Python<pre><code>async def parse_output_data(\n    request: HttpRequest,\n    data: Schema\n) -&gt; dict\n</code></pre>"},{"location":"api/models/model_util/#parameters_1","title":"Parameters","text":"Parameter Type Description <code>request</code> <code>HttpRequest</code> Current HTTP request <code>data</code> <code>Schema</code> Serialized schema instance"},{"location":"api/models/model_util/#return-value_2","title":"Return Value","text":"<p>Post-processed dictionary ready for API response.</p>"},{"location":"api/models/model_util/#transformations_1","title":"Transformations","text":"<ol> <li>Replace nested FK dicts \u2192 Actual model instances</li> <li>Add <code>&lt;field&gt;_id</code> keys \u2192 For nested FK references</li> <li>Flatten nested structures \u2192 Consistent response format</li> </ol>"},{"location":"api/models/model_util/#examples_1","title":"Examples","text":"<p>Basic FK transformation:</p> Python<pre><code># Before parse_output_data\n{\n    \"id\": 1,\n    \"title\": \"Article Title\",\n    \"author\": {\"id\": 10, \"username\": \"john_doe\"}\n}\n\n# After parse_output_data\n{\n    \"id\": 1,\n    \"title\": \"Article Title\",\n    \"author\": &lt;User instance&gt;,\n    \"author_id\": 10\n}\n</code></pre> <p>Nested relationships:</p> Python<pre><code># Before\n{\n    \"id\": 1,\n    \"author\": {\n        \"id\": 10,\n        \"profile\": {\n            \"id\": 5,\n            \"bio\": \"Developer\"\n        }\n    }\n}\n\n# After\n{\n    \"id\": 1,\n    \"author\": &lt;User instance&gt;,\n    \"author_id\": 10,\n    \"profile_id\": 5\n}\n</code></pre> <p>Why is this useful?</p> <p>Allows accessing relationships directly in subsequent operations:</p> Python<pre><code>result = await util.read_s(request, article, ArticleReadSchema)\n\n# Direct access to instances (no additional queries)\nauthor_name = result[\"author\"].username\nhas_premium = result[\"author\"].is_premium\n\n# Also provides IDs for convenience\nauthor_id = result[\"author_id\"]\n</code></pre>"},{"location":"api/models/model_util/#verbose_name_path_resolver","title":"<code>verbose_name_path_resolver()</code>","text":"<p>Get URL-friendly path segment from model's verbose name plural.</p>"},{"location":"api/models/model_util/#signature_3","title":"Signature","text":"Python<pre><code>def verbose_name_path_resolver() -&gt; str\n</code></pre>"},{"location":"api/models/model_util/#return-value_3","title":"Return Value","text":"<p>Slugified plural verbose name.</p>"},{"location":"api/models/model_util/#example_1","title":"Example","text":"Python<pre><code>class BlogPost(ModelSerializer):\n    class Meta:\n        verbose_name = \"blog post\"\n        verbose_name_plural = \"blog posts\"\n\nutil = ModelUtil(BlogPost)\npath = util.verbose_name_path_resolver()\nprint(path)  # \"blog-posts\"\n\n# Used in URL routing:\n# /api/blog-posts/\n# /api/blog-posts/{id}/\n</code></pre>"},{"location":"api/models/model_util/#verbose_name_view_resolver","title":"<code>verbose_name_view_resolver()</code>","text":"<p>Get display name from model's singular verbose name.</p>"},{"location":"api/models/model_util/#signature_4","title":"Signature","text":"Python<pre><code>def verbose_name_view_resolver() -&gt; str\n</code></pre>"},{"location":"api/models/model_util/#return-value_4","title":"Return Value","text":"<p>Capitalized singular verbose name.</p>"},{"location":"api/models/model_util/#example_2","title":"Example","text":"Python<pre><code>class BlogPost(ModelSerializer):\n    class Meta:\n        verbose_name = \"blog post\"\n\nutil = ModelUtil(BlogPost)\nname = util.verbose_name_view_resolver()\nprint(name)  # \"Blog post\"\n\n# Used in OpenAPI documentation:\n# \"Create Blog post\"\n# \"Update Blog post\"\n</code></pre>"},{"location":"api/models/model_util/#crud-operations","title":"CRUD Operations","text":""},{"location":"api/models/model_util/#create_s","title":"<code>create_s()</code>","text":"<p>Create new model instance with full lifecycle support.</p>"},{"location":"api/models/model_util/#signature_5","title":"Signature","text":"Python<pre><code>async def create_s(\n    request: HttpRequest,\n    data: Schema,\n    obj_schema: Schema\n) -&gt; dict\n</code></pre>"},{"location":"api/models/model_util/#parameters_2","title":"Parameters","text":"Parameter Type Description <code>request</code> <code>HttpRequest</code> Current HTTP request <code>data</code> <code>Schema</code> Input schema with creation data <code>obj_schema</code> <code>Schema</code> Output schema for response"},{"location":"api/models/model_util/#return-value_5","title":"Return Value","text":"<p>Serialized created object as dictionary.</p>"},{"location":"api/models/model_util/#execution-flow","title":"Execution Flow","text":"Text Only<pre><code>1. parse_input_data(data) \u2192 (payload, customs)\n2. Model.objects.acreate(**payload)\n3. custom_actions(customs)    [if ModelSerializer]\n4. post_create()              [if ModelSerializer]\n5. read_s(obj, obj_schema)\n6. return serialized_dict\n</code></pre>"},{"location":"api/models/model_util/#example_3","title":"Example","text":"Python<pre><code>from ninja import Schema\n\nclass UserCreateSchema(Schema):\n    username: str\n    email: str\n    send_welcome: bool = True\n\nclass UserReadSchema(Schema):\n    id: int\n    username: str\n    email: str\n    created_at: datetime\n\n# Create user\ndata = UserCreateSchema(\n    username=\"john_doe\",\n    email=\"john@example.com\",\n    send_welcome=True\n)\n\nresult = await util.create_s(request, data, UserReadSchema)\n\nprint(result)\n# {\n#     \"id\": 1,\n#     \"username\": \"john_doe\",\n#     \"email\": \"john@example.com\",\n#     \"created_at\": \"2024-01-15T10:30:00Z\"\n# }\n</code></pre>"},{"location":"api/models/model_util/#with-hooks","title":"With Hooks","text":"Python<pre><code>class User(ModelSerializer):\n    username = models.CharField(max_length=150)\n    email = models.EmailField()\n\n    class CreateSerializer:\n        fields = [\"username\", \"email\"]\n        customs = [(\"send_welcome\", bool, True)]\n\n    async def custom_actions(self, payload):\n        if payload.get(\"send_welcome\"):\n            await send_welcome_email(self.email)\n\n    async def post_create(self):\n        await AuditLog.objects.acreate(\n            action=\"user_created\",\n            user_id=self.id\n        )\n\n# Hooks are automatically invoked\nresult = await util.create_s(request, data, UserReadSchema)\n</code></pre>"},{"location":"api/models/model_util/#read_s","title":"<code>read_s()</code>","text":"<p>Serialize model instance to response dict.</p>"},{"location":"api/models/model_util/#signature_6","title":"Signature","text":"Python<pre><code>async def read_s(\n    request: HttpRequest,\n    obj: ModelSerializer | models.Model,\n    obj_schema: Schema\n) -&gt; dict\n</code></pre>"},{"location":"api/models/model_util/#parameters_3","title":"Parameters","text":"Parameter Type Description <code>request</code> <code>HttpRequest</code> Current HTTP request <code>obj</code> <code>ModelSerializer \\| models.Model</code> Model instance to serialize <code>obj_schema</code> <code>Schema</code> Output schema"},{"location":"api/models/model_util/#return-value_6","title":"Return Value","text":"<p>Serialized object as dictionary.</p>"},{"location":"api/models/model_util/#execution-flow_1","title":"Execution Flow","text":"Text Only<pre><code>1. obj_schema.from_orm(obj)\n2. schema.model_dump(mode=\"json\")\n3. parse_output_data(dumped_data)\n4. return processed_dict\n</code></pre>"},{"location":"api/models/model_util/#example_4","title":"Example","text":"Python<pre><code>user = await User.objects.aget(id=1)\nresult = await util.read_s(request, user, UserReadSchema)\n\nprint(result)\n# {\n#     \"id\": 1,\n#     \"username\": \"john_doe\",\n#     \"email\": \"john@example.com\",\n#     \"created_at\": \"2024-01-15T10:30:00Z\"\n# }\n</code></pre>"},{"location":"api/models/model_util/#with-nested-relations","title":"With Nested Relations","text":"Python<pre><code>class ArticleReadSchema(Schema):\n    id: int\n    title: str\n    author: UserReadSchema  # Nested\n\narticle = await Article.objects.select_related('author').aget(id=1)\nresult = await util.read_s(request, article, ArticleReadSchema)\n\nprint(result)\n# {\n#     \"id\": 1,\n#     \"title\": \"Getting Started\",\n#     \"author\": &lt;User instance&gt;,\n#     \"author_id\": 10\n# }\n</code></pre>"},{"location":"api/models/model_util/#update_s","title":"<code>update_s()</code>","text":"<p>Update existing model instance.</p>"},{"location":"api/models/model_util/#signature_7","title":"Signature","text":"Python<pre><code>async def update_s(\n    request: HttpRequest,\n    data: Schema,\n    pk: int | str,\n    obj_schema: Schema\n) -&gt; dict\n</code></pre>"},{"location":"api/models/model_util/#parameters_4","title":"Parameters","text":"Parameter Type Description <code>request</code> <code>HttpRequest</code> Current HTTP request <code>data</code> <code>Schema</code> Input schema with update data <code>pk</code> <code>int \\| str</code> Primary key of object to update <code>obj_schema</code> <code>Schema</code> Output schema for response"},{"location":"api/models/model_util/#return-value_7","title":"Return Value","text":"<p>Serialized updated object as dictionary.</p>"},{"location":"api/models/model_util/#execution-flow_2","title":"Execution Flow","text":"Text Only<pre><code>1. get_object(pk=pk)\n2. parse_input_data(data) \u2192 (payload, customs)\n3. Update obj fields from payload\n4. custom_actions(customs)    [if ModelSerializer]\n5. obj.asave()\n6. read_s(obj, obj_schema)\n7. return serialized_dict\n</code></pre>"},{"location":"api/models/model_util/#example_5","title":"Example","text":"Python<pre><code>class UserUpdateSchema(Schema):\n    email: str | None = None\n    bio: str | None = None\n\ndata = UserUpdateSchema(email=\"newemail@example.com\")\nresult = await util.update_s(request, data, pk=1, obj_schema=UserReadSchema)\n\nprint(result)\n# {\n#     \"id\": 1,\n#     \"username\": \"john_doe\",  # unchanged\n#     \"email\": \"newemail@example.com\",  # updated\n#     \"bio\": \"...\",  # unchanged\n# }\n</code></pre>"},{"location":"api/models/model_util/#partial-updates","title":"Partial Updates","text":"<p>Only provided fields are updated:</p> Python<pre><code># Update only email\ndata = UserUpdateSchema(email=\"new@example.com\")\nawait util.update_s(request, data, pk=1, UserReadSchema)\n\n# Update only bio\ndata = UserUpdateSchema(bio=\"New bio\")\nawait util.update_s(request, data, pk=1, UserReadSchema)\n\n# Update both\ndata = UserUpdateSchema(email=\"new@example.com\", bio=\"New bio\")\nawait util.update_s(request, data, pk=1, UserReadSchema)\n</code></pre>"},{"location":"api/models/model_util/#with-custom-actions","title":"With Custom Actions","text":"Python<pre><code>class User(ModelSerializer):\n    class UpdateSerializer:\n        optionals = [(\"email\", str)]\n        customs = [(\"reset_password\", bool, False)]\n\n    async def custom_actions(self, payload):\n        if payload.get(\"reset_password\"):\n            await self.send_password_reset_email()\n\ndata = UserUpdateSchema(email=\"new@example.com\", reset_password=True)\nawait util.update_s(request, data, pk=1, UserReadSchema)\n# Email updated AND password reset email sent\n</code></pre>"},{"location":"api/models/model_util/#delete_s","title":"<code>delete_s()</code>","text":"<p>Delete model instance.</p>"},{"location":"api/models/model_util/#signature_8","title":"Signature","text":"Python<pre><code>async def delete_s(\n    request: HttpRequest,\n    pk: int | str\n) -&gt; None\n</code></pre>"},{"location":"api/models/model_util/#parameters_5","title":"Parameters","text":"Parameter Type Description <code>request</code> <code>HttpRequest</code> Current HTTP request <code>pk</code> <code>int \\| str</code> Primary key of object to delete"},{"location":"api/models/model_util/#return-value_8","title":"Return Value","text":"<p><code>None</code></p>"},{"location":"api/models/model_util/#execution-flow_3","title":"Execution Flow","text":"Text Only<pre><code>1. get_object(pk=pk)\n2. obj.adelete()\n3. obj.on_delete()    [if ModelSerializer]\n</code></pre>"},{"location":"api/models/model_util/#example_6","title":"Example","text":"Python<pre><code>await util.delete_s(request, pk=1)\n# User with id=1 is deleted\n</code></pre>"},{"location":"api/models/model_util/#with-delete-hook","title":"With Delete Hook","text":"Python<pre><code>class User(ModelSerializer):\n    def on_delete(self):\n        logger.info(f\"User {self.username} deleted\")\n        cache.delete(f\"user:{self.id}\")\n\nawait util.delete_s(request, pk=1)\n# Logs deletion and clears cache\n</code></pre>"},{"location":"api/models/model_util/#error-handling","title":"Error Handling","text":"<p>ModelUtil raises <code>SerializeError</code> for various failure scenarios:</p>"},{"location":"api/models/model_util/#404-not-found","title":"404 Not Found","text":"Python<pre><code>from ninja_aio.exceptions import SerializeError\n\ntry:\n    user = await util.get_object(request, pk=999)\nexcept SerializeError as e:\n    print(e.status_code)  # 404\n    print(e.details)\n    # {\"user\": \"not found\"}\n</code></pre>"},{"location":"api/models/model_util/#400-bad-request","title":"400 Bad Request","text":"<p>Invalid base64:</p> Python<pre><code>try:\n    data = DocumentCreateSchema(\n        name=\"doc.pdf\",\n        file_data=\"not-valid-base64!!!\"\n    )\n    await util.create_s(request, data, DocumentReadSchema)\nexcept SerializeError as e:\n    print(e.status_code)  # 400\n    print(e.details)\n    # {\"file_data\": \"Invalid base64 encoding\"}\n</code></pre> <p>Missing related object:</p> Python<pre><code>try:\n    data = ArticleCreateSchema(\n        title=\"Test\",\n        author=999  # Non-existent user ID\n    )\n    await util.create_s(request, data, ArticleReadSchema)\nexcept SerializeError as e:\n    print(e.status_code)  # 400\n    print(e.details)\n    # {\"author\": \"User with id 999 not found\"}\n</code></pre>"},{"location":"api/models/model_util/#performance-optimization","title":"Performance Optimization","text":""},{"location":"api/models/model_util/#automatic-query-optimization","title":"Automatic Query Optimization","text":"Python<pre><code>class Article(ModelSerializer):\n    author = models.ForeignKey(User, on_delete=models.CASCADE)\n    category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True)\n    tags = models.ManyToManyField(Tag, related_name=\"articles\")\n\nutil = ModelUtil(Article)\n\n# Single query optimization\narticle = await util.get_object(request, pk=1)\n# Automatically executes:\n# SELECT * FROM article\n#   LEFT JOIN user ON article.author_id = user.id\n#   LEFT JOIN category ON article.category_id = category.id\n# WITH prefetch for tags\n\n# Queryset optimization\narticles = await util.get_object(request)\n# Automatically adds select_related and prefetch_related\n</code></pre>"},{"location":"api/models/model_util/#manual-optimization","title":"Manual Optimization","text":"<p>For complex scenarios, override in ModelSerializer:</p> Python<pre><code>class Article(ModelSerializer):\n    @classmethod\n    async def queryset_request(cls, request):\n        return cls.objects.select_related(\n            'author',\n            'author__profile',  # Deep relation\n            'category'\n        ).prefetch_related(\n            'tags',\n            'comments__author'  # Nested prefetch\n        ).only(\n            'id', 'title', 'content',  # Limit fields\n            'author__username',\n            'category__name'\n        )\n</code></pre>"},{"location":"api/models/model_util/#integration-with-apiviewset","title":"Integration with APIViewSet","text":"<p>ModelUtil is automatically used by APIViewSet:</p> Python<pre><code>from ninja_aio.views import APIViewSet\n\nclass UserViewSet(APIViewSet):\n    model = User\n    api = api\n\n    # Internally creates ModelUtil(User)\n    # All CRUD operations use ModelUtil methods\n</code></pre>"},{"location":"api/models/model_util/#complete-example","title":"Complete Example","text":"Python<pre><code>from django.db import models\nfrom ninja_aio.models import ModelSerializer, ModelUtil\nfrom ninja import Schema\nfrom django.http import HttpRequest\n\n# Models\nclass Author(ModelSerializer):\n    name = models.CharField(max_length=200)\n    email = models.EmailField(unique=True)\n\n    class CreateSerializer:\n        fields = [\"name\", \"email\"]\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"email\"]\n\nclass Book(ModelSerializer):\n    title = models.CharField(max_length=200)\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"books\")\n    isbn = models.CharField(max_length=13, unique=True)\n    cover_image = models.BinaryField(null=True)\n    is_published = models.BooleanField(default=False)\n\n    class CreateSerializer:\n        fields = [\"title\", \"author\", \"isbn\"]\n        optionals = [(\"cover_image\", str)]  # base64\n        customs = [(\"notify_author\", bool, True)]\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"author\", \"isbn\", \"is_published\"]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"title\", str),\n            (\"is_published\", bool),\n        ]\n\n    async def custom_actions(self, payload):\n        if payload.get(\"notify_author\"):\n            await send_email(\n                self.author.email,\n                f\"New book created: {self.title}\"\n            )\n\n    async def post_create(self):\n        await AuditLog.objects.acreate(\n            action=\"book_created\",\n            book_id=self.id\n        )\n\n# Usage\nasync def example(request: HttpRequest):\n    util = ModelUtil(Book)\n\n    # Create\n    book_data = BookCreateSchema(\n        title=\"Django Unleashed\",\n        author=5,\n        isbn=\"9781234567890\",\n        cover_image=\"iVBORw0KGgo...\",  # base64\n        notify_author=True\n    )\n    created = await util.create_s(request, book_data, BookReadSchema)\n\n    # Read\n    book = await util.get_object(request, pk=created[\"id\"])\n    serialized = await util.read_s(request, book, BookReadSchema)\n\n    # Update\n    update_data = BookUpdateSchema(is_published=True)\n    updated = await util.update_s(request, update_data, created[\"id\"], BookReadSchema)\n\n    # Delete\n    await util.delete_s(request, created[\"id\"])\n</code></pre>"},{"location":"api/models/model_util/#best-practices","title":"Best Practices","text":"<ol> <li>Always use with async views:</li> </ol> Python<pre><code>async def my_view(request):\n    util = ModelUtil(User)\n    users = await util.get_object(request)\n</code></pre> <ol> <li>Reuse util instances when possible:</li> </ol> Python<pre><code># Good: One util per view\nutil = ModelUtil(User)\nuser = await util.create_s(...)\nupdated = await util.update_s(...)\n</code></pre> <ol> <li>Let ModelUtil handle query optimization:</li> </ol> Python<pre><code># Don't manually optimize unless necessary\nuser = await util.get_object(request, pk=1)\n# ModelUtil already applied select_related/prefetch_related\n</code></pre> <ol> <li>Handle SerializeError appropriately:</li> </ol> Python<pre><code>from ninja_aio.exceptions import SerializeError\n\ntry:\n    result = await util.create_s(request, data, schema)\nexcept SerializeError as e:\n    return e.status_code, e.details\n</code></pre> <ol> <li>Use parse_input_data for custom processing: Python<pre><code>payload, customs = await util.parse_input_data(request, data)\n# Process customs before creation\nif customs.get(\"validate_uniqueness\"):\n    # Custom validation logic\n    pass\n</code></pre></li> </ol>"},{"location":"api/models/model_util/#see-also","title":"See Also","text":"<ul> <li>Model Serializer - Define schemas on models</li> <li>API ViewSet - High-level CRUD views using ModelUtil</li> </ul>"},{"location":"api/renderers/orjson_renderer/","title":"ORJSON renderer option","text":"<p>This package uses an internal ORJSON-based renderer. Configure serialization options via Django settings:</p> Python<pre><code># settings.py\nimport orjson\n\n# Single option\nNINJA_AIO_ORJSON_RENDERER_OPTION = orjson.OPT_INDENT_2\n\n# Multiple options (bitwise OR)\nNINJA_AIO_ORJSON_RENDERER_OPTION = (\n    orjson.OPT_INDENT_2 | orjson.OPT_NON_STR_KEYS\n)\n</code></pre> <p>Notes: - The value is an orjson option bitmask (e.g., <code>orjson.OPT_INDENT_2</code>, <code>orjson.OPT_NON_STR_KEYS</code>), and you can combine multiple options using <code>|</code>. - If not set, the default <code>orjson.dumps</code> options are used.</p>"},{"location":"api/views/api_view/","title":"API View","text":"<p>The <code>APIView</code> class provides a base for creating simple API endpoints with custom views.</p>"},{"location":"api/views/api_view/#overview","title":"Overview","text":"<p><code>APIView</code> is a lightweight wrapper around Django Ninja's <code>Router</code> that provides:</p> <ul> <li>Organized routing with tags</li> <li>Custom authentication configuration</li> <li>Error handling with standard HTTP status codes</li> </ul>"},{"location":"api/views/api_view/#class-definition","title":"Class Definition","text":"Python<pre><code>class APIView:\n    api: NinjaAPI\n    router_tag: str\n    api_route_path: str\n    auth: list | None = NOT_SET\n</code></pre>"},{"location":"api/views/api_view/#attributes","title":"Attributes","text":"Attribute Type Description <code>api</code> <code>NinjaAPI</code> The NinjaAPI instance to register routes <code>router_tag</code> <code>str</code> Tag name for grouping endpoints in OpenAPI docs <code>api_route_path</code> <code>str</code> Base path for all routes in this view <code>auth</code> <code>list \\| None</code> Authentication classes (optional)"},{"location":"api/views/api_view/#methods","title":"Methods","text":""},{"location":"api/views/api_view/#views","title":"<code>views()</code>","text":"<p>Override this method to define your custom endpoints.</p> <p>Example - Basic Views:</p> Python<pre><code>class UserAPIView(APIView):\n    api = api_instance\n    router_tag = \"Users\"\n    api_route_path = \"/users\"\n\n    def views(self):\n        @self.router.get(\"/stats\")\n        async def get_stats(request):\n            return {\"total_users\": 100}\n\n        @self.router.post(\"/bulk-create\")\n        async def bulk_create(request, data: list[UserSchema]):\n            # bulk creation logic\n            return {\"created\": len(data)}\n</code></pre> <p>Example - With Authentication:</p> Python<pre><code>class ProtectedAPIView(APIView):\n    api = api_instance\n    router_tag = \"Protected\"\n    api_route_path = \"/protected\"\n    auth = [JWTAuth()]\n\n    def views(self):\n        # Authenticated endpoint\n        @self.router.get(\"/private\", auth=self.auth)\n        async def private_data(request):\n            return {\"user_id\": request.auth.user_id}\n\n        # Public endpoint\n        @self.router.get(\"/public\")\n        async def public_data(request):\n            return {\"message\": \"This is public\"}\n</code></pre>"},{"location":"api/views/api_view/#add_views_to_route","title":"<code>add_views_to_route()</code>","text":"<p>Registers all defined views to the API instance.</p> <p>Returns: The router instance</p> <p>Note: When using <code>@api.view(prefix=\"/path\", tags=[...])</code>, manual registration via <code>add_views_to_route()</code> is not required; the router is mounted automatically.</p>"},{"location":"api/views/api_view/#complete-example","title":"Complete Example","text":"<p>Recommended:</p> Python<pre><code>from ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIView\nfrom ninja import Schema\n\napi = NinjaAIO(title=\"My API\")\n\nclass StatsSchema(Schema):\n    total: int\n    active: int\n\n@api.view(prefix=\"/analytics\", tags=[\"Analytics\"])\nclass AnalyticsView(APIView):\n    def views(self):\n        @self.router.get(\"/dashboard\", response=StatsSchema)\n        async def dashboard(request):\n            return {\"total\": 1000, \"active\": 750}\n\n        @self.router.post(\"/track\")\n        async def track_event(request, event: str):\n            return {\"tracked\": event}\n</code></pre> <p>Alternative implementation:</p> Python<pre><code>api = NinjaAIO(title=\"My API\")\n\nclass AnalyticsView(APIView):\n    api = api\n    router_tag = \"Analytics\"\n    api_route_path = \"/analytics\"\n\n    def views(self):\n        @self.router.get(\"/dashboard\", response=StatsSchema)\n        async def dashboard(request):\n            return {\"total\": 1000, \"active\": 750}\n\n        @self.router.post(\"/track\")\n        async def track_event(request, event: str):\n            return {\"tracked\": event}\n\nAnalyticsView().add_views_to_route()\n</code></pre>"},{"location":"api/views/api_view/#notes","title":"Notes","text":"<ul> <li>Use <code>APIView</code> for simple, non-CRUD endpoints</li> <li>For CRUD operations, use <code>APIViewSet</code></li> <li>All views are async-compatible</li> <li>Standard error codes are available via <code>self.error_codes</code></li> </ul> <p>Note:</p> <ul> <li>Path schema PK type is inferred from the model\u2019s primary key for ViewSets.</li> <li>NinjaAIO remains API-compatible; global CSRF argument is no longer required in initialization.</li> </ul>"},{"location":"api/views/api_view/#see-also","title":"See Also","text":"<ul> <li>API View Set - Full CRUD operations</li> <li>Authentication - Authentication setup</li> </ul>"},{"location":"api/views/api_view_set/","title":"APIViewSet","text":"<p><code>APIViewSet</code> auto-generates async CRUD endpoints and optional Many-to-Many (M2M) endpoints for a Django <code>Model</code> or a <code>ModelSerializer</code>. It supports dynamic schema generation, per-verb authentication, pagination, list &amp; relation filtering with runtime-built Pydantic schemas, and custom view injection.</p>"},{"location":"api/views/api_view_set/#generated-crud-endpoints","title":"Generated CRUD Endpoints","text":"Method Path Summary Response POST <code>/{base}/</code> Create Model <code>201 schema_out</code> GET <code>/{base}/</code> List Models <code>200 List[schema_out]</code> (paginated) GET <code>/{base}/{pk}</code> Retrieve Model <code>200 schema_out</code> PATCH <code>/{base}/{pk}/</code> Update Model <code>200 schema_out</code> DELETE <code>/{base}/{pk}/</code> Delete Model <code>204 No Content</code> <p>Notes:</p> <ul> <li>Retrieve path has no trailing slash; update/delete include a trailing slash.</li> <li><code>{base}</code> auto-resolves from model verbose name plural (lowercase) unless <code>api_route_path</code> is provided.</li> <li>Error responses may use a unified generic schema for codes: 400, 401, 404.</li> </ul>"},{"location":"api/views/api_view_set/#core-attributes","title":"Core Attributes","text":"Attribute Type Default Description <code>model</code> <code>ModelSerializer \\| Model</code> \u2014 Target model (required) <code>api</code> <code>NinjaAPI</code> \u2014 API instance (required) <code>schema_in</code> <code>Schema \\| None</code> <code>None</code> (auto) Create input schema override <code>schema_out</code> <code>Schema \\| None</code> <code>None</code> (auto) Read/output schema override <code>schema_update</code> <code>Schema \\| None</code> <code>None</code> (auto) Update input schema override <code>pagination_class</code> <code>type[AsyncPaginationBase]</code> <code>PageNumberPagination</code> Pagination strategy <code>query_params</code> <code>dict[str, tuple[type, ...]]</code> <code>{}</code> List endpoint filters definition <code>disable</code> <code>list[type[VIEW_TYPES]]</code> <code>[]</code> Disable CRUD views (<code>create</code>,<code>list</code>,<code>retrieve</code>,<code>update</code>,<code>delete</code>,<code>all</code>) <code>api_route_path</code> <code>str</code> <code>\"\"</code> Base route segment <code>list_docs</code> <code>str</code> <code>\"List all objects.\"</code> List endpoint description <code>create_docs</code> <code>str</code> <code>\"Create a new object.\"</code> Create endpoint description <code>retrieve_docs</code> <code>str</code> <code>\"Retrieve a specific object by its primary key.\"</code> Retrieve endpoint description <code>update_docs</code> <code>str</code> <code>\"Update an object by its primary key.\"</code> Update endpoint description <code>delete_docs</code> <code>str</code> <code>\"Delete an object by its primary key.\"</code> Delete endpoint description <code>m2m_relations</code> <code>list[M2MRelationSchema]</code> <code>[]</code> M2M relation configs <code>m2m_auth</code> <code>list \\| None</code> <code>NOT_SET</code> Default auth for all M2M endpoints (overridden per relation if set)"},{"location":"api/views/api_view_set/#authentication-attributes","title":"Authentication Attributes","text":"Attribute Type Default Description <code>auth</code> <code>list \\| None</code> <code>NOT_SET</code> Global fallback auth <code>get_auth</code> <code>list \\| None</code> <code>NOT_SET</code> Auth for list + retrieve <code>post_auth</code> <code>list \\| None</code> <code>NOT_SET</code> Auth for create <code>patch_auth</code> <code>list \\| None</code> <code>NOT_SET</code> Auth for update <code>delete_auth</code> <code>list \\| None</code> <code>NOT_SET</code> Auth for delete <p>Resolution rules:</p> <ul> <li>Per-verb auth overrides <code>auth</code> when not <code>NOT_SET</code>.</li> <li><code>None</code> makes the endpoint public (no authentication).</li> <li>M2M endpoints use relation-level auth (<code>m2m_data.auth</code>) or fall back to <code>m2m_auth</code>.</li> </ul>"},{"location":"api/views/api_view_set/#automatic-schema-generation","title":"Automatic Schema Generation","text":"<p>If <code>model</code> is a subclass of <code>ModelSerializerMeta</code>:</p> <ul> <li><code>schema_out</code> is generated from <code>ReadSerializer</code></li> <li><code>schema_in</code> from <code>CreateSerializer</code></li> <li><code>schema_update</code> from <code>UpdateSerializer</code></li> </ul> <p>Otherwise provide them manually.</p>"},{"location":"api/views/api_view_set/#list-filtering","title":"List Filtering","text":"<p>Define filters for the list view with <code>query_params</code>:</p> Python<pre><code>query_params = {\n    \"is_active\": (bool, None),\n    \"role\": (str, None),\n    \"search\": (str, None),\n}\n</code></pre> <p>Override handler:</p> Python<pre><code>async def query_params_handler(self, queryset, filters: dict):\n    if filters.get(\"is_active\") is not None:\n        queryset = queryset.filter(is_active=filters[\"is_active\"])\n    if filters.get(\"role\"):\n        queryset = queryset.filter(role=filters[\"role\"])\n    if filters.get(\"search\"):\n        from django.db.models import Q\n        s = filters[\"search\"]\n        queryset = queryset.filter(Q(username__icontains=s) | Q(email__icontains=s))\n    return queryset\n</code></pre> <p>A dynamic Pydantic model (<code>FiltersSchema</code>) is built with <code>pydantic.create_model</code> from <code>query_params</code>.</p>"},{"location":"api/views/api_view_set/#list-and-retrieve-implementations","title":"List and Retrieve implementations","text":"<p>List now leverages ModelUtil.get_objects and list_read_s, automatically applying read optimizations and optional filters:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    def views(self):\n        @self.router.get(\"/\")\n        async def list(request, filters: self.filters_schema = None):\n            qs = await self.model_util.get_objects(\n                request,\n                query_data=self._get_query_data(),  # defaults from ModelSerializer.QuerySet.read\n                is_for_read=True,\n            )\n            if filters is not None:\n                qs = await self.query_params_handler(qs, filters.model_dump())\n            return await self.model_util.list_read_s(self.schema_out, request, qs)\n</code></pre> <p>Retrieve uses read_s with getters, deriving PK type from the model:</p> Python<pre><code>@self.router.get(\"/{pk}/\")\nasync def retrieve(request, pk: self.path_schema):\n    return await self.model_util.read_s(\n        self.schema_out,\n        request,\n        query_data=QuerySchema(getters={\"pk\": self._get_pk(pk)}),\n        is_for_read=True,\n    )\n</code></pre> <ul> <li>Path schema PK type is inferred from the model\u2019s primary key field.</li> </ul>"},{"location":"api/views/api_view_set/#many-to-many-relations","title":"Many-to-Many Relations","text":"<p>Relations are declared via <code>M2MRelationSchema</code> objects (not tuples). Each schema can include:</p> <ul> <li><code>model</code>: related Django model or ModelSerializer</li> <li><code>related_name</code>: attribute name on the main model (e.g. <code>\"tags\"</code>)</li> <li><code>path</code>: custom URL segment (optional)</li> <li><code>auth</code>: list of auth instances (optional)</li> <li><code>add</code>: enable additions (bool)</li> <li><code>remove</code>: enable removals (bool)</li> <li><code>get</code>: enable GET listing (bool)</li> <li><code>filters</code>: dict of <code>{param_name: (type, default)}</code> for relation-level filtering</li> <li><code>related_schema</code>: optional pre-built schema for the related model (auto-generated if the <code>model</code> is a <code>ModelSerializer</code>)</li> </ul> <p>If <code>path</code> is empty it falls back to the related model verbose name (lowercase plural). If <code>filters</code> is provided, a per-relation filters schema is auto-generated and exposed on the GET relation endpoint: <code>GET /{base}/{pk}/{related_path}?param=value</code></p> <p>Custom filter hook naming convention: <code>&lt;related_name&gt;_query_params_handler(self, queryset, filters_dict)</code></p> <p>The M2M helper:</p> <ul> <li>Returns a paginated list of related items on GET.</li> <li>Supports both sync and async custom filter handlers.</li> <li>Uses <code>list_read_s</code> for related items serialization.</li> </ul> <p>Example filter handler (sync or async):</p> Python<pre><code>def tags_query_params_handler(self, queryset, filters_dict):\n    name = filters_dict.get(\"name\")\n    return queryset.filter(name=name) if name else queryset\n\n# or\n\nasync def tags_query_params_handler(self, queryset, filters_dict):\n    # perform async lookups if needed, then return queryset\n    return queryset\n</code></pre> <p>Warning: Model support</p> <ul> <li>You can supply a standard Django <code>Model</code> (not a <code>ModelSerializer</code>) in <code>M2MRelationSchema.model</code>. When doing so you must provide <code>related_schema</code> manually:</li> </ul> Python<pre><code>M2MRelationSchema(\n    model=Tag,                # plain django.db.models.Model\n    related_name=\"tags\",\n    related_schema=TagOut,    # a Pydantic/Ninja Schema you define\n    add=True,\n    remove=True,\n    get=True,\n)\n</code></pre> <p>For <code>ModelSerializer</code> models, <code>related_schema</code> can be inferred automatically (via internal helpers).</p> <p>Example with filters:</p> Python<pre><code>class UserViewSet(APIViewSet):\n    model = User\n    api = api\n    m2m_relations = [\n        M2MRelationSchema(\n            model=Tag,\n            related_name=\"tags\",\n            filters={\"name\": (str, \"\")}\n        )\n    ]\n\n    async def tags_query_params_handler(self, queryset, filters):\n        name_filter = filters.get(\"name\")\n        if name_filter:\n            queryset = queryset.filter(name__icontains=name_filter)\n        return queryset\n</code></pre>"},{"location":"api/views/api_view_set/#relation-handlers-get-filters-vs-post-per-pk-resolution","title":"Relation Handlers: GET filters vs POST per-PK resolution","text":"<ul> <li> <p>GET filters handler (per relation):</p> </li> <li> <p>Name: <code>&lt;related_name&gt;_query_params_handler(self, queryset, filters_dict)</code></p> </li> <li>Purpose: apply filters to the related list queryset (GET endpoint).</li> <li> <p>Supports both synchronous and asynchronous functions.</p> </li> <li> <p>POST per-PK resolution handler (per relation):</p> </li> <li>Name: <code>&lt;related_name&gt;_query_handler(self, request, pk, instance)</code></li> <li>Purpose: resolve a single related object (for add/remove validation) before mutation.</li> <li>Must return a queryset; the object is resolved with <code>.afirst()</code>.</li> <li>Automatic fallback if missing: <code>ModelUtil(related_model).get_objects(request, ObjectsQuerySchema(filters={\"pk\": pk}))</code> + <code>.afirst()</code>.</li> </ul> <p>Example:</p> Python<pre><code>class MyViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    async def tags_query_params_handler(self, qs, filters: dict):\n        name = filters.get(\"name\")\n        return qs.filter(name__icontains=name) if name else qs\n\n    async def tags_query_handler(self, request, pk, instance):\n        # allow only tags belonging to the same project as the instance\n        return Tag.objects.filter(pk=pk, project_id=instance.project_id)\n</code></pre>"},{"location":"api/views/api_view_set/#endpoint-paths-and-operation-naming","title":"Endpoint paths and operation naming","text":"<ul> <li> <p>GET relation: <code>/{base}/{pk}/{rel_path}</code> (no trailing slash)</p> </li> <li> <p>OperationId: <code>get_{base_model_name}_{rel_path}</code></p> </li> <li> <p>POST relation: <code>/{base}/{pk}/{rel_path}/</code> (trailing slash)</p> </li> <li>OperationId: <code>manage_{base_model_name}_{rel_path}</code></li> </ul>"},{"location":"api/views/api_view_set/#requestresponse-and-concurrency","title":"Request/Response and concurrency","text":"<p>Request bodies:</p> <ul> <li>Add &amp; Remove: <code>{ \"add\": number[], \"remove\": number[] }</code></li> <li>Add only: <code>{ \"add\": number[] }</code></li> <li>Remove only: <code>{ \"remove\": number[] }</code></li> </ul> <p>Standard response (M2MSchemaOut):</p> JSON<pre><code>{\n  \"results\": { \"count\": X, \"details\": [\"...\"] },\n  \"errors\": { \"count\": Y, \"details\": [\"...\"] }\n}\n</code></pre> <ul> <li>Concurrency: <code>aadd(...)</code> and <code>aremove(...)</code> run in parallel via <code>asyncio.gather</code> when both lists are non-empty.</li> <li>Per-PK errors include: object not found, state mismatch (removing non-related, adding already-related).</li> <li>Per-PK success messages indicate the executed action.</li> </ul>"},{"location":"api/views/api_view_set/#generated-m2m-endpoints-per-relation","title":"Generated M2M Endpoints (per relation)","text":"Method Path Feature GET <code>/{base}/{pk}/{rel_path}</code> List related objects (paginated, optional filters) POST <code>/{base}/{pk}/{rel_path}/</code> Add/remove related objects <p>Example:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    m2m_relations = [\n        M2MRelationSchema(model=Tag, related_name=\"tags\"),\n        M2MRelationSchema(model=Category, related_name=\"categories\", path=\"article-categories\"),\n        M2MRelationSchema(model=User, related_name=\"authors\", path=\"co-authors\", auth=[AdminAuth()])\n    ]\n    m2m_auth = [JWTAuth()]  # fallback for relations without custom auth\n</code></pre>"},{"location":"api/views/api_view_set/#custom-views","title":"Custom Views","text":"<p>Override <code>views()</code> to register extra endpoints:</p> Python<pre><code>def views(self):\n    @self.router.get(\"/stats/\", response={200: GenericMessageSchema})\n    async def stats(request):\n        total = await self.model.objects.acount()\n        return {\"message\": f\"Total: {total}\"}\n</code></pre>"},{"location":"api/views/api_view_set/#dynamic-view-naming","title":"Dynamic View Naming","text":"<p>All generated handlers are decorated with <code>@unique_view(...)</code> to ensure stable unique function names (prevents collisions and ensures consistent OpenAPI schema generation). Relation endpoints use explicit names like <code>get_&lt;model&gt;_&lt;rel_path&gt;</code> and <code>manage_&lt;model&gt;_&lt;rel_path&gt;</code>.</p>"},{"location":"api/views/api_view_set/#overridable-hooks","title":"Overridable Hooks","text":"Hook Purpose <code>views()</code> Register custom endpoints <code>query_params_handler(queryset, filters)</code> Apply list filters <code>&lt;related_name&gt;_query_params_handler(queryset, filters)</code> Apply relation-specific filters"},{"location":"api/views/api_view_set/#error-handling","title":"Error Handling","text":"<p>All CRUD and M2M endpoints may respond with <code>GenericMessageSchema</code> for error codes: 400 (validation), 401 (auth), 404 (not found).</p>"},{"location":"api/views/api_view_set/#performance-tips","title":"Performance Tips","text":"<ol> <li>Implement <code>@classmethod async def queryset_request(cls, request)</code> in your <code>ModelSerializer</code> to prefetch related objects.</li> <li>Use database indexes on filtered fields (<code>query_params</code> and relation <code>filters</code>).</li> <li>Keep pagination enabled for large datasets.</li> <li>Prefetch reverse relations via <code>model_util.get_reverse_relations()</code> (already applied in list view).</li> <li>Limit slice size for expensive searches if needed (<code>queryset = queryset[:1000]</code>).</li> </ol>"},{"location":"api/views/api_view_set/#minimal-usage","title":"Minimal Usage","text":"<p>Recommended:</p> Python<pre><code>from ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom .models import User\n\napi = NinjaAIO(title=\"My API\")\n\n@api.viewset(model=User)\nclass UserViewSet(APIViewSet):\n    pass\n</code></pre> <p>Note: prefix and tags are optional. If omitted, the base path is inferred from the model verbose name plural and tags default to the model verbose name.</p> <p>Alternative implementation:</p> Python<pre><code>from ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom .models import User\n\napi = NinjaAIO(title=\"My API\")\n\nclass UserViewSet(APIViewSet):\n    model = User\n    api = api\n\nUserViewSet().add_views_to_route()\n</code></pre>"},{"location":"api/views/api_view_set/#disable-selected-views","title":"Disable Selected Views","text":"Python<pre><code>@api.viewset(model=User)\nclass ReadOnlyUserViewSet(APIViewSet):\n    disable = [\"create\", \"update\", \"delete\"]\n</code></pre>"},{"location":"api/views/api_view_set/#authentication-example","title":"Authentication Example","text":"Python<pre><code>@api.viewset(model=User)\nclass UserViewSet(APIViewSet):\n    auth = [JWTAuth()]      # global fallback\n    get_auth = None         # list/retrieve public\n    delete_auth = [AdminAuth()]  # delete restricted\n</code></pre>"},{"location":"api/views/api_view_set/#complete-m2m-filters-example","title":"Complete M2M + Filters Example","text":"<p>Recommended:</p> Python<pre><code>from ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom ninja_aio.models import ModelSerializer\nfrom django.db import models\n\napi = NinjaAIO(title=\"My API\")\n\nclass Tag(ModelSerializer):\n    name = models.CharField(max_length=100)\n    class ReadSerializer:\n        fields = [\"id\", \"name\"]\n\nclass User(ModelSerializer):\n    username = models.CharField(max_length=150)\n    tags = models.ManyToManyField(Tag, related_name=\"users\")\n    class ReadSerializer:\n        fields = [\"id\", \"username\", \"tags\"]\n\n@api.viewset(model=User)\nclass UserViewSet(APIViewSet):\n    query_params = {\"search\": (str, None)}\n    m2m_relations = [\n        M2MRelationSchema(\n            model=Tag,\n            related_name=\"tags\",\n            filters={\"name\": (str, \"\")},\n            add=True,\n            remove=True,\n            get=True,\n        )\n    ]\n\n    async def query_params_handler(self, queryset, filters):\n        if filters.get(\"search\"):\n            from django.db.models import Q\n            s = filters[\"search\"]\n            return queryset.filter(Q(username__icontains=s))\n        return queryset\n\n    async def tags_query_params_handler(self, queryset, filters):\n        name_filter = filters.get(\"name\")\n        if name_filter:\n            queryset = queryset.filter(name__icontains=name_filter)\n        return queryset\n</code></pre> <p>Alternative implementation:</p> Python<pre><code>class UserViewSet(APIViewSet):\n    model = User\n    api = api\n    query_params = {\"search\": (str, None)}\n    m2m_relations = [\n        M2MRelationSchema(\n            model=Tag,\n            related_name=\"tags\",\n            filters={\"name\": (str, \"\")},\n            add=True,\n            remove=True,\n            get=True,\n        )\n    ]\n\n    async def query_params_handler(self, queryset, filters):\n        if filters.get(\"search\"):\n            from django.db.models import Q\n            s = filters[\"search\"]\n            return queryset.filter(Q(username__icontains=s))\n        return queryset\n\n    async def tags_query_params_handler(self, queryset, filters):\n        name_filter = filters.get(\"name\")\n        if name_filter:\n            queryset = queryset.filter(name__icontains=name_filter)\n        return queryset\n\nUserViewSet().add_views_to_route()\n</code></pre>"},{"location":"api/views/api_view_set/#readonlyviewset","title":"ReadOnlyViewSet","text":"<p>ReadOnlyViewSet enables only list and retrieve endpoints.</p> Python<pre><code>@api.viewset(model=MyModel)\nclass MyModelReadOnlyViewSet(ReadOnlyViewSet):\n    pass\n</code></pre>"},{"location":"api/views/api_view_set/#writeonlyviewset","title":"WriteOnlyViewSet","text":"<p>WriteOnlyViewSet enables only create, update, and delete endpoints.</p> Python<pre><code>@api.viewset(model=MyModel)\nclass MyModelWriteOnlyViewSet(WriteOnlyViewSet):\n    pass\n</code></pre>"},{"location":"api/views/api_view_set/#see-also","title":"See Also","text":"<ul> <li>ModelSerializer</li> <li>Authentication</li> <li>Pagination</li> <li>APIView</li> </ul>"},{"location":"api/views/decorators/","title":"View decorators","text":"<p>This package provides:</p> <ul> <li>decorate_view: compose multiple decorators (sync/async views), preserving Python stacking order, and skipping None values.</li> <li>APIViewSet.extra_decorators: declarative per-operation decorators.</li> </ul>"},{"location":"api/views/decorators/#decorate_view","title":"decorate_view","text":"<p>Behavior:</p> <ul> <li>Order matches normal stacking: <code>@d1</code> over <code>@d2</code> \u2261 <code>d1(d2(view))</code>.</li> <li>Works with sync/async views.</li> <li>Ignores None values, useful for conditional decoration.</li> </ul> <p>Example:</p> Python<pre><code>from ninja_aio.decorators import decorate_view\nfrom ninja_aio.views import APIViewSet\n\nclass MyViewSet(APIViewSet):\n    api = api\n    model = MyModel\n\n    def views(self):\n        @self.router.get(\"health/\")\n        @decorate_view(authenticate, log_request)\n        async def health(request):\n            return {\"ok\": True}\n</code></pre> <p>Conditional decoration:</p> Python<pre><code>cache_dec = cache_page(60) if settings.ENABLE_CACHE else None\n\n@self.router.get(\"data/\")\n@decorate_view(cache_dec, authenticate)\nasync def data(request):\n    ...\n</code></pre> <p>Note: decorate_view does not add an extra wrapper; each decorator should preserve metadata itself (e.g., functools.wraps).</p>"},{"location":"api/views/decorators/#apiviewsetextra_decorators","title":"APIViewSet.extra_decorators","text":"<p>Attach decorators to CRUD operations without redefining views:</p> Python<pre><code>from ninja_aio.schemas.helpers import DecoratorsSchema\n\nclass MyViewSet(APIViewSet):\n    api = api\n    model = MyModel\n    extra_decorators = DecoratorsSchema(\n        list=[require_auth, cache_page(30)],\n        retrieve=[require_auth],\n        create=[require_auth],\n        update=[require_auth],\n        delete=[require_auth],\n    )\n</code></pre> <p>These are applied in combination with built-ins (e.g., unique_view, paginate) using decorate_view in the implementation.</p>"},{"location":"api/views/mixins/","title":"ViewSet Mixins","text":"<p>These mixins implement a query_params_handler to apply common filtering patterns to Django QuerySets. Import from <code>ninja_aio.views.mixins</code>. Values used for filtering come from validated query params in your viewset\u2019s <code>query_params</code>.</p> <p>Note: Each mixin overrides <code>query_params_handler</code>. When composing multiple mixins, define your own <code>query_params_handler</code> and call <code>super()</code> in the desired order.</p>"},{"location":"api/views/mixins/#icontainsfilterviewsetmixin","title":"IcontainsFilterViewSetMixin","text":"<p>Applies case-insensitive substring filters (<code>__icontains</code>) for string values.</p> <ul> <li>Behavior: For each <code>str</code> value in <code>filters</code>, applies <code>field__icontains=value</code>.</li> <li>Ignores non-string values.</li> </ul> <p>Example:</p> Python<pre><code>from ninja_aio.views.mixins import IcontainsFilterViewSetMixin\nfrom ninja_aio.views.api import APIViewSet\n\nclass UserViewSet(IcontainsFilterViewSetMixin, APIViewSet):\n    model = models.User\n    api = api\n    query_params = {\"name\": (str, \"\"), \"email\": (str, \"\")}\n</code></pre>"},{"location":"api/views/mixins/#booleanfilterviewsetmixin","title":"BooleanFilterViewSetMixin","text":"<p>Filters boolean fields using exact match.</p> <ul> <li>Behavior: Applies <code>{key: value}</code> only for <code>bool</code> values.</li> </ul> <p>Example:</p> Python<pre><code>from ninja_aio.views.mixins import BooleanFilterViewSetMixin\n\nclass FeatureViewSet(BooleanFilterViewSetMixin, APIViewSet):\n    model = models.FeatureFlag\n    api = api\n    query_params = {\"enabled\": (bool, False)}\n</code></pre>"},{"location":"api/views/mixins/#numericfilterviewsetmixin","title":"NumericFilterViewSetMixin","text":"<p>Applies exact filters for numeric values.</p> <ul> <li>Behavior: Filters only <code>int</code> and <code>float</code> values.</li> </ul> <p>Example:</p> Python<pre><code>from ninja_aio.views.mixins import NumericFilterViewSetMixin\n\nclass OrderViewSet(NumericFilterViewSetMixin, APIViewSet):\n    model = models.Order\n    api = api\n    query_params = {\"amount\": (float, 0.0), \"quantity\": (int, 0)}\n</code></pre>"},{"location":"api/views/mixins/#datefilterviewsetmixin","title":"DateFilterViewSetMixin","text":"<p>Base mixin for date/datetime filtering with custom comparisons.</p> <ul> <li>Attributes:</li> <li><code>_compare_attr</code>: comparison operator suffix (e.g., <code>__gt</code>, <code>__lt</code>, <code>__gte</code>, <code>__lte</code>).</li> <li>Behavior: Applies filters for values that implement <code>isoformat</code> (date/datetime-like). Prefer using Pydantic <code>date</code>/<code>datetime</code> types in <code>query_params</code>.</li> </ul> <p>Example:</p> Python<pre><code>from ninja_aio.views.mixins import DateFilterViewSetMixin\n\nclass EventViewSet(DateFilterViewSetMixin, APIViewSet):\n    model = models.Event\n    api = api\n    # Use date/datetime types so values have `isoformat`.\n    query_params = {\"created_at\": (datetime, None)}\n    _compare_attr = \"__gt\"\n</code></pre>"},{"location":"api/views/mixins/#greaterdatefilterviewsetmixin","title":"GreaterDateFilterViewSetMixin","text":"<p>Sets comparison to strict greater-than (<code>__gt</code>).</p> <p>Example:</p> Python<pre><code>from ninja_aio.views.mixins import GreaterDateFilterViewSetMixin\n\nclass EventViewSet(GreaterDateFilterViewSetMixin, APIViewSet):\n    model = models.Event\n    api = api\n    query_params = {\"created_at\": (datetime, None)}\n</code></pre>"},{"location":"api/views/mixins/#lessdatefilterviewsetmixin","title":"LessDateFilterViewSetMixin","text":"<p>Sets comparison to strict less-than (<code>__lt</code>).</p> <p>Example:</p> Python<pre><code>from ninja_aio.views.mixins import LessDateFilterViewSetMixin\n\nclass EventViewSet(LessDateFilterViewSetMixin, APIViewSet):\n    model = models.Event\n    api = api\n    query_params = {\"created_at\": (datetime, None)}\n</code></pre>"},{"location":"api/views/mixins/#greaterequaldatefilterviewsetmixin","title":"GreaterEqualDateFilterViewSetMixin","text":"<p>Sets comparison to greater-than-or-equal (<code>__gte</code>).</p> <p>Example:</p> Python<pre><code>from ninja_aio.views.mixins import GreaterEqualDateFilterViewSetMixin\n\nclass EventViewSet(GreaterEqualDateFilterViewSetMixin, APIViewSet):\n    model = models.Event\n    api = api\n    query_params = {\"created_at\": (datetime, None)}\n</code></pre>"},{"location":"api/views/mixins/#lessequaldatefilterviewsetmixin","title":"LessEqualDateFilterViewSetMixin","text":"<p>Sets comparison to less-than-or-equal (<code>__lte</code>).</p> <p>Example:</p> Python<pre><code>from ninja_aio.views.mixins import LessEqualDateFilterViewSetMixin\n\nclass EventViewSet(LessEqualDateFilterViewSetMixin, APIViewSet):\n    model = models.Event\n    api = api\n    query_params = {\"created_at\": (datetime, None)}\n</code></pre>"},{"location":"api/views/mixins/#tips","title":"Tips","text":"<ul> <li>Align <code>query_params</code> types with expected filter values; prefer Pydantic <code>date</code>/<code>datetime</code> for date filters so values implement <code>isoformat</code>.</li> <li>Validate field names and lookups to avoid runtime errors.</li> <li>For multiple mixins, implement your own <code>async def query_params_handler(...)</code> and chain with <code>await super().query_params_handler(...)</code> to combine behaviors.</li> </ul>"},{"location":"getting_started/installation/","title":"Installation","text":""},{"location":"getting_started/installation/#installation","title":"\ud83d\udce6 Installation","text":"Bash<pre><code>pip install django-ninja-aio-crud\n</code></pre> <p>Requirements: - Python 3.8+ - Django 4.1+ (for async ORM support) - django-ninja</p>"},{"location":"getting_started/quick_start/","title":"Quick Start","text":""},{"location":"getting_started/quick_start/#quick-start","title":"\ud83d\ude80 Quick Start","text":""},{"location":"getting_started/quick_start/#1-create-your-model","title":"1. Create Your Model","text":"<p>Define your model using <code>ModelSerializer</code>:</p> Python<pre><code># models.py\nfrom django.db import models\nfrom ninja_aio.models import ModelSerializer\n\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    is_published = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"content\", \"is_published\", \"created_at\"]\n\n    class CreateSerializer:\n        fields = [\"title\", \"content\"]\n        optionals = [(\"is_published\", bool)]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"title\", str),\n            (\"content\", str),\n            (\"is_published\", bool),\n        ]\n</code></pre>"},{"location":"getting_started/quick_start/#2-create-your-viewset","title":"2. Create Your ViewSet","text":"<p>Define your API views using <code>APIViewSet</code>:</p> Python<pre><code># views.py\nfrom ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom .models import Article\n\napi = NinjaAIO(title=\"My Blog API\", version=\"1.0.0\")\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n\nArticleViewSet().add_views_to_route()\n</code></pre>"},{"location":"getting_started/quick_start/#3-configure-urls","title":"3. Configure URLs","text":"<p>Add the API to your URL configuration:</p> Python<pre><code># urls.py\nfrom django.urls import path\nfrom .views import api\n\nurlpatterns = [\n    path(\"api/\", api.urls),\n]\n</code></pre>"},{"location":"getting_started/quick_start/#4-run-your-server","title":"4. Run Your Server","text":"Bash<pre><code>python manage.py runserver\n</code></pre> <p>Visit http://localhost:8000/api/docs to see your auto-generated API documentation!</p>"},{"location":"getting_started/quick_start/#generated-api-documentation","title":"\ud83d\udcf8 Generated API Documentation","text":""},{"location":"getting_started/quick_start/#endpoints-overview","title":"Endpoints Overview","text":"<p>Your API automatically includes:</p> Method Endpoint Description <code>GET</code> <code>/article/</code> List all articles (paginated) <code>POST</code> <code>/article/</code> Create new article <code>GET</code> <code>/article/{id}</code> Retrieve single article <code>PATCH</code> <code>/article/{id}/</code> Update article <code>DELETE</code> <code>/article/{id}/</code> Delete article"},{"location":"getting_started/quick_start/#list-endpoint","title":"List Endpoint","text":"<p>Features: - Automatic pagination - Query parameter filtering - Sorting support</p>"},{"location":"getting_started/quick_start/#create-endpoint","title":"Create Endpoint","text":"<p>Features: - Input validation - Custom field support - Relationship handling</p>"},{"location":"getting_started/quick_start/#retrieve-endpoint","title":"Retrieve Endpoint","text":"<p>Features: - Nested relationship serialization - Optimized queries</p>"},{"location":"getting_started/quick_start/#update-endpoint","title":"Update Endpoint","text":"<p>Features: - Partial updates (PATCH) - Field-level validation - Custom actions</p>"},{"location":"getting_started/quick_start/#delete-endpoint","title":"Delete Endpoint","text":"<p>Features: - Soft delete support - Cascade handling - Custom hooks</p>"},{"location":"tutorial/authentication/","title":"Step 3: Add Authentication","text":"<p>In this step, you'll learn how to secure your API with JWT authentication and implement role-based access control.</p>"},{"location":"tutorial/authentication/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Setting up JWT authentication</li> <li>Protecting endpoints</li> <li>Implementing role-based access</li> <li>Creating login/register endpoints</li> <li>Testing authenticated requests</li> </ul>"},{"location":"tutorial/authentication/#prerequisites","title":"Prerequisites","text":"<p>Make sure you've completed: - Step 1: Define Your Model - Step 2: Create CRUD Views</p>"},{"location":"tutorial/authentication/#setting-up-jwt-keys","title":"Setting Up JWT Keys","text":""},{"location":"tutorial/authentication/#generate-rsa-keys-recommended-for-production","title":"Generate RSA Keys (Recommended for Production)","text":"Bash<pre><code># Generate private key\nopenssl genrsa -out private_key.pem 2048\n\n# Generate public key\nopenssl rsa -in private_key.pem -pubout -out public_key.pem\n</code></pre>"},{"location":"tutorial/authentication/#store-keys-securely","title":"Store Keys Securely","text":"Python<pre><code># settings.py\nimport os\nfrom pathlib import Path\n\nBASE_DIR = Path(__file__).resolve().parent.parent\n\n# JWT Settings\nJWT_PRIVATE_KEY_PATH = os.path.join(BASE_DIR, 'private_key.pem')\nJWT_PUBLIC_KEY_PATH = os.path.join(BASE_DIR, 'public_key.pem')\n\n# Read keys\nwith open(JWT_PUBLIC_KEY_PATH, 'r') as f:\n    JWT_PUBLIC_KEY = f.read()\n\nwith open(JWT_PRIVATE_KEY_PATH, 'r') as f:\n    JWT_PRIVATE_KEY = f.read()\n\n# Token expiration (in seconds)\nJWT_ACCESS_TOKEN_EXPIRE = 60 * 15  # 15 minutes\nJWT_REFRESH_TOKEN_EXPIRE = 60 * 60 * 24 * 7  # 7 days\n\n# JWT Claims\nJWT_ISSUER = \"https://your-api.com\"\nJWT_AUDIENCE = \"your-api\"\n</code></pre> <p>Security</p> <p>Never commit your private key to version control! Add <code>private_key.pem</code> to your <code>.gitignore</code>.</p>"},{"location":"tutorial/authentication/#create-user-model","title":"Create User Model","text":"<p>Update your User model to work with authentication:</p> Python<pre><code># models.py\nfrom django.contrib.auth.models import AbstractUser\nfrom django.db import models\nfrom ninja_aio.models import ModelSerializer\n\n\nclass User(AbstractUser, ModelSerializer):\n    email = models.EmailField(unique=True)\n    bio = models.TextField(blank=True)\n    avatar = models.URLField(blank=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"username\", \"email\", \"first_name\", \"last_name\", \"bio\", \"avatar\"]\n        excludes = [\"password\"]\n\n    class CreateSerializer:\n        fields = [\"username\", \"email\", \"password\", \"first_name\", \"last_name\"]\n        optionals = [(\"bio\", str), (\"avatar\", str)]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"first_name\", str),\n            (\"last_name\", str),\n            (\"bio\", str),\n            (\"avatar\", str),\n        ]\n        excludes = [\"username\", \"email\", \"password\"]\n\n    def __str__(self):\n        return self.username\n\n\n# Update Article model to use custom User\nclass Article(ModelSerializer):\n    # ... existing fields ...\n    author = models.ForeignKey(\n        \"User\",  # Use string reference\n        on_delete=models.CASCADE,\n        related_name=\"articles\"\n    )\n    # ... rest of model ...\n</code></pre>"},{"location":"tutorial/authentication/#configure-django-to-use-custom-user","title":"Configure Django to Use Custom User","text":"Python<pre><code># settings.py\nAUTH_USER_MODEL = 'myapp.User'  # Replace 'myapp' with your app name\n</code></pre>"},{"location":"tutorial/authentication/#run-migrations","title":"Run Migrations","text":"Bash<pre><code>python manage.py makemigrations\npython manage.py migrate\n</code></pre>"},{"location":"tutorial/authentication/#create-authentication-class","title":"Create Authentication Class","text":"Python<pre><code># auth.py\nfrom ninja_aio.auth import AsyncJwtBearer\nfrom joserfc import jwk\nfrom django.conf import settings\nfrom .models import User\n\n\nclass JWTAuth(AsyncJwtBearer):\n    # Import public key for verification\n    jwt_public = jwk.RSAKey.import_key(settings.JWT_PUBLIC_KEY)\n    jwt_alg = \"RS256\"\n\n    # Validate required claims\n    claims = {\n        \"iss\": {\"essential\": True, \"value\": settings.JWT_ISSUER},\n        \"aud\": {\"essential\": True, \"value\": settings.JWT_AUDIENCE},\n        \"sub\": {\"essential\": True},  # User ID\n    }\n\n    async def auth_handler(self, request):\n        \"\"\"\n        Called after token validation.\n        Returns the user object that will be attached to request.auth\n        \"\"\"\n        # Get user ID from token\n        user_id = self.dcd.claims.get(\"sub\")\n\n        try:\n            # Fetch user from database\n            user = await User.objects.aget(id=user_id, is_active=True)\n            return user\n        except User.DoesNotExist:\n            return False\n</code></pre>"},{"location":"tutorial/authentication/#create-token-generation-helper","title":"Create Token Generation Helper","text":"Python<pre><code># utils.py\nfrom datetime import datetime, timedelta\nimport jwt\nfrom django.conf import settings\n\n\ndef create_access_token(user_id: int, **extra_claims) -&gt; str:\n    \"\"\"Generate JWT access token\"\"\"\n    now = datetime.utcnow()\n\n    payload = {\n        \"sub\": str(user_id),\n        \"iss\": settings.JWT_ISSUER,\n        \"aud\": settings.JWT_AUDIENCE,\n        \"iat\": now,\n        \"exp\": now + timedelta(seconds=settings.JWT_ACCESS_TOKEN_EXPIRE),\n        **extra_claims\n    }\n\n    token = jwt.encode(\n        payload,\n        settings.JWT_PRIVATE_KEY,\n        algorithm=\"RS256\"\n    )\n\n    return token\n\n\ndef create_refresh_token(user_id: int) -&gt; str:\n    \"\"\"Generate JWT refresh token\"\"\"\n    now = datetime.utcnow()\n\n    payload = {\n        \"sub\": str(user_id),\n        \"iss\": settings.JWT_ISSUER,\n        \"aud\": settings.JWT_AUDIENCE,\n        \"iat\": now,\n        \"exp\": now + timedelta(seconds=settings.JWT_REFRESH_TOKEN_EXPIRE),\n        \"type\": \"refresh\"\n    }\n\n    token = jwt.encode(\n        payload,\n        settings.JWT_PRIVATE_KEY,\n        algorithm=\"RS256\"\n    )\n\n    return token\n</code></pre>"},{"location":"tutorial/authentication/#create-loginregister-endpoints","title":"Create Login/Register Endpoints","text":"Python<pre><code># views.py\nfrom ninja_aio import NinjaAIO\nfrom ninja import Schema\nfrom ninja_aio.exceptions import SerializeError\nfrom django.contrib.auth.hashers import make_password, check_password\nfrom .models import User\nfrom .utils import create_access_token, create_refresh_token\nfrom .auth import JWTAuth\n\napi = NinjaAIO(title=\"Blog API\", version=\"1.0.0\")\n\n\n# Schemas for authentication\nclass RegisterSchema(Schema):\n    username: str\n    email: str\n    password: str\n    first_name: str = \"\"\n    last_name: str = \"\"\n\n\nclass LoginSchema(Schema):\n    username: str\n    password: str\n\n\nclass TokenResponse(Schema):\n    access_token: str\n    refresh_token: str\n    token_type: str = \"bearer\"\n    expires_in: int\n\n\nclass UserResponse(Schema):\n    id: int\n    username: str\n    email: str\n    first_name: str\n    last_name: str\n\n\n# Register endpoint\n@api.post(\"/auth/register/\", response=TokenResponse)\nasync def register(request, data: RegisterSchema):\n    \"\"\"Register a new user\"\"\"\n    # Check if username exists\n    if await User.objects.filter(username=data.username).aexists():\n        raise SerializeError(\n            {\"username\": \"Username already taken\"},\n            status_code=400\n        )\n\n    # Check if email exists\n    if await User.objects.filter(email=data.email).aexists():\n        raise SerializeError(\n            {\"email\": \"Email already registered\"},\n            status_code=400\n        )\n\n    # Create user\n    user = await User.objects.acreate(\n        username=data.username,\n        email=data.email,\n        password=make_password(data.password),\n        first_name=data.first_name,\n        last_name=data.last_name,\n    )\n\n    # Generate tokens\n    access_token = create_access_token(user.id)\n    refresh_token = create_refresh_token(user.id)\n\n    from django.conf import settings\n    return {\n        \"access_token\": access_token,\n        \"refresh_token\": refresh_token,\n        \"expires_in\": settings.JWT_ACCESS_TOKEN_EXPIRE\n    }\n\n\n# Login endpoint\n@api.post(\"/auth/login/\", response=TokenResponse)\nasync def login(request, data: LoginSchema):\n    \"\"\"Login user\"\"\"\n    try:\n        user = await User.objects.aget(username=data.username)\n    except User.DoesNotExist:\n        raise SerializeError(\n            {\"detail\": \"Invalid credentials\"},\n            status_code=401\n        )\n\n    # Check password\n    if not check_password(data.password, user.password):\n        raise SerializeError(\n            {\"detail\": \"Invalid credentials\"},\n            status_code=401\n        )\n\n    # Check if user is active\n    if not user.is_active:\n        raise SerializeError(\n            {\"detail\": \"Account is disabled\"},\n            status_code=401\n        )\n\n    # Generate tokens\n    access_token = create_access_token(user.id)\n    refresh_token = create_refresh_token(user.id)\n\n    from django.conf import settings\n    return {\n        \"access_token\": access_token,\n        \"refresh_token\": refresh_token,\n        \"expires_in\": settings.JWT_ACCESS_TOKEN_EXPIRE\n    }\n\n\n# Get current user\n@api.get(\"/auth/me/\", response=UserResponse, auth=JWTAuth())\nasync def me(request):\n    \"\"\"Get current authenticated user\"\"\"\n    user = request.auth\n    return {\n        \"id\": user.id,\n        \"username\": user.username,\n        \"email\": user.email,\n        \"first_name\": user.first_name,\n        \"last_name\": user.last_name,\n    }\n\n\n# Refresh token\n@api.post(\"/auth/refresh/\", response=TokenResponse)\nasync def refresh(request, refresh_token: str):\n    \"\"\"Refresh access token\"\"\"\n    import jwt\n    from django.conf import settings\n\n    try:\n        # Decode refresh token\n        payload = jwt.decode(\n            refresh_token,\n            settings.JWT_PUBLIC_KEY,\n            algorithms=[\"RS256\"],\n            audience=settings.JWT_AUDIENCE,\n            issuer=settings.JWT_ISSUER\n        )\n\n        # Check token type\n        if payload.get(\"type\") != \"refresh\":\n            raise SerializeError(\n                {\"detail\": \"Invalid token type\"},\n                status_code=401\n            )\n\n        user_id = int(payload.get(\"sub\"))\n\n        # Generate new tokens\n        new_access_token = create_access_token(user_id)\n        new_refresh_token = create_refresh_token(user_id)\n\n        return {\n            \"access_token\": new_access_token,\n            \"refresh_token\": new_refresh_token,\n            \"expires_in\": settings.JWT_ACCESS_TOKEN_EXPIRE\n        }\n\n    except jwt.ExpiredSignatureError:\n        raise SerializeError(\n            {\"detail\": \"Refresh token expired\"},\n            status_code=401\n        )\n    except jwt.InvalidTokenError:\n        raise SerializeError(\n            {\"detail\": \"Invalid refresh token\"},\n            status_code=401\n        )\n</code></pre>"},{"location":"tutorial/authentication/#protect-your-viewsets","title":"Protect Your ViewSets","text":"<p>Now let's add authentication to your CRUD endpoints:</p> Python<pre><code># views.py\nfrom ninja_aio.views import APIViewSet\nfrom .models import Article\nfrom .auth import JWTAuth\n\napi = NinjaAIO(title=\"Blog API\", version=\"1.0.0\")\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    # Public read, authenticated write\n    get_auth = None  # List and retrieve are public\n    post_auth = [JWTAuth()]  # Create requires auth\n    patch_auth = [JWTAuth()]  # Update requires auth\n    delete_auth = [JWTAuth()]  # Delete requires auth\n\n\nArticleViewSet().add_views_to_route()\n</code></pre>"},{"location":"tutorial/authentication/#set-author-automatically","title":"Set Author Automatically","text":"<p>Modify the Article model to set the author from the authenticated user:</p> Python<pre><code># models.py\nclass Article(ModelSerializer):\n    # ... existing fields ...\n\n    @classmethod\n    async def queryset_request(cls, request):\n        \"\"\"Filter articles based on authentication\"\"\"\n        qs = cls.objects.select_related('author', 'category').prefetch_related('tags')\n\n        # Show all published articles\n        # Plus user's own drafts if authenticated\n        if request.auth:\n            from django.db.models import Q\n            return qs.filter(\n                Q(is_published=True) | Q(author=request.auth)\n            )\n\n        return qs.filter(is_published=True)\n\n    async def custom_actions(self, payload: dict):\n        \"\"\"Set author from request\"\"\"\n        # This is called during creation\n        if hasattr(self, '_request') and self._request.auth:\n            self.author = self._request.auth\n            await self.asave(update_fields=['author'])\n\n        # Call parent\n        await super().custom_actions(payload)\n</code></pre>"},{"location":"tutorial/authentication/#role-based-access-control","title":"Role-Based Access Control","text":"<p>Create different authentication classes for different roles:</p> Python<pre><code># auth.py\nfrom ninja_aio.auth import AsyncJwtBearer\nfrom joserfc import jwk\nfrom django.conf import settings\nfrom .models import User\n\n\nclass JWTAuth(AsyncJwtBearer):\n    \"\"\"Base JWT authentication\"\"\"\n    jwt_public = jwk.RSAKey.import_key(settings.JWT_PUBLIC_KEY)\n    jwt_alg = \"RS256\"\n    claims = {\n        \"iss\": {\"essential\": True, \"value\": settings.JWT_ISSUER},\n        \"aud\": {\"essential\": True, \"value\": settings.JWT_AUDIENCE},\n        \"sub\": {\"essential\": True},\n    }\n\n    async def auth_handler(self, request):\n        user_id = self.dcd.claims.get(\"sub\")\n        try:\n            user = await User.objects.aget(id=user_id, is_active=True)\n            return user\n        except User.DoesNotExist:\n            return False\n\n\nclass AdminAuth(JWTAuth):\n    \"\"\"Requires admin/staff privileges\"\"\"\n\n    async def auth_handler(self, request):\n        user = await super().auth_handler(request)\n\n        if not user.is_staff:\n            return False\n\n        return user\n\n\nclass SuperuserAuth(JWTAuth):\n    \"\"\"Requires superuser privileges\"\"\"\n\n    async def auth_handler(self, request):\n        user = await super().auth_handler(request)\n\n        if not user.is_superuser:\n            return False\n\n        return user\n</code></pre>"},{"location":"tutorial/authentication/#apply-role-based-auth","title":"Apply Role-Based Auth","text":"Python<pre><code># views.py\nfrom .auth import JWTAuth, AdminAuth\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    # Public read\n    get_auth = None\n\n    # Regular users can create\n    post_auth = [JWTAuth()]\n\n    # Regular users can update (own articles)\n    patch_auth = [JWTAuth()]\n\n    # Only admins can delete\n    delete_auth = [AdminAuth()]\n\n\nclass UserViewSet(APIViewSet):\n    model = User\n    api = api\n\n    # Only admins can manage users\n    auth = [AdminAuth()]\n\n\nArticleViewSet().add_views_to_route()\nUserViewSet().add_views_to_route()\n</code></pre>"},{"location":"tutorial/authentication/#ownership-validation","title":"Ownership Validation","text":"<p>Ensure users can only edit their own articles:</p> Python<pre><code># views.py\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    get_auth = None\n    post_auth = [JWTAuth()]\n    patch_auth = [JWTAuth()]\n    delete_auth = [JWTAuth()]\n\n    def views(self):\n        # Override update to check ownership\n        @self.router.patch(\"/{pk}/\")\n        async def update(request, pk: int, data: Article.generate_update_s()):\n            \"\"\"Update article (owner or admin only)\"\"\"\n            try:\n                article = await Article.objects.aget(pk=pk)\n            except Article.DoesNotExist:\n                raise SerializeError({\"article\": \"not found\"}, status_code=404)\n\n            # Check ownership (unless admin)\n            user = request.auth\n            if article.author_id != user.id and not user.is_staff:\n                raise SerializeError(\n                    {\"detail\": \"You can only edit your own articles\"},\n                    status_code=403\n                )\n\n            # Update article\n            from ninja_aio.models import ModelUtil\n            util = ModelUtil(Article)\n            schema = Article.generate_read_s()\n\n            return await util.update_s(request, article, data, schema)\n\n        # Override delete to check ownership\n        @self.router.delete(\"/{pk}/\")\n        async def delete(request, pk: int):\n            \"\"\"Delete article (owner or admin only)\"\"\"\n            try:\n                article = await Article.objects.aget(pk=pk)\n            except Article.DoesNotExist:\n                raise SerializeError({\"article\": \"not found\"}, status_code=404)\n\n            # Check ownership (unless admin)\n            user = request.auth\n            if article.author_id != user.id and not user.is_staff:\n                raise SerializeError(\n                    {\"detail\": \"You can only delete your own articles\"},\n                    status_code=403\n                )\n\n            await article.adelete()\n            return {\"message\": \"Article deleted successfully\"}\n\n\nArticleViewSet().add_views_to_route()\n</code></pre>"},{"location":"tutorial/authentication/#testing-authentication","title":"Testing Authentication","text":""},{"location":"tutorial/authentication/#register-a-user","title":"Register a User","text":"Bash<pre><code>curl -X POST http://localhost:8000/api/auth/register/ \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"username\": \"johndoe\",\n    \"email\": \"john@example.com\",\n    \"password\": \"secure_password_123\",\n    \"first_name\": \"John\",\n    \"last_name\": \"Doe\"\n  }'\n</code></pre> <p>Response:</p> JSON<pre><code>{\n  \"access_token\": \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...\",\n  \"refresh_token\": \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...\",\n  \"token_type\": \"bearer\",\n  \"expires_in\": 900\n}\n</code></pre>"},{"location":"tutorial/authentication/#login","title":"Login","text":"Bash<pre><code>curl -X POST http://localhost:8000/api/auth/login/ \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"username\": \"johndoe\",\n    \"password\": \"secure_password_123\"\n  }'\n</code></pre>"},{"location":"tutorial/authentication/#get-current-user","title":"Get Current User","text":"Bash<pre><code>curl http://localhost:8000/api/auth/me/ \\\n  -H \"Authorization: Bearer YOUR_ACCESS_TOKEN\"\n</code></pre>"},{"location":"tutorial/authentication/#create-article-authenticated","title":"Create Article (Authenticated)","text":"Bash<pre><code>curl -X POST http://localhost:8000/api/article/ \\\n  -H \"Authorization: Bearer YOUR_ACCESS_TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"title\": \"My Article\",\n    \"content\": \"Article content...\",\n    \"category\": 1\n  }'\n</code></pre>"},{"location":"tutorial/authentication/#refresh-token","title":"Refresh Token","text":"Bash<pre><code>curl -X POST http://localhost:8000/api/auth/refresh/ \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"refresh_token\": \"YOUR_REFRESH_TOKEN\"}'\n</code></pre>"},{"location":"tutorial/authentication/#error-responses","title":"Error Responses","text":""},{"location":"tutorial/authentication/#missing-token","title":"Missing Token","text":"Bash<pre><code>curl http://localhost:8000/api/article/ \\\n  -X POST \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"title\": \"Test\"}'\n</code></pre> <p>Response (401):</p> JSON<pre><code>{\n  \"detail\": \"Unauthorized\"\n}\n</code></pre>"},{"location":"tutorial/authentication/#invalid-token","title":"Invalid Token","text":"Bash<pre><code>curl http://localhost:8000/api/article/ \\\n  -H \"Authorization: Bearer invalid_token\" \\\n  -X POST\n</code></pre> <p>Response (401):</p> JSON<pre><code>{\n  \"detail\": \"Invalid token\"\n}\n</code></pre>"},{"location":"tutorial/authentication/#expired-token","title":"Expired Token","text":"<p>Response (401):</p> JSON<pre><code>{\n  \"detail\": \"Token has expired\"\n}\n</code></pre>"},{"location":"tutorial/authentication/#insufficient-permissions","title":"Insufficient Permissions","text":"Bash<pre><code># Regular user trying to delete\ncurl -X DELETE http://localhost:8000/api/article/1/ \\\n  -H \"Authorization: Bearer USER_TOKEN\"\n</code></pre> <p>Response (403):</p> JSON<pre><code>{\n  \"detail\": \"Admin privileges required\"\n}\n</code></pre>"},{"location":"tutorial/authentication/#using-swagger-ui-with-auth","title":"Using Swagger UI with Auth","text":"<p>The Swagger UI at <code>/api/docs</code> has built-in authentication support:</p> <ol> <li>Click the \"Authorize\" button at the top</li> <li>Enter your token: <code>Bearer YOUR_ACCESS_TOKEN</code></li> <li>Click \"Authorize\"</li> <li>Now all requests will include the token</li> </ol>"},{"location":"tutorial/authentication/#custom-claims","title":"Custom Claims","text":"<p>Add custom claims to your tokens:</p> Python<pre><code># utils.py\ndef create_access_token(user_id: int, **extra_claims) -&gt; str:\n    \"\"\"Generate JWT access token with custom claims\"\"\"\n    now = datetime.utcnow()\n\n    # Add custom claims\n    payload = {\n        \"sub\": str(user_id),\n        \"iss\": settings.JWT_ISSUER,\n        \"aud\": settings.JWT_AUDIENCE,\n        \"iat\": now,\n        \"exp\": now + timedelta(seconds=settings.JWT_ACCESS_TOKEN_EXPIRE),\n        **extra_claims\n    }\n\n    return jwt.encode(payload, settings.JWT_PRIVATE_KEY, algorithm=\"RS256\")\n\n\n# In login endpoint\nasync def login(request, data: LoginSchema):\n    # ... authentication logic ...\n\n    # Create token with custom claims\n    access_token = create_access_token(\n        user.id,\n        email=user.email,\n        username=user.username,\n        is_staff=user.is_staff,\n        permissions=[\"read:articles\", \"write:articles\"]\n    )\n\n    # ...\n</code></pre> <p>Access custom claims in your auth handler:</p> Python<pre><code>class JWTAuth(AsyncJwtBearer):\n    # ...\n\n    async def auth_handler(self, request):\n        user_id = self.dcd.claims.get(\"sub\")\n        user = await User.objects.aget(id=user_id, is_active=True)\n\n        # Attach custom claims to request\n        request.user_permissions = self.dcd.claims.get(\"permissions\", [])\n        request.user_email = self.dcd.claims.get(\"email\")\n\n        return user\n</code></pre>"},{"location":"tutorial/authentication/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Use RSA keys in production: Python<pre><code>jwt_public = jwk.RSAKey.import_key(settings.JWT_PUBLIC_KEY)\njwt_alg = \"RS256\"\n</code></pre></p> </li> <li> <p>Keep access tokens short-lived: Python<pre><code>JWT_ACCESS_TOKEN_EXPIRE = 60 * 15  # 15 minutes\n</code></pre></p> </li> <li> <p>Use refresh tokens: Python<pre><code>JWT_REFRESH_TOKEN_EXPIRE = 60 * 60 * 24 * 7  # 7 days\n</code></pre></p> </li> <li> <p>Validate claims: Python<pre><code>claims = {\n    \"iss\": {\"essential\": True, \"value\": \"your-issuer\"},\n    \"aud\": {\"essential\": True, \"value\": \"your-api\"},\n}\n</code></pre></p> </li> <li> <p>Hash passwords properly: Python<pre><code>from django.contrib.auth.hashers import make_password\npassword = make_password(raw_password)\n</code></pre></p> </li> <li> <p>Check user ownership: Python<pre><code>if article.author_id != user.id and not user.is_staff:\n    raise SerializeError({\"detail\": \"Forbidden\"}, status_code=403)\n</code></pre></p> </li> <li> <p>Use HTTPS in production - Never send tokens over HTTP</p> </li> <li> <p>Implement token blacklist for logout functionality</p> </li> </ol>"},{"location":"tutorial/authentication/#next-steps","title":"Next Steps","text":"<p>Now that you have authentication set up, let's customize schemas in Step 4: Filtering &amp; Pagination.</p> <p>What You've Learned</p> <ul> <li>\u2705 Setting up JWT authentication</li> <li>\u2705 Creating login/register endpoints</li> <li>\u2705 Protecting API endpoints</li> <li>\u2705 Implementing role-based access control</li> <li>\u2705 Validating ownership</li> <li>\u2705 Testing authenticated requests</li> </ul>"},{"location":"tutorial/authentication/#see-also","title":"See Also","text":"<ul> <li>Authentication API Reference - Complete authentication documentation</li> <li>APIViewSet Auth Options - ViewSet authentication options</li> </ul>"},{"location":"tutorial/crud/","title":"Step 2: Create CRUD Views","text":"<p>In this step, you'll learn how to create a complete REST API with CRUD operations using <code>APIViewSet</code>.</p>"},{"location":"tutorial/crud/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>How to create a basic ViewSet</li> <li>Understanding auto-generated endpoints</li> <li>Customizing query parameters</li> <li>Adding custom endpoints</li> <li>Working with request context</li> <li>Handling errors</li> </ul>"},{"location":"tutorial/crud/#prerequisites","title":"Prerequisites","text":"<p>Make sure you've completed:</p> <ul> <li>Step 1: Define Your Model</li> </ul> <p>You should have the <code>Article</code>, <code>Author</code>, <code>Category</code>, and <code>Tag</code> models defined.</p>"},{"location":"tutorial/crud/#basic-viewset","title":"Basic ViewSet","text":"<p>Let's create a simple API for the Article model:</p> Python<pre><code># views.py\nfrom ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom .models import Article\n\n# Create API instance\napi = NinjaAIO(\n    title=\"Blog API\",\n    version=\"1.0.0\",\n    description=\"A simple blog API built with Django Ninja Aio CRUD\"\n)\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n\n# Register the ViewSet\nArticleViewSet().add_views_to_route()\n</code></pre> <p>That's it! You now have a complete CRUD API with 5 endpoints.</p>"},{"location":"tutorial/crud/#configure-urls","title":"Configure URLs","text":"<p>Add the API to your Django URLs:</p> Python<pre><code># urls.py\nfrom django.contrib import admin\nfrom django.urls import path\nfrom myapp.views import api\n\nurlpatterns = [\n    path(\"admin/\", admin.site.urls),\n    path(\"api/\", api.urls),\n]\n</code></pre>"},{"location":"tutorial/crud/#auto-generated-endpoints","title":"Auto-Generated Endpoints","text":"<p>The ViewSet automatically generates these endpoints:</p> Method Endpoint Description Request Body Response <code>GET</code> <code>/api/article/</code> List all articles (paginated) None <code>{count, next, previous, results}</code> <code>POST</code> <code>/api/article/</code> Create new article Article data Created article <code>GET</code> <code>/api/article/{id}</code> Retrieve single article None Article data <code>PATCH</code> <code>/api/article/{id}/</code> Update article Partial article data Updated article <code>DELETE</code> <code>/api/article/{id}/</code> Delete article None None (204)"},{"location":"tutorial/crud/#test-your-api","title":"Test Your API","text":"<p>Start the development server:</p> Bash<pre><code>python manage.py runserver\n</code></pre> <p>Visit http://localhost:8000/api/docs to see the auto-generated Swagger UI documentation.</p>"},{"location":"tutorial/crud/#creating-multiple-viewsets","title":"Creating Multiple ViewSets","text":"<p>Let's add APIs for all our models:</p> Python<pre><code># views.py\nfrom ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom .models import Article, Author, Category, Tag\n\napi = NinjaAIO(title=\"Blog API\", version=\"1.0.0\")\n\n\nclass AuthorViewSet(APIViewSet):\n    model = Author\n    api = api\n\n\nclass CategoryViewSet(APIViewSet):\n    model = Category\n    api = api\n\n\nclass TagViewSet(APIViewSet):\n    model = Tag\n    api = api\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n\n# Register all ViewSets\nAuthorViewSet().add_views_to_route()\nCategoryViewSet().add_views_to_route()\nTagViewSet().add_views_to_route()\nArticleViewSet().add_views_to_route()\n</code></pre> <p>Now you have complete CRUD APIs for all models:</p> <ul> <li><code>/api/author/</code></li> <li><code>/api/category/</code></li> <li><code>/api/tag/</code></li> <li><code>/api/article/</code></li> </ul>"},{"location":"tutorial/crud/#adding-query-parameters","title":"Adding Query Parameters","text":"<p>Let's add filtering to the Article list endpoint:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    query_params = {\n        \"is_published\": (bool, None),\n        \"author\": (int, None),\n        \"category\": (int, None),\n        \"search\": (str, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        # Filter by published status\n        if filters.get(\"is_published\") is not None:\n            queryset = queryset.filter(is_published=filters[\"is_published\"])\n\n        # Filter by author\n        if filters.get(\"author\"):\n            queryset = queryset.filter(author_id=filters[\"author\"])\n\n        # Filter by category\n        if filters.get(\"category\"):\n            queryset = queryset.filter(category_id=filters[\"category\"])\n\n        # Search in title and content\n        if filters.get(\"search\"):\n            from django.db.models import Q\n            search_term = filters[\"search\"]\n            queryset = queryset.filter(\n                Q(title__icontains=search_term) |\n                Q(content__icontains=search_term)\n            )\n\n        return queryset\n\n\nArticleViewSet().add_views_to_route()\n</code></pre>"},{"location":"tutorial/crud/#using-query-parameters","title":"Using Query Parameters","text":"<p>Now you can filter articles:</p> Bash<pre><code># Get published articles\nGET /api/article/?is_published=true\n\n# Get articles by specific author\nGET /api/article/?author=5\n\n# Get articles in specific category\nGET /api/article/?category=3\n\n# Search articles\nGET /api/article/?search=django\n\n# Combine filters\nGET /api/article/?is_published=true&amp;author=5&amp;category=3\n\n# With pagination\nGET /api/article/?is_published=true&amp;page=2&amp;page_size=20\n</code></pre>"},{"location":"tutorial/crud/#custom-endpoints","title":"Custom Endpoints","text":"<p>Add custom endpoints beyond CRUD:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    def views(self):\n        \"\"\"Define custom endpoints\"\"\"\n\n        # Publish an article\n        @self.router.post(\"/{pk}/publish/\")\n        async def publish(request, pk: int):\n            article = await Article.objects.aget(pk=pk)\n            article.is_published = True\n            from django.utils import timezone\n            article.published_at = timezone.now()\n            await article.asave()\n\n            return {\n                \"message\": \"Article published successfully\",\n                \"published_at\": article.published_at\n            }\n\n        # Unpublish an article\n        @self.router.post(\"/{pk}/unpublish/\")\n        async def unpublish(request, pk: int):\n            article = await Article.objects.aget(pk=pk)\n            article.is_published = False\n            article.published_at = None\n            await article.asave()\n\n            return {\"message\": \"Article unpublished successfully\"}\n\n        # Increment view count\n        @self.router.post(\"/{pk}/view/\")\n        async def increment_views(request, pk: int):\n            article = await Article.objects.aget(pk=pk)\n            article.views += 1\n            await article.asave(update_fields=[\"views\"])\n\n            return {\"views\": article.views}\n\n        # Get article statistics\n        @self.router.get(\"/stats/\")\n        async def stats(request):\n            from django.db.models import Count, Avg, Sum\n\n            total = await Article.objects.acount()\n            published = await Article.objects.filter(is_published=True).acount()\n\n            # Use sync_to_async for aggregate\n            from asgiref.sync import sync_to_async\n\n            avg_views = await sync_to_async(\n                lambda: Article.objects.aggregate(avg=Avg(\"views\"))\n            )()\n\n            total_views = await sync_to_async(\n                lambda: Article.objects.aggregate(total=Sum(\"views\"))\n            )()\n\n            return {\n                \"total_articles\": total,\n                \"published_articles\": published,\n                \"draft_articles\": total - published,\n                \"average_views\": avg_views[\"avg\"] or 0,\n                \"total_views\": total_views[\"total\"] or 0,\n            }\n\n        # Get popular articles\n        @self.router.get(\"/popular/\")\n        async def popular(request, limit: int = 10):\n            articles = []\n            async for article in Article.objects.filter(\n                is_published=True\n            ).order_by(\"-views\")[:limit]:\n                articles.append(article)\n\n            # Serialize articles\n            from ninja_aio.models import ModelUtil\n            util = ModelUtil(Article)\n            schema = Article.generate_read_s()\n\n            results = []\n            for article in articles:\n                data = await util.read_s(request, article, schema)\n                results.append(data)\n\n            return results\n\n\nArticleViewSet().add_views_to_route()\n</code></pre>"},{"location":"tutorial/crud/#custom-endpoint-urls","title":"Custom Endpoint URLs","text":"<p>Your custom endpoints are now available:</p> Bash<pre><code># Publish article\nPOST /api/article/1/publish/\n\n# Unpublish article\nPOST /api/article/1/unpublish/\n\n# Increment views\nPOST /api/article/1/view/\n\n# Get statistics\nGET /api/article/stats/\n\n# Get popular articles (top 10)\nGET /api/article/popular/\n\n# Get top 20\nGET /api/article/popular/?limit=20\n</code></pre>"},{"location":"tutorial/crud/#request-context","title":"Request Context","text":"<p>Access request information in your ViewSet:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    def views(self):\n        @self.router.get(\"/my-articles/\")\n        async def my_articles(request):\n            \"\"\"Get articles by current user\"\"\"\n            # Access authenticated user\n            user = request.auth\n\n            # Get user's articles\n            articles = []\n            async for article in Article.objects.filter(author=user):\n                articles.append(article)\n\n            # Serialize\n            from ninja_aio.models import ModelUtil\n            util = ModelUtil(Article)\n            schema = Article.generate_read_s()\n\n            results = []\n            for article in articles:\n                data = await util.read_s(request, article, schema)\n                results.append(data)\n\n            return results\n\n        @self.router.post(\"/\")\n        async def create_article(request, data: Article.generate_create_s()):\n            \"\"\"Override create to set author from request\"\"\"\n            # Set author from authenticated user\n            data.author = request.auth.id\n\n            # Use default create logic\n            from ninja_aio.models import ModelUtil\n            util = ModelUtil(Article)\n            schema = Article.generate_read_s()\n\n            return await util.create_s(request, data, schema)\n\n\nArticleViewSet().add_views_to_route()\n</code></pre>"},{"location":"tutorial/crud/#filtering-by-user","title":"Filtering by User","text":"<p>Automatically filter queryset based on user:</p> Python<pre><code>class Article(ModelSerializer):\n    # ... fields ...\n\n    @classmethod\n    async def queryset_request(cls, request):\n        \"\"\"Filter articles based on user\"\"\"\n        qs = cls.objects.select_related('author', 'category').prefetch_related('tags')\n\n        # If user is not authenticated, show only published\n        if not request.auth:\n            return qs.filter(is_published=True)\n\n        # If user is admin, show all\n        user = request.auth\n        if user.is_staff:\n            return qs\n\n        # Regular users see published + their own drafts\n        from django.db.models import Q\n        return qs.filter(\n            Q(is_published=True) | Q(author=user)\n        )\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    # queryset_request is automatically called for all operations\n\n\nArticleViewSet().add_views_to_route()\n</code></pre>"},{"location":"tutorial/crud/#custom-pagination","title":"Custom Pagination","text":"<p>Override default pagination:</p> Python<pre><code>from ninja.pagination import PageNumberPagination\n\n\nclass LargePagePagination(PageNumberPagination):\n    page_size = 50  # Default 50 items per page\n    max_page_size = 200  # Allow up to 200 items\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    pagination_class = LargePagePagination\n\n\nArticleViewSet().add_views_to_route()\n</code></pre> <p>Now list endpoint uses custom pagination:</p> Bash<pre><code># Default 50 items\nGET /api/article/\n\n# Custom page size\nGET /api/article/?page_size=100\n\n# Page 2\nGET /api/article/?page=2&amp;page_size=50\n</code></pre>"},{"location":"tutorial/crud/#ordering","title":"Ordering","text":"<p>Add ordering to list endpoint:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    query_params = {\n        \"is_published\": (bool, None),\n        \"ordering\": (str, \"-created_at\"),  # Default: newest first\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        # Apply published filter\n        if filters.get(\"is_published\") is not None:\n            queryset = queryset.filter(is_published=filters[\"is_published\"])\n\n        # Apply ordering\n        ordering = filters.get(\"ordering\", \"-created_at\")\n\n        # Validate ordering field\n        valid_fields = [\n            \"created_at\", \"-created_at\",\n            \"title\", \"-title\",\n            \"views\", \"-views\",\n            \"published_at\", \"-published_at\"\n        ]\n\n        if ordering in valid_fields:\n            queryset = queryset.order_by(ordering)\n\n        return queryset\n\n\nArticleViewSet().add_views_to_route()\n</code></pre> <p>Usage:</p> Bash<pre><code># Newest first (default)\nGET /api/article/\n\n# Oldest first\nGET /api/article/?ordering=created_at\n\n# By title A-Z\nGET /api/article/?ordering=title\n\n# By title Z-A\nGET /api/article/?ordering=-title\n\n# Most viewed\nGET /api/article/?ordering=-views\n\n# Recently published\nGET /api/article/?ordering=-published_at\n</code></pre>"},{"location":"tutorial/crud/#error-handling","title":"Error Handling","text":"<p>Handle errors gracefully:</p> Python<pre><code>from ninja_aio.exceptions import SerializeError, NotFoundError\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    def views(self):\n        @self.router.post(\"/{pk}/publish/\")\n        async def publish(request, pk: int):\n            try:\n                article = await Article.objects.aget(pk=pk)\n            except Article.DoesNotExist:\n                raise NotFoundError(self.model)\n\n            # Check if already published\n            if article.is_published:\n                raise SerializeError(\n                    {\"article\": \"already published\"},\n                    status_code=400\n                )\n\n            # Publish\n            article.is_published = True\n            from django.utils import timezone\n            article.published_at = timezone.now()\n            await article.asave()\n\n            return {\n                \"message\": \"Article published successfully\",\n                \"published_at\": article.published_at\n            }\n\n\nArticleViewSet().add_views_to_route()\n</code></pre>"},{"location":"tutorial/crud/#disabling-endpoints","title":"Disabling Endpoints","text":"<p>Disable specific CRUD operations:</p> Python<pre><code>class CategoryViewSet(APIViewSet):\n    model = Category\n    api = api\n\n    # Disable delete (categories can't be deleted)\n    disable_delete = True\n\n    # Disable update (categories are immutable)\n    disable_update = True\n\n\nCategoryViewSet().add_views_to_route()\n</code></pre> <p>Now only these endpoints are available:</p> <ul> <li><code>GET /api/category/</code> - List</li> <li><code>POST /api/category/</code> - Create</li> <li><code>GET /api/category/{id}</code> - Retrieve</li> </ul>"},{"location":"tutorial/crud/#response-customization","title":"Response Customization","text":"<p>Customize response format:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    def views(self):\n        @self.router.get(\"/{pk}/\")\n        async def retrieve(request, pk: int):\n            \"\"\"Custom retrieve with additional data\"\"\"\n            article = await Article.objects.select_related(\n                'author', 'category'\n            ).prefetch_related('tags').aget(pk=pk)\n\n            # Serialize article\n            from ninja_aio.models import ModelUtil\n            util = ModelUtil(Article)\n            schema = Article.generate_read_s()\n            article_data = await util.read_s(request, article, schema)\n\n            # Get related articles\n            related = []\n            async for rel_article in Article.objects.filter(\n                category=article.category,\n                is_published=True\n            ).exclude(pk=pk)[:5]:\n                rel_data = await util.read_s(request, rel_article, schema)\n                related.append(rel_data)\n\n            # Get author's other articles\n            author_articles = []\n            async for auth_article in Article.objects.filter(\n                author=article.author,\n                is_published=True\n            ).exclude(pk=pk)[:5]:\n                auth_data = await util.read_s(request, auth_article, schema)\n                author_articles.append(auth_data)\n\n            return {\n                \"article\": article_data,\n                \"related_articles\": related,\n                \"author_articles\": author_articles,\n                \"meta\": {\n                    \"total_views\": article.views,\n                    \"author_article_count\": await Article.objects.filter(\n                        author=article.author\n                    ).acount()\n                }\n            }\n\n\nArticleViewSet().add_views_to_route()\n</code></pre>"},{"location":"tutorial/crud/#complete-example","title":"Complete Example","text":"<p>Here's a complete ViewSet with all features:</p> Python<pre><code># views.py\nfrom ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom ninja.pagination import PageNumberPagination\nfrom ninja_aio.exceptions import SerializeError, NotFoundError\nfrom .models import Article, Author, Category, Tag\nfrom django.db.models import Q\n\napi = NinjaAIO(\n    title=\"Blog API\",\n    version=\"1.0.0\",\n    description=\"A complete blog API\"\n)\n\n\nclass CustomPagination(PageNumberPagination):\n    page_size = 20\n    max_page_size = 100\n\n\nclass AuthorViewSet(APIViewSet):\n    model = Author\n    api = api\n\n\nclass CategoryViewSet(APIViewSet):\n    model = Category\n    api = api\n\n\nclass TagViewSet(APIViewSet):\n    model = Tag\n    api = api\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    pagination_class = CustomPagination\n\n    query_params = {\n        \"is_published\": (bool, None),\n        \"author\": (int, None),\n        \"category\": (int, None),\n        \"tag\": (int, None),\n        \"search\": (str, None),\n        \"ordering\": (str, \"-created_at\"),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        # Published filter\n        if filters.get(\"is_published\") is not None:\n            queryset = queryset.filter(is_published=filters[\"is_published\"])\n\n        # Author filter\n        if filters.get(\"author\"):\n            queryset = queryset.filter(author_id=filters[\"author\"])\n\n        # Category filter\n        if filters.get(\"category\"):\n            queryset = queryset.filter(category_id=filters[\"category\"])\n\n        # Tag filter\n        if filters.get(\"tag\"):\n            queryset = queryset.filter(tags__id=filters[\"tag\"])\n\n        # Search\n        if filters.get(\"search\"):\n            search = filters[\"search\"]\n            queryset = queryset.filter(\n                Q(title__icontains=search) |\n                Q(content__icontains=search) |\n                Q(excerpt__icontains=search)\n            )\n\n        # Ordering\n        ordering = filters.get(\"ordering\", \"-created_at\")\n        valid_orderings = [\n            \"created_at\", \"-created_at\",\n            \"title\", \"-title\",\n            \"views\", \"-views\",\n            \"published_at\", \"-published_at\"\n        ]\n        if ordering in valid_orderings:\n            queryset = queryset.order_by(ordering)\n\n        return queryset\n\n    def views(self):\n        # Publish article\n        @self.router.post(\"/{pk}/publish/\")\n        async def publish(request, pk: int):\n            try:\n                article = await Article.objects.aget(pk=pk)\n            except Article.DoesNotExist:\n                raise NotFoundError(self.model)\n\n            if article.is_published:\n                raise SerializeError(\n                    {\"article\": \"already published\"},\n                    status_code=400\n                )\n\n            article.is_published = True\n            from django.utils import timezone\n            article.published_at = timezone.now()\n            await article.asave()\n\n            return {\"message\": \"Article published\", \"published_at\": article.published_at}\n\n        # Unpublish article\n        @self.router.post(\"/{pk}/unpublish/\")\n        async def unpublish(request, pk: int):\n            try:\n                article = await Article.objects.aget(pk=pk)\n            except Article.DoesNotExist:\n                raise NotFoundError(self.model)\n\n            article.is_published = False\n            article.published_at = None\n            await article.asave()\n\n            return {\"message\": \"Article unpublished\"}\n\n        # Increment views\n        @self.router.post(\"/{pk}/view/\")\n        async def view(request, pk: int):\n            try:\n                article = await Article.objects.aget(pk=pk)\n            except Article.DoesNotExist:\n                raise NotFoundError(self.model)\n\n            article.views += 1\n            await article.asave(update_fields=[\"views\"])\n\n            return {\"views\": article.views}\n\n        # Statistics\n        @self.router.get(\"/stats/\")\n        async def stats(request):\n            from django.db.models import Count, Avg, Sum\n            from asgiref.sync import sync_to_async\n\n            total = await Article.objects.acount()\n            published = await Article.objects.filter(is_published=True).acount()\n\n            avg_views = await sync_to_async(\n                lambda: Article.objects.aggregate(avg=Avg(\"views\"))\n            )()\n\n            total_views = await sync_to_async(\n                lambda: Article.objects.aggregate(total=Sum(\"views\"))\n            )()\n\n            return {\n                \"total_articles\": total,\n                \"published\": published,\n                \"drafts\": total - published,\n                \"avg_views\": avg_views[\"avg\"] or 0,\n                \"total_views\": total_views[\"total\"] or 0,\n            }\n\n        # Popular articles\n        @self.router.get(\"/popular/\")\n        async def popular(request, limit: int = 10):\n            articles = []\n            async for article in Article.objects.filter(\n                is_published=True\n            ).order_by(\"-views\")[:limit]:\n                articles.append(article)\n\n            from ninja_aio.models import ModelUtil\n            util = ModelUtil(Article)\n            schema = Article.generate_read_s()\n\n            results = []\n            for article in articles:\n                data = await util.read_s(request, article, schema)\n                results.append(data)\n\n            return results\n\n\n# Register ViewSets\nAuthorViewSet().add_views_to_route()\nCategoryViewSet().add_views_to_route()\nTagViewSet().add_views_to_route()\nArticleViewSet().add_views_to_route()\n</code></pre>"},{"location":"tutorial/crud/#testing-your-api","title":"Testing Your API","text":"<p>Test your endpoints using curl, httpie, or the Swagger UI:</p> Bash<pre><code># List articles\ncurl http://localhost:8000/api/article/\n\n# Create article\ncurl -X POST http://localhost:8000/api/article/ \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"title\": \"My Article\",\n    \"content\": \"Content here...\",\n    \"author\": 1,\n    \"category\": 2\n  }'\n\n# Get article\ncurl http://localhost:8000/api/article/1\n\n# Update article\ncurl -X PATCH http://localhost:8000/api/article/1/ \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"title\": \"Updated Title\"}'\n\n# Delete article\ncurl -X DELETE http://localhost:8000/api/article/1/\n\n# Custom endpoints\ncurl -X POST http://localhost:8000/api/article/1/publish/\ncurl http://localhost:8000/api/article/stats/\ncurl http://localhost:8000/api/article/popular/?limit=5\n</code></pre>"},{"location":"tutorial/crud/#next-steps","title":"Next Steps","text":"<p>Now that you have CRUD operations set up, let's add authentication in Step 3: Add Authentication.</p> <p>!!! success \"What You've Learned\" - \u2705 Creating ViewSets for CRUD operations - \u2705 Understanding auto-generated endpoints - \u2705 Adding query parameters and filtering - \u2705 Creating custom endpoints - \u2705 Working with pagination - \u2705 Handling errors properly - \u2705 Customizing responses</p>"},{"location":"tutorial/crud/#see-also","title":"See Also","text":"<ul> <li>APIViewSet API Reference - Complete API documentation</li> <li>Pagination - Advanced pagination options</li> <li>ModelUtil - Working with models</li> </ul>"},{"location":"tutorial/filtering/","title":"Step 4: Add Filtering &amp; Pagination","text":"<p>In this final step, you'll learn how to implement advanced filtering, searching, and pagination for your API endpoints.</p>"},{"location":"tutorial/filtering/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Query parameter filtering</li> <li>Full-text search</li> <li>Ordering and sorting</li> <li>Custom pagination</li> <li>Filter combinations</li> <li>Performance optimization</li> </ul>"},{"location":"tutorial/filtering/#prerequisites","title":"Prerequisites","text":"<p>Make sure you've completed:</p> <ul> <li>Step 1: Define Your Model</li> <li>Step 2: Create CRUD Views</li> <li>Step 3: Add Authentication</li> </ul>"},{"location":"tutorial/filtering/#basic-filtering","title":"Basic Filtering","text":""},{"location":"tutorial/filtering/#simple-field-filters","title":"Simple Field Filters","text":"Python<pre><code># views.py\nfrom ninja_aio.views import APIViewSet\nfrom .models import Article\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"is_published\": (bool, None),\n        \"author\": (int, None),\n        \"category\": (int, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        # Filter by published status\n        if filters.get(\"is_published\") is not None:\n            queryset = queryset.filter(is_published=filters[\"is_published\"])\n\n        # Filter by author ID\n        if filters.get(\"author\"):\n            queryset = queryset.filter(author_id=filters[\"author\"])\n\n        # Filter by category ID\n        if filters.get(\"category\"):\n            queryset = queryset.filter(category_id=filters[\"category\"])\n\n        return queryset\n\n\nArticleViewSet().add_views_to_route()\n</code></pre> <p>Usage:</p> Bash<pre><code># Get published articles\nGET /api/article/?is_published=true\n\n# Get articles by author\nGET /api/article/?author=5\n\n# Get articles in category\nGET /api/article/?category=3\n\n# Combine filters\nGET /api/article/?is_published=true&amp;author=5&amp;category=3\n</code></pre>"},{"location":"tutorial/filtering/#date-range-filters","title":"Date Range Filters","text":"Python<pre><code>from datetime import datetime\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"created_after\": (str, None),   # ISO date string\n        \"created_before\": (str, None),\n        \"published_after\": (str, None),\n        \"published_before\": (str, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        # Filter by creation date\n        if filters.get(\"created_after\"):\n            date = datetime.fromisoformat(filters[\"created_after\"])\n            queryset = queryset.filter(created_at__gte=date)\n\n        if filters.get(\"created_before\"):\n            date = datetime.fromisoformat(filters[\"created_before\"])\n            queryset = queryset.filter(created_at__lte=date)\n\n        # Filter by publication date\n        if filters.get(\"published_after\"):\n            date = datetime.fromisoformat(filters[\"published_after\"])\n            queryset = queryset.filter(published_at__gte=date)\n\n        if filters.get(\"published_before\"):\n            date = datetime.fromisoformat(filters[\"published_before\"])\n            queryset = queryset.filter(published_at__lte=date)\n\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># Articles created after a date\nGET /api/article/?created_after=2024-01-01\n\n# Articles published in a date range\nGET /api/article/?published_after=2024-01-01&amp;published_before=2024-01-31\n\n# Articles from last 7 days\nGET /api/article/?created_after=2024-01-15\n</code></pre>"},{"location":"tutorial/filtering/#numeric-range-filters","title":"Numeric Range Filters","text":"Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"min_views\": (int, None),\n        \"max_views\": (int, None),\n        \"min_rating\": (float, None),\n        \"max_rating\": (float, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        # Filter by views\n        if filters.get(\"min_views\"):\n            queryset = queryset.filter(views__gte=filters[\"min_views\"])\n\n        if filters.get(\"max_views\"):\n            queryset = queryset.filter(views__lte=filters[\"max_views\"])\n\n        # Filter by rating\n        if filters.get(\"min_rating\"):\n            queryset = queryset.filter(rating__gte=filters[\"min_rating\"])\n\n        if filters.get(\"max_rating\"):\n            queryset = queryset.filter(rating__lte=filters[\"max_rating\"])\n\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># Popular articles (1000+ views)\nGET /api/article/?min_views=1000\n\n# Highly rated articles (4.5+)\nGET /api/article/?min_rating=4.5\n\n# Articles with 100-1000 views\nGET /api/article/?min_views=100&amp;max_views=1000\n</code></pre>"},{"location":"tutorial/filtering/#search-functionality","title":"Search Functionality","text":""},{"location":"tutorial/filtering/#simple-text-search","title":"Simple Text Search","text":"Python<pre><code>from django.db.models import Q\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"search\": (str, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        if filters.get(\"search\"):\n            search_term = filters[\"search\"]\n            queryset = queryset.filter(\n                Q(title__icontains=search_term) |\n                Q(content__icontains=search_term) |\n                Q(excerpt__icontains=search_term)\n            )\n\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># Search in title and content\nGET /api/article/?search=django\n\n# Search with other filters\nGET /api/article/?search=tutorial&amp;is_published=true\n</code></pre>"},{"location":"tutorial/filtering/#full-text-search-postgresql","title":"Full-Text Search (PostgreSQL)","text":"<p>For better performance with large datasets:</p> Python<pre><code>from django.contrib.postgres.search import SearchVector, SearchQuery, SearchRank\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"search\": (str, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        if filters.get(\"search\"):\n            search_term = filters[\"search\"]\n\n            # Create search vector\n            vector = SearchVector('title', weight='A') + \\\n                     SearchVector('content', weight='B')\n\n            query = SearchQuery(search_term)\n\n            # Filter and rank by relevance\n            queryset = queryset.annotate(\n                rank=SearchRank(vector, query)\n            ).filter(\n                rank__gte=0.1\n            ).order_by('-rank')\n\n        return queryset\n</code></pre>"},{"location":"tutorial/filtering/#search-with-highlights","title":"Search with Highlights","text":"Python<pre><code>from django.contrib.postgres.search import SearchVector, SearchQuery, SearchHeadline\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"search\": (str, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        if filters.get(\"search\"):\n            search_term = filters[\"search\"]\n            query = SearchQuery(search_term)\n\n            # Add highlighted excerpts\n            queryset = queryset.annotate(\n                headline=SearchHeadline(\n                    'content',\n                    query,\n                    start_sel='&lt;mark&gt;',\n                    stop_sel='&lt;/mark&gt;',\n                    max_words=50,\n                )\n            )\n\n        return queryset\n</code></pre>"},{"location":"tutorial/filtering/#ordering","title":"Ordering","text":""},{"location":"tutorial/filtering/#basic-ordering","title":"Basic Ordering","text":"Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"ordering\": (str, \"-created_at\"),  # Default: newest first\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        ordering = filters.get(\"ordering\", \"-created_at\")\n\n        # Whitelist allowed ordering fields\n        valid_orderings = [\n            \"created_at\", \"-created_at\",\n            \"updated_at\", \"-updated_at\",\n            \"title\", \"-title\",\n            \"views\", \"-views\",\n            \"rating\", \"-rating\",\n            \"published_at\", \"-published_at\",\n        ]\n\n        if ordering in valid_orderings:\n            queryset = queryset.order_by(ordering)\n\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># Newest first (default)\nGET /api/article/?ordering=-created_at\n\n# Oldest first\nGET /api/article/?ordering=created_at\n\n# By title A-Z\nGET /api/article/?ordering=title\n\n# Most viewed\nGET /api/article/?ordering=-views\n\n# Highest rated\nGET /api/article/?ordering=-rating\n</code></pre>"},{"location":"tutorial/filtering/#multiple-field-ordering","title":"Multiple Field Ordering","text":"Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"ordering\": (str, \"-created_at,title\"),  # Multiple fields\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        ordering = filters.get(\"ordering\", \"-created_at,title\")\n\n        # Parse ordering string\n        order_fields = ordering.split(',')\n\n        # Validate each field\n        valid_fields = {\n            \"created_at\", \"-created_at\",\n            \"title\", \"-title\",\n            \"views\", \"-views\",\n        }\n\n        validated_fields = [\n            field for field in order_fields\n            if field in valid_fields\n        ]\n\n        if validated_fields:\n            queryset = queryset.order_by(*validated_fields)\n\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># Order by date, then title\nGET /api/article/?ordering=-created_at,title\n\n# Order by views, then rating\nGET /api/article/?ordering=-views,-rating\n</code></pre>"},{"location":"tutorial/filtering/#advanced-filtering","title":"Advanced Filtering","text":""},{"location":"tutorial/filtering/#related-field-filters","title":"Related Field Filters","text":"Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"author_username\": (str, None),\n        \"category_slug\": (str, None),\n        \"tag_name\": (str, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        # Filter by author username\n        if filters.get(\"author_username\"):\n            queryset = queryset.filter(\n                author__username__iexact=filters[\"author_username\"]\n            )\n\n        # Filter by category slug\n        if filters.get(\"category_slug\"):\n            queryset = queryset.filter(\n                category__slug=filters[\"category_slug\"]\n            )\n\n        # Filter by tag name\n        if filters.get(\"tag_name\"):\n            queryset = queryset.filter(\n                tags__name__iexact=filters[\"tag_name\"]\n            )\n\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># By author username\nGET /api/article/?author_username=johndoe\n\n# By category slug\nGET /api/article/?category_slug=tutorials\n\n# By tag name\nGET /api/article/?tag_name=python\n</code></pre>"},{"location":"tutorial/filtering/#multiple-tags-filter","title":"Multiple Tags Filter","text":"Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"tags\": (str, None),  # Comma-separated tag IDs or names\n        \"tags_mode\": (str, \"any\"),  # \"any\" or \"all\"\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        if filters.get(\"tags\"):\n            tag_list = filters[\"tags\"].split(',')\n            mode = filters.get(\"tags_mode\", \"any\")\n\n            # Check if tags are IDs or names\n            if tag_list[0].isdigit():\n                # Filter by tag IDs\n                tag_ids = [int(t) for t in tag_list]\n\n                if mode == \"all\":\n                    # Must have ALL tags\n                    for tag_id in tag_ids:\n                        queryset = queryset.filter(tags__id=tag_id)\n                else:\n                    # Must have ANY tag\n                    queryset = queryset.filter(tags__id__in=tag_ids).distinct()\n            else:\n                # Filter by tag names\n                if mode == \"all\":\n                    for tag_name in tag_list:\n                        queryset = queryset.filter(tags__name__iexact=tag_name)\n                else:\n                    queryset = queryset.filter(\n                        tags__name__in=tag_list\n                    ).distinct()\n\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># Articles with ANY of these tags\nGET /api/article/?tags=1,2,3\n\n# Articles with ALL of these tags\nGET /api/article/?tags=python,django,tutorial&amp;tags_mode=all\n\n# Using tag IDs\nGET /api/article/?tags=1,2,3&amp;tags_mode=all\n</code></pre>"},{"location":"tutorial/filtering/#exclude-filters","title":"Exclude Filters","text":"Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"exclude_author\": (int, None),\n        \"exclude_category\": (int, None),\n        \"exclude_ids\": (str, None),  # Comma-separated IDs\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        # Exclude specific author\n        if filters.get(\"exclude_author\"):\n            queryset = queryset.exclude(author_id=filters[\"exclude_author\"])\n\n        # Exclude specific category\n        if filters.get(\"exclude_category\"):\n            queryset = queryset.exclude(category_id=filters[\"exclude_category\"])\n\n        # Exclude specific article IDs\n        if filters.get(\"exclude_ids\"):\n            ids = [int(id) for id in filters[\"exclude_ids\"].split(',')]\n            queryset = queryset.exclude(id__in=ids)\n\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># Exclude articles by specific author\nGET /api/article/?exclude_author=5\n\n# Exclude specific articles\nGET /api/article/?exclude_ids=1,2,3\n</code></pre>"},{"location":"tutorial/filtering/#pagination","title":"Pagination","text":""},{"location":"tutorial/filtering/#default-pagination","title":"Default Pagination","text":"<p>Django Ninja Aio CRUD uses page-number pagination by default:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    # Uses default PageNumberPagination\n</code></pre> <p>Usage:</p> Bash<pre><code># First page (10 items)\nGET /api/article/?page=1\n\n# Custom page size\nGET /api/article/?page=1&amp;page_size=20\n\n# Second page\nGET /api/article/?page=2&amp;page_size=20\n</code></pre> <p>Response:</p> JSON<pre><code>{\n  \"count\": 150,\n  \"next\": 3,\n  \"previous\": 1,\n  \"results\": [...]\n}\n</code></pre>"},{"location":"tutorial/filtering/#custom-pagination","title":"Custom Pagination","text":"Python<pre><code>from ninja.pagination import PageNumberPagination\n\n\nclass CustomPagination(PageNumberPagination):\n    page_size = 25  # Default items per page\n    max_page_size = 100  # Maximum allowed\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    pagination_class = CustomPagination\n</code></pre>"},{"location":"tutorial/filtering/#disable-pagination","title":"Disable Pagination","text":"Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    pagination_class = None  # Return all results\n\n\n# Or conditionally\nclass ConditionalPagination(PageNumberPagination):\n    async def apaginate_queryset(self, queryset, pagination, request=None, **params):\n        # Disable if 'all' parameter present\n        if params.get('all'):\n            items = []\n            async for item in queryset:\n                items.append(item)\n            return {\"results\": items}\n\n        return await super().apaginate_queryset(queryset, pagination, request, **params)\n</code></pre>"},{"location":"tutorial/filtering/#filter-presets","title":"Filter Presets","text":"<p>Create reusable filter combinations:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"preset\": (str, None),\n        # ... other filters\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        preset = filters.get(\"preset\")\n\n        # Apply preset filters\n        if preset == \"trending\":\n            # Popular recent articles\n            from django.utils import timezone\n            from datetime import timedelta\n\n            last_week = timezone.now() - timedelta(days=7)\n            queryset = queryset.filter(\n                created_at__gte=last_week,\n                is_published=True\n            ).order_by('-views', '-rating')\n\n        elif preset == \"featured\":\n            # Featured articles\n            queryset = queryset.filter(\n                is_published=True,\n                is_featured=True\n            ).order_by('-featured_at')\n\n        elif preset == \"recent\":\n            # Recently published\n            queryset = queryset.filter(\n                is_published=True\n            ).order_by('-published_at')[:20]\n\n        elif preset == \"popular\":\n            # All-time most viewed\n            queryset = queryset.filter(\n                is_published=True\n            ).order_by('-views')[:50]\n\n        # Apply other filters\n        # ...\n\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># Get trending articles\nGET /api/article/?preset=trending\n\n# Get featured articles\nGET /api/article/?preset=featured\n\n# Combine with other filters\nGET /api/article/?preset=recent&amp;category=1\n</code></pre>"},{"location":"tutorial/filtering/#performance-optimization","title":"Performance Optimization","text":""},{"location":"tutorial/filtering/#select-related","title":"Select Related","text":"<p>Optimize queries with foreign keys:</p> Python<pre><code>class Article(ModelSerializer):\n    # ... fields ...\n\n    @classmethod\n    async def queryset_request(cls, request):\n        # Always include related objects\n        return cls.objects.select_related(\n            'author',\n            'category'\n        ).prefetch_related(\n            'tags',\n            'comments'\n        )\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    # Queries are now optimized automatically\n</code></pre>"},{"location":"tutorial/filtering/#index-database-fields","title":"Index Database Fields","text":"Python<pre><code># models.py\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200, db_index=True)\n    slug = models.SlugField(unique=True, db_index=True)\n    is_published = models.BooleanField(default=False, db_index=True)\n    created_at = models.DateTimeField(auto_now_add=True, db_index=True)\n\n    class Meta:\n        indexes = [\n            models.Index(fields=['-created_at']),\n            models.Index(fields=['is_published', '-created_at']),\n            models.Index(fields=['author', '-created_at']),\n            models.Index(fields=['category', '-created_at']),\n        ]\n</code></pre>"},{"location":"tutorial/filtering/#limit-query-results","title":"Limit Query Results","text":"Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    async def query_params_handler(self, queryset, filters):\n        # Apply filters\n        # ...\n\n        # Limit results for expensive queries\n        if filters.get(\"search\"):\n            queryset = queryset[:1000]  # Max 1000 results for search\n\n        return queryset\n</code></pre>"},{"location":"tutorial/filtering/#complete-example","title":"Complete Example","text":"<p>Here's a comprehensive filtering implementation:</p> Python<pre><code># views.py\nfrom ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom ninja.pagination import PageNumberPagination\nfrom django.db.models import Q\nfrom datetime import datetime\nfrom .models import Article\n\napi = NinjaAIO(title=\"Blog API\", version=\"1.0.0\")\n\n\nclass ArticlePagination(PageNumberPagination):\n    page_size = 20\n    max_page_size = 100\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    pagination_class = ArticlePagination\n\n    query_params = {\n        # Basic filters\n        \"is_published\": (bool, None),\n        \"author\": (int, None),\n        \"category\": (int, None),\n\n        # Text search\n        \"search\": (str, None),\n\n        # Date range\n        \"created_after\": (str, None),\n        \"created_before\": (str, None),\n\n        # Numeric range\n        \"min_views\": (int, None),\n        \"max_views\": (int, None),\n\n        # Related filters\n        \"author_username\": (str, None),\n        \"category_slug\": (str, None),\n        \"tags\": (str, None),\n        \"tags_mode\": (str, \"any\"),\n\n        # Ordering\n        \"ordering\": (str, \"-created_at\"),\n\n        # Presets\n        \"preset\": (str, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        # Apply preset first\n        preset = filters.get(\"preset\")\n        if preset == \"trending\":\n            from django.utils import timezone\n            from datetime import timedelta\n            last_week = timezone.now() - timedelta(days=7)\n            queryset = queryset.filter(\n                created_at__gte=last_week,\n                is_published=True\n            )\n        elif preset == \"popular\":\n            queryset = queryset.filter(is_published=True)\n\n        # Published status\n        if filters.get(\"is_published\") is not None:\n            queryset = queryset.filter(is_published=filters[\"is_published\"])\n\n        # Author filter\n        if filters.get(\"author\"):\n            queryset = queryset.filter(author_id=filters[\"author\"])\n        elif filters.get(\"author_username\"):\n            queryset = queryset.filter(\n                author__username__iexact=filters[\"author_username\"]\n            )\n\n        # Category filter\n        if filters.get(\"category\"):\n            queryset = queryset.filter(category_id=filters[\"category\"])\n        elif filters.get(\"category_slug\"):\n            queryset = queryset.filter(category__slug=filters[\"category_slug\"])\n\n        # Tags filter\n        if filters.get(\"tags\"):\n            tag_list = filters[\"tags\"].split(',')\n            mode = filters.get(\"tags_mode\", \"any\")\n\n            if mode == \"all\":\n                for tag in tag_list:\n                    if tag.isdigit():\n                        queryset = queryset.filter(tags__id=int(tag))\n                    else:\n                        queryset = queryset.filter(tags__name__iexact=tag)\n            else:\n                if tag_list[0].isdigit():\n                    tag_ids = [int(t) for t in tag_list]\n                    queryset = queryset.filter(tags__id__in=tag_ids).distinct()\n                else:\n                    queryset = queryset.filter(tags__name__in=tag_list).distinct()\n\n        # Search\n        if filters.get(\"search\"):\n            search_term = filters[\"search\"]\n            queryset = queryset.filter(\n                Q(title__icontains=search_term) |\n                Q(content__icontains=search_term)\n            )\n\n        # Date range\n        if filters.get(\"created_after\"):\n            date = datetime.fromisoformat(filters[\"created_after\"])\n            queryset = queryset.filter(created_at__gte=date)\n\n        if filters.get(\"created_before\"):\n            date = datetime.fromisoformat(filters[\"created_before\"])\n            queryset = queryset.filter(created_at__lte=date)\n\n        # Views range\n        if filters.get(\"min_views\"):\n            queryset = queryset.filter(views__gte=filters[\"min_views\"])\n\n        if filters.get(\"max_views\"):\n            queryset = queryset.filter(views__lte=filters[\"max_views\"])\n\n        # Ordering\n        ordering = filters.get(\"ordering\", \"-created_at\")\n        valid_orderings = [\n            \"created_at\", \"-created_at\",\n            \"title\", \"-title\",\n            \"views\", \"-views\",\n            \"published_at\", \"-published_at\",\n        ]\n\n        if ordering in valid_orderings:\n            queryset = queryset.order_by(ordering)\n        elif preset == \"trending\":\n            queryset = queryset.order_by('-views', '-rating')\n        elif preset == \"popular\":\n            queryset = queryset.order_by('-views')\n\n        return queryset\n\n\nArticleViewSet().add_views_to_route()\n</code></pre>"},{"location":"tutorial/filtering/#testing-filters","title":"Testing Filters","text":"Bash<pre><code># Basic filtering\ncurl \"http://localhost:8000/api/article/?is_published=true\"\n\n# Search\ncurl \"http://localhost:8000/api/article/?search=django\"\n\n# Date range\ncurl \"http://localhost:8000/api/article/?created_after=2024-01-01&amp;created_before=2024-01-31\"\n\n# Multiple filters\ncurl \"http://localhost:8000/api/article/?is_published=true&amp;category=1&amp;min_views=100&amp;ordering=-views\"\n\n# Tags\ncurl \"http://localhost:8000/api/article/?tags=python,django&amp;tags_mode=all\"\n\n# Presets\ncurl \"http://localhost:8000/api/article/?preset=trending\"\n\n# Pagination\ncurl \"http://localhost:8000/api/article/?page=2&amp;page_size=50\"\n\n# Combined\ncurl \"http://localhost:8000/api/article/?search=tutorial&amp;category=1&amp;is_published=true&amp;min_views=1000&amp;ordering=-rating&amp;page=1&amp;page_size=20\"\n</code></pre>"},{"location":"tutorial/filtering/#congratulations","title":"Congratulations! \ud83c\udf89","text":"<p>You've completed all tutorial steps and built a complete, production-ready API with:</p> <ul> <li>\u2705 Models with automatic schema generation</li> <li>\u2705 Full CRUD operations</li> <li>\u2705 JWT authentication</li> <li>\u2705 Custom schemas and validation</li> <li>\u2705 Advanced filtering and search</li> <li>\u2705 Pagination</li> <li>\u2705 Performance optimization</li> </ul>"},{"location":"tutorial/filtering/#next-steps","title":"Next Steps","text":"<p>Explore advanced topics:</p> <ul> <li>API Reference - Complete API documentation</li> <li>Authentication - Advanced auth patterns</li> <li>Pagination - Custom pagination strategies</li> </ul>"},{"location":"tutorial/filtering/#see-also","title":"See Also","text":"<ul> <li>Pagination API Reference - Pagination classes</li> <li>ModelUtil - Query optimization</li> </ul>"},{"location":"tutorial/model/","title":"Step 1: Define Your Model","text":"<p>In this first step, you'll learn how to define Django models using <code>ModelSerializer</code>, which allows you to declare schemas directly on your models.</p>"},{"location":"tutorial/model/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>How to create a model with <code>ModelSerializer</code></li> <li>Defining serialization schemas (Create, Read, Update)</li> <li>Working with relationships</li> <li>Adding custom fields</li> <li>Implementing lifecycle hooks</li> </ul>"},{"location":"tutorial/model/#prerequisites","title":"Prerequisites","text":"<p>Make sure you have:</p> <ul> <li>Django 4.1+ installed</li> <li><code>django-ninja-aio-crud</code> installed</li> <li>A Django project set up</li> </ul>"},{"location":"tutorial/model/#basic-model-definition","title":"Basic Model Definition","text":"<p>Let's create a simple blog article model:</p> Python<pre><code># models.py\nfrom django.db import models\nfrom ninja_aio.models import ModelSerializer\n\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    is_published = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    def __str__(self):\n        return self.title\n</code></pre> <p>Why ModelSerializer?</p> <p><code>ModelSerializer</code> is a powerful mixin that combines Django's <code>Model</code> with automatic schema generation capabilities. Instead of creating separate serializer classes, you define everything on the model itself.</p>"},{"location":"tutorial/model/#adding-serializer-classes","title":"Adding Serializer Classes","text":"<p>Now let's add serialization schemas to control which fields are exposed in different operations:</p>"},{"location":"tutorial/model/#readserializer","title":"ReadSerializer","text":"<p>Defines which fields appear in API responses:</p> Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    is_published = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"content\", \"is_published\", \"created_at\", \"updated_at\"]\n\n    def __str__(self):\n        return self.title\n</code></pre> <p>Result: When you retrieve an article, the API will return:</p> JSON<pre><code>{\n  \"id\": 1,\n  \"title\": \"Getting Started with Django\",\n  \"content\": \"In this article...\",\n  \"is_published\": true,\n  \"created_at\": \"2024-01-15T10:30:00Z\",\n  \"updated_at\": \"2024-01-15T11:00:00Z\"\n}\n</code></pre>"},{"location":"tutorial/model/#createserializer","title":"CreateSerializer","text":"<p>Defines which fields are required/allowed when creating:</p> Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    is_published = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"content\", \"is_published\", \"created_at\", \"updated_at\"]\n\n    class CreateSerializer:\n        fields = [\"title\", \"content\"]\n        optionals = [\n            (\"is_published\", bool),\n        ]\n\n    def __str__(self):\n        return self.title\n</code></pre> <p>Usage: When creating an article:</p> JSON<pre><code>// Required fields\n{\n  \"title\": \"My New Article\",\n  \"content\": \"Article content here...\"\n}\n\n// With optional field\n{\n  \"title\": \"My New Article\",\n  \"content\": \"Article content here...\",\n  \"is_published\": true\n}\n</code></pre> <p>Auto-generated Fields</p> <p>Fields like <code>id</code>, <code>created_at</code>, and <code>updated_at</code> are automatically handled by Django and shouldn't be in <code>CreateSerializer.fields</code>.</p>"},{"location":"tutorial/model/#updateserializer","title":"UpdateSerializer","text":"<p>Defines which fields can be updated (usually all optional for PATCH):</p> Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    is_published = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"content\", \"is_published\", \"created_at\", \"updated_at\"]\n\n    class CreateSerializer:\n        fields = [\"title\", \"content\"]\n        optionals = [(\"is_published\", bool)]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"title\", str),\n            (\"content\", str),\n            (\"is_published\", bool),\n        ]\n        excludes = [\"created_at\", \"updated_at\"]\n\n    def __str__(self):\n        return self.title\n</code></pre> <p>Usage: Partial update (PATCH):</p> JSON<pre><code>// Update only title\n{\n  \"title\": \"Updated Title\"\n}\n\n// Update multiple fields\n{\n  \"title\": \"Updated Title\",\n  \"is_published\": true\n}\n</code></pre>"},{"location":"tutorial/model/#working-with-relationships","title":"Working with Relationships","text":""},{"location":"tutorial/model/#foreignkey-relationships","title":"ForeignKey Relationships","text":"<p>Let's add an author to our articles:</p> Python<pre><code>class Author(ModelSerializer):\n    name = models.CharField(max_length=200)\n    email = models.EmailField(unique=True)\n    bio = models.TextField(blank=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"email\", \"bio\"]\n\n    class CreateSerializer:\n        fields = [\"name\", \"email\"]\n        optionals = [(\"bio\", str)]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"name\", str),\n            (\"email\", str),\n            (\"bio\", str),\n        ]\n\n    def __str__(self):\n        return self.name\n\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"articles\")\n    is_published = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"content\", \"author\", \"is_published\", \"created_at\"]\n\n    class CreateSerializer:\n        fields = [\"title\", \"content\", \"author\"]\n        optionals = [(\"is_published\", bool)]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"title\", str),\n            (\"content\", str),\n            (\"is_published\", bool),\n        ]\n        excludes = [\"author\"]  # Can't change author after creation\n\n    def __str__(self):\n        return self.title\n</code></pre> <p>Creating an article with author:</p> JSON<pre><code>{\n  \"title\": \"My Article\",\n  \"content\": \"Content here...\",\n  \"author\": 5 // Author ID\n}\n</code></pre> <p>Response includes nested author data:</p> JSON<pre><code>{\n  \"id\": 1,\n  \"title\": \"My Article\",\n  \"content\": \"Content here...\",\n  \"author\": {\n    \"id\": 5,\n    \"name\": \"John Doe\",\n    \"email\": \"john@example.com\",\n    \"bio\": \"Software developer\"\n  },\n  \"is_published\": false,\n  \"created_at\": \"2024-01-15T10:30:00Z\"\n}\n</code></pre> <p>Automatic Nested Serialization</p> <p>When <code>Author</code> is also a <code>ModelSerializer</code>, Django Ninja Aio CRUD automatically serializes it in the response!</p>"},{"location":"tutorial/model/#manytomany-relationships","title":"ManyToMany Relationships","text":"<p>Let's add tags to articles:</p> Python<pre><code>class Tag(ModelSerializer):\n    name = models.CharField(max_length=50, unique=True)\n    slug = models.SlugField(unique=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"slug\"]\n\n    class CreateSerializer:\n        fields = [\"name\", \"slug\"]\n\n    def __str__(self):\n        return self.name\n\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"articles\")\n    tags = models.ManyToManyField(Tag, related_name=\"articles\", blank=True)\n    is_published = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"content\", \"author\", \"tags\", \"is_published\", \"created_at\"]\n\n    class CreateSerializer:\n        fields = [\"title\", \"content\", \"author\"]\n        optionals = [\n            (\"is_published\", bool),\n            (\"tags\", list[int]),  # List of tag IDs\n        ]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"title\", str),\n            (\"content\", str),\n            (\"is_published\", bool),\n            (\"tags\", list[int]),\n        ]\n\n    def __str__(self):\n        return self.title\n</code></pre> <p>Creating with tags:</p> JSON<pre><code>{\n  \"title\": \"My Article\",\n  \"content\": \"Content...\",\n  \"author\": 5,\n  \"tags\": [1, 2, 3] // Tag IDs\n}\n</code></pre> <p>Response:</p> JSON<pre><code>{\n  \"id\": 1,\n  \"title\": \"My Article\",\n  \"content\": \"Content...\",\n  \"author\": {...},\n  \"tags\": [\n    {\"id\": 1, \"name\": \"python\", \"slug\": \"python\"},\n    {\"id\": 2, \"name\": \"django\", \"slug\": \"django\"},\n    {\"id\": 3, \"name\": \"tutorial\", \"slug\": \"tutorial\"}\n  ],\n  \"is_published\": false,\n  \"created_at\": \"2024-01-15T10:30:00Z\"\n}\n</code></pre>"},{"location":"tutorial/model/#adding-custom-fields","title":"Adding Custom Fields","text":"<p>Sometimes you need computed or synthetic fields in your API responses:</p> Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"articles\")\n    views = models.IntegerField(default=0)\n    is_published = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"content\", \"author\", \"views\", \"is_published\", \"created_at\"]\n        customs = [\n            (\"word_count\", int, lambda obj: len(obj.content.split())),\n            (\"reading_time\", int, lambda obj: len(obj.content.split()) // 200),  # Assume 200 words/min\n            (\"author_name\", str, lambda obj: obj.author.name),\n        ]\n\n    class CreateSerializer:\n        fields = [\"title\", \"content\", \"author\"]\n        customs = [\n            (\"notify_subscribers\", bool, True),  # Custom action flag\n            (\"schedule_publish\", str, None),  # ISO datetime string\n        ]\n\n    def __str__(self):\n        return self.title\n</code></pre> <p>Response with custom fields:</p> JSON<pre><code>{\n  \"id\": 1,\n  \"title\": \"My Article\",\n  \"content\": \"...\",\n  \"author\": {...},\n  \"views\": 150,\n  \"is_published\": true,\n  \"created_at\": \"2024-01-15T10:30:00Z\",\n  \"word_count\": 842,\n  \"reading_time\": 4,\n  \"author_name\": \"John Doe\"\n}\n</code></pre> <p>Custom Fields in CreateSerializer</p> <p>Custom fields in <code>CreateSerializer</code> are used for instructions (like flags or metadata), not stored in the database. They're passed to <code>custom_actions()</code> hook.</p>"},{"location":"tutorial/model/#query-optimizations-queryset","title":"Query optimizations (QuerySet)","text":"<p>Configure select_related/prefetch_related for read and queryset_request hooks:</p> Python<pre><code>from ninja_aio.schemas.helpers import ModelQuerySetSchema, ModelQuerySetExtraSchema\n\nclass Article(ModelSerializer):\n    # ...existing fields...\n\n    class QuerySet:\n        read = ModelQuerySetSchema(\n            select_related=[\"author\", \"category\"],\n            prefetch_related=[\"tags\"],\n        )\n        queryset_request = ModelQuerySetSchema(\n            select_related=[],\n            prefetch_related=[\"tags\"],\n        )\n        extras = [\n            ModelQuerySetExtraSchema(\n                scope=\"cards\",\n                select_related=[\"author\"],\n                prefetch_related=[],\n            )\n        ]\n</code></pre> <p>Use the QueryUtil for custom scopes:</p> Python<pre><code>qs = Article.query_util.apply_queryset_optimizations(\n    Article.objects.all(),\n    Article.query_util.SCOPES.cards,  # from extras\n)\n</code></pre>"},{"location":"tutorial/model/#fetch-and-serialize-with-modelutil","title":"Fetch and serialize with ModelUtil","text":"Python<pre><code>from ninja_aio.models import ModelUtil\nfrom ninja_aio.schemas.helpers import ObjectsQuerySchema, ObjectQuerySchema\n\nutil = ModelUtil(Article)\n\n# List published with default read optimizations\nitems = await util.list_read_s(\n    Article.generate_read_s(),\n    request,\n    query_data=ObjectsQuerySchema(filters={\"is_published\": True}),\n    is_for_read=True,\n)\n\n# Retrieve by slug with getters\nitem = await util.read_s(\n    Article.generate_read_s(),\n    request,\n    query_data=ObjectQuerySchema(getters={\"slug\": \"my-article\"}),\n    is_for_read=True,\n)\n</code></pre>"},{"location":"tutorial/model/#lifecycle-hooks","title":"Lifecycle Hooks","text":"<p>Add behavior at key points in the model lifecycle:</p>"},{"location":"tutorial/model/#sync-hooks","title":"Sync Hooks","text":"Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    slug = models.SlugField(unique=True, blank=True)\n    is_published = models.BooleanField(default=False)\n    published_at = models.DateTimeField(null=True, blank=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"slug\", \"is_published\", \"published_at\"]\n\n    def before_save(self):\n        \"\"\"Called before every save (create and update)\"\"\"\n        if not self.slug:\n            from django.utils.text import slugify\n            self.slug = slugify(self.title)\n\n    def on_create_before_save(self):\n        \"\"\"Called only on creation, before save\"\"\"\n        print(f\"Creating new article: {self.title}\")\n\n    def after_save(self):\n        \"\"\"Called after every save\"\"\"\n        from django.core.cache import cache\n        cache.delete(f\"article:{self.id}\")\n\n    def on_create_after_save(self):\n        \"\"\"Called only after creation\"\"\"\n        print(f\"Article created with ID: {self.id}\")\n\n    def on_delete(self):\n        \"\"\"Called after deletion\"\"\"\n        print(f\"Article deleted: {self.title}\")\n</code></pre>"},{"location":"tutorial/model/#async-hooks","title":"Async Hooks","text":"Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    author = models.ForeignKey(Author, on_delete=models.CASCADE)\n    is_published = models.BooleanField(default=False)\n\n    class CreateSerializer:\n        fields = [\"title\", \"content\", \"author\"]\n        customs = [\n            (\"notify_subscribers\", bool, True),\n            (\"schedule_publish\", str, None),\n        ]\n\n    async def post_create(self):\n        \"\"\"Called after object creation (async)\"\"\"\n        # Send notification email\n        from myapp.tasks import send_new_article_notification\n        await send_new_article_notification(self.id)\n\n        # Create activity log\n        from myapp.models import ActivityLog\n        await ActivityLog.objects.acreate(\n            action=\"article_created\",\n            article_id=self.id,\n            user_id=self.author_id\n        )\n\n    async def custom_actions(self, payload: dict):\n        \"\"\"Process custom fields from CreateSerializer\"\"\"\n        if payload.get(\"notify_subscribers\"):\n            from myapp.tasks import notify_subscribers\n            await notify_subscribers(self.id)\n\n        if payload.get(\"schedule_publish\"):\n            from datetime import datetime\n            schedule_time = datetime.fromisoformat(payload[\"schedule_publish\"])\n            from myapp.tasks import schedule_publish_task\n            await schedule_publish_task(self.id, schedule_time)\n</code></pre> <p>Execution Order</p> <p>Create: <code>on_create_before_save()</code> \u2192 <code>before_save()</code> \u2192 <code>save()</code> \u2192 <code>on_create_after_save()</code> \u2192 <code>after_save()</code> \u2192 <code>custom_actions()</code> \u2192 <code>post_create()</code></p> Text Only<pre><code>**Update**: `before_save()` \u2192 `save()` \u2192 `after_save()` \u2192 `custom_actions()`\n</code></pre>"},{"location":"tutorial/model/#complete-example","title":"Complete Example","text":"<p>Here's a complete blog model with all features:</p> Python<pre><code># models.py\nfrom django.db import models\nfrom django.utils.text import slugify\nfrom ninja_aio.models import ModelSerializer\n\n\nclass Author(ModelSerializer):\n    name = models.CharField(max_length=200)\n    email = models.EmailField(unique=True)\n    bio = models.TextField(blank=True)\n    avatar = models.URLField(blank=True)\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"email\", \"bio\", \"avatar\", \"created_at\"]\n        customs = [\n            (\"article_count\", int, lambda obj: obj.articles.count()),\n        ]\n\n    class CreateSerializer:\n        fields = [\"name\", \"email\"]\n        optionals = [(\"bio\", str), (\"avatar\", str)]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"name\", str),\n            (\"bio\", str),\n            (\"avatar\", str),\n        ]\n        excludes = [\"email\", \"created_at\"]\n\n    def __str__(self):\n        return self.name\n\n\nclass Category(ModelSerializer):\n    name = models.CharField(max_length=100)\n    slug = models.SlugField(unique=True, blank=True)\n    description = models.TextField(blank=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"slug\", \"description\"]\n\n    class CreateSerializer:\n        fields = [\"name\"]\n        optionals = [(\"description\", str)]\n\n    def before_save(self):\n        if not self.slug:\n            self.slug = slugify(self.name)\n\n    def __str__(self):\n        return self.name\n\n\nclass Tag(ModelSerializer):\n    name = models.CharField(max_length=50, unique=True)\n    slug = models.SlugField(unique=True, blank=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"slug\"]\n\n    class CreateSerializer:\n        fields = [\"name\"]\n\n    def before_save(self):\n        if not self.slug:\n            self.slug = slugify(self.name)\n\n    def __str__(self):\n        return self.name\n\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    slug = models.SlugField(unique=True, blank=True)\n    content = models.TextField()\n    excerpt = models.TextField(max_length=300, blank=True)\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"articles\")\n    category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True, related_name=\"articles\")\n    tags = models.ManyToManyField(Tag, related_name=\"articles\", blank=True)\n    cover_image = models.URLField(blank=True)\n    is_published = models.BooleanField(default=False)\n    published_at = models.DateTimeField(null=True, blank=True)\n    views = models.IntegerField(default=0)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    class ReadSerializer:\n        fields = [\n            \"id\", \"title\", \"slug\", \"content\", \"excerpt\",\n            \"author\", \"category\", \"tags\", \"cover_image\",\n            \"is_published\", \"published_at\", \"views\",\n            \"created_at\", \"updated_at\"\n        ]\n        customs = [\n            (\"word_count\", int, lambda obj: len(obj.content.split())),\n            (\"reading_time\", int, lambda obj: max(1, len(obj.content.split()) // 200)),\n        ]\n\n    class CreateSerializer:\n        fields = [\"title\", \"content\", \"author\", \"category\"]\n        optionals = [\n            (\"excerpt\", str),\n            (\"cover_image\", str),\n            (\"tags\", list[int]),\n            (\"is_published\", bool),\n        ]\n        customs = [\n            (\"notify_subscribers\", bool, True),\n        ]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"title\", str),\n            (\"content\", str),\n            (\"excerpt\", str),\n            (\"category\", int),\n            (\"tags\", list[int]),\n            (\"cover_image\", str),\n            (\"is_published\", bool),\n        ]\n        excludes = [\"author\", \"created_at\", \"views\"]\n\n    def before_save(self):\n        # Generate slug from title\n        if not self.slug:\n            self.slug = slugify(self.title)\n\n        # Auto-generate excerpt\n        if not self.excerpt and self.content:\n            self.excerpt = self.content[:297] + \"...\"\n\n        # Set published_at when publishing\n        if self.is_published and not self.published_at:\n            from django.utils import timezone\n            self.published_at = timezone.now()\n\n    async def post_create(self):\n        # Log creation\n        from myapp.models import ActivityLog\n        await ActivityLog.objects.acreate(\n            action=\"article_created\",\n            article_id=self.id,\n            user_id=self.author_id\n        )\n\n    async def custom_actions(self, payload: dict):\n        if payload.get(\"notify_subscribers\"):\n            # Send notifications (implement your notification logic)\n            from myapp.tasks import notify_article_published\n            await notify_article_published(self.id)\n\n    def __str__(self):\n        return self.title\n</code></pre>"},{"location":"tutorial/model/#run-migrations","title":"Run Migrations","text":"<p>After defining your models, create and run migrations:</p> Bash<pre><code># Create migrations\npython manage.py makemigrations\n\n# Apply migrations\npython manage.py migrate\n</code></pre>"},{"location":"tutorial/model/#next-steps","title":"Next Steps","text":"<p>Now that you have your models defined, let's create CRUD views in Step 2: Create CRUD Views.</p> <p>!!! success \"What You've Learned\" - \u2705 Creating models with <code>ModelSerializer</code> - \u2705 Defining Read, Create, and Update serializers - \u2705 Working with ForeignKey and ManyToMany relationships - \u2705 Adding custom computed fields - \u2705 Implementing lifecycle hooks</p>"},{"location":"tutorial/model/#see-also","title":"See Also","text":"<ul> <li>ModelSerializer API Reference - Complete API documentation</li> <li>ModelUtil API Reference - Utility methods</li> </ul>"}]}