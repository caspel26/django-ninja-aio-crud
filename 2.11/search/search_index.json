{"config":{"lang":["en"],"separator":"[\\\\s\\\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83e\udd77 Django Ninja Aio CRUD","text":"<p>Django Ninja Aio CRUD is a powerful async REST framework built on top of Django Ninja. It provides automatic CRUD operations, class-based views, and built-in utilities to make API development faster and cleaner.</p>"},{"location":"#key-features","title":"\u2728 Key Features","text":"<ul> <li>\ud83d\udce6 Serializer (Meta-driven) \u2014 Define schemas for existing Django models without inheriting ModelSerializer</li> <li>\ud83d\ude80 Fully Async - Built for Django's async ORM</li> <li>\ud83d\udd04 Automatic CRUD - Generate complete REST APIs with minimal code</li> <li>\ud83d\udcdd ModelSerializer - Define schemas directly on models</li> <li>\ud83c\udfaf Class-Based Views - Clean, organized view architecture</li> <li>\ud83d\udd10 JWT Authentication - Built-in async JWT bearer authentication</li> <li>\ud83d\udcc4 Auto Documentation - OpenAPI/Swagger UI out of the box</li> <li>\ud83d\udd17 Relationship Support - Automatic nested serialization (FK, M2M, reverse relations)</li> <li>\ud83d\udcca Pagination - Built-in async pagination support</li> <li>\u26a1 Performance - Using <code>orjson</code> for fast JSON serialization</li> </ul>"},{"location":"#why-django-ninja-aio-crud","title":"\ud83c\udfaf Why Django Ninja Aio CRUD?","text":"<p>Traditional Django REST development requires:</p> <ul> <li>Separate serializer classes</li> <li>Manual CRUD view implementation</li> <li>Repetitive boilerplate code</li> <li>Complex relationship handling</li> </ul> <p>Django Ninja Aio CRUD eliminates this complexity:</p> Traditional ApproachDjango Ninja Aio CRUD Python<pre><code># schema.py\nclass UserSchemaOut(ModelSchema)\n    class Meta:\n    model = User\n    fields = ['id', 'username', 'email']\n\nclass UserSchemaIn(ModelSchema):\n    class Meta:\n        model = User\n        fields = ['username', 'email', 'password']\n\n# views.py\n@api.get(\"/users\", response={200: list[UserSchemaOut]})\nasync def list_users(request):\n    return [user async for user in User.objects.select_related().all()]\n\n@api.post(\"/users/\", response={201: UserSchemaOut})\nasync def create_user(request, data: UserSchemaIn):\n    user = await User.objects.select_related().acreate(**data.model_dump())\n    return 201, user\n\n\n# ... more views for retrieve, update, delete\n</code></pre> Python<pre><code># models.py\nclass User(ModelSerializer):\n    username = models.CharField(max_length=150)\n    email = models.EmailField()\n    password = models.CharField(max_length=128)\n\n    class ReadSerializer:\n        fields = [\"id\", \"username\", \"email\"]\n\n    class CreateSerializer:\n        fields = [\"username\", \"email\", \"password\"]\n\n    class UpdateSerializer:\n        optionals = [(\"email\", str)]\n\n# views.py\n@api.viewset(User)\nclass UserViewSet(APIViewSet):\n    pass\n\n# Done! List, Create, Retrieve, Update, Delete endpoints ready\n</code></pre>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":"<p>Explore detailed documentation for each component:</p>"},{"location":"#serializer-meta-driven","title":"Serializer (Meta-driven)","text":"<ul> <li>Serializer (Meta-driven) - Dynamic schemas for existing Django models without inheriting ModelSerializer</li> </ul>"},{"location":"#models","title":"Models","text":"<ul> <li>Model Serializer - Schema generation and serialization</li> <li>Model Util - Async CRUD utilities</li> </ul>"},{"location":"#views","title":"Views","text":"<ul> <li>API View - Simple custom views</li> <li>API View Set - Complete CRUD operations</li> </ul>"},{"location":"#advanced-topics","title":"Advanced Topics","text":"<ul> <li>Authentication - JWT and custom auth</li> <li>Pagination - Customize pagination behavior</li> </ul>"},{"location":"#start-with-serializer","title":"Start with Serializer","text":"<p>Use Meta-driven Serializer first if you already have Django models and want immediate CRUD without changing bases:</p> Python<pre><code>from ninja_aio.models import serializers\nfrom . import models\n\nclass BookSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Book\n        schema_in = serializers.SchemaModelConfig(fields=[\"title\", \"published\"])\n        schema_out = serializers.SchemaModelConfig(fields=[\"id\", \"title\", \"published\"])\n        schema_update = serializers.SchemaModelConfig(optionals=[(\"title\", str), (\"published\", bool)])\n````\n\nAttach to a ViewSet:\n\n```python\nfrom ninja_aio.views import APIViewSet\nfrom ninja_aio import NinjaAIO\n\napi = NinjaAIO()\n\n@api.viewset(models.Book)\nclass BookViewSet(APIViewSet):\n    serializer_class = BookSerializer\n</code></pre>"},{"location":"#query-optimization-and-schemas","title":"Query optimization and schemas","text":"<ul> <li>Declare query optimizations on models via <code>class QuerySet</code> (read, queryset_request, extras).</li> <li>Use <code>QueryUtil</code> to apply scope-based <code>select_related</code> / <code>prefetch_related</code>.</li> <li>Standard query schemas:</li> <li><code>ObjectsQuerySchema(filters=..., select_related=..., prefetch_related=...)</code></li> <li><code>ObjectQuerySchema(getters=..., select_related=..., prefetch_related=...)</code></li> <li><code>QuerySchema(filters=... | getters=...)</code></li> </ul> <p>ViewSets internally use these to:</p> <ul> <li>Build optimized querysets in list/retrieve.</li> <li>Serialize via <code>list_read_s</code> and <code>read_s</code>.</li> </ul> <p>Example:</p> Python<pre><code>items = await ModelUtil(Article).list_read_s(\n    Article.generate_read_s(),\n    request,\n    query_data=ObjectsQuerySchema(filters={\"category\": 3}),\n    is_for_read=True,\n)\n</code></pre>"},{"location":"#example-complete-blog-api","title":"\ud83d\udca1 Example: Complete Blog API","text":"<p>Here's a real-world example with relationships:</p> Python<pre><code># models.py\nfrom django.db import models\nfrom ninja_aio.models import ModelSerializer\n\n\nclass Author(ModelSerializer):\n    name = models.CharField(max_length=200)\n    email = models.EmailField(unique=True)\n    bio = models.TextField(blank=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"email\", \"bio\", \"articles\"]\n\n    class CreateSerializer:\n        fields = [\"name\", \"email\"]\n        optionals = [(\"bio\", str)]\n\n\nclass Category(ModelSerializer):\n    name = models.CharField(max_length=100)\n    slug = models.SlugField(unique=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"slug\"]\n\n    class CreateSerializer:\n        fields = [\"name\", \"slug\"]\n\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    slug = models.SlugField(unique=True)\n    content = models.TextField()\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"articles\")\n    category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True)\n    tags = models.ManyToManyField('Tag', related_name=\"articles\")\n    is_published = models.BooleanField(default=False)\n    views = models.IntegerField(default=0)\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    class ReadSerializer:\n        fields = [\n            \"id\", \"title\", \"slug\", \"content\",\n            \"author\", \"category\", \"tags\",\n            \"is_published\", \"views\", \"created_at\"\n        ]\n\n    class CreateSerializer:\n        fields = [\"title\", \"slug\", \"content\", \"author\", \"category\"]\n        customs = [(\"notify_subscribers\", bool, True)]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"title\", str),\n            (\"content\", str),\n            (\"is_published\", bool),\n        ]\n\n    async def custom_actions(self, payload: dict):\n        if payload.get(\"notify_subscribers\"):\n            # Send notifications\n            await notify_new_article(self)\n\n\nclass Tag(ModelSerializer):\n    name = models.CharField(max_length=50, unique=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\"]\n\n\n# views.py\nfrom ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom .models import Author, Category, Article, Tag\n\napi = NinjaAIO(title=\"Blog API\", version=\"1.0.0\")\n\n\n@api.viewset(Author)\nclass AuthorViewSet(APIViewSet):\n    pass\n\n\n@api.viewset(Category)\nclass CategoryViewSet(APIViewSet):\n    pass\n\n\n@api.viewset(Article)\nclass ArticleViewSet(APIViewSet):\n    query_params = {\n        \"is_published\": (bool, None),\n        \"category\": (int, None),\n        \"author\": (int, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        if filters.get(\"is_published\") is not None:\n            queryset = queryset.filter(is_published=filters[\"is_published\"])\n        if filters.get(\"category\"):\n            queryset = queryset.filter(category_id=filters[\"category\"])\n        if filters.get(\"author\"):\n            queryset = queryset.filter(author_id=filters[\"author\"])\n        return queryset\n\n\n@api.viewset(Tag)\nclass TagViewSet(APIViewSet):\n    pass\n</code></pre> <p>This creates a complete blog API with:</p> <ul> <li>4 models with relationships</li> <li>Automatic nested serialization</li> <li>Query filtering</li> <li>Custom actions</li> <li>Full CRUD operations for all models</li> </ul>"},{"location":"#key-concepts","title":"\ud83c\udf1f Key Concepts","text":""},{"location":"#modelserializer","title":"ModelSerializer","text":"<p>Central to Django Ninja Aio CRUD - defines schemas directly on models:</p> Python<pre><code>class User(ModelSerializer):\n    username = models.CharField(max_length=150)\n\n    class ReadSerializer:\n        fields = [\"id\", \"username\"]  # Response schema\n\n    class CreateSerializer:\n        fields = [\"username\"]  # Input schema\n\n    class UpdateSerializer:\n        optionals = [(\"username\", str)]  # Partial update schema\n</code></pre>"},{"location":"#serializer-meta-driven_1","title":"Serializer (Meta-driven)","text":"<p>Use when you have vanilla Django models and want dynamic serialization without changing your model base class.</p> Python<pre><code>from ninja_aio.models import serializers\nfrom . import models\n\nclass BookSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Book\n        schema_in = serializers.SchemaModelConfig(fields=[\"title\", \"published\"])\n        schema_out = serializers.SchemaModelConfig(fields=[\"id\", \"title\", \"published\"])\n        schema_update = serializers.SchemaModelConfig(optionals=[(\"title\", str), (\"published\", bool)])\n</code></pre> <p>Attach to an APIViewSet:</p> Python<pre><code>@api.viewset(models.Book)\nclass BookViewSet(APIViewSet):\n    serializer_class = BookSerializer\n</code></pre>"},{"location":"#apiviewset","title":"APIViewSet","text":"<p>Automatically generates complete CRUD endpoints:</p> Python<pre><code>@api.viewset(User)\nclass UserViewSet(APIViewSet):\n    pass\n    # Generates: List, Create, Retrieve, Update, Delete\n</code></pre>"},{"location":"#custom-views","title":"Custom Views","text":"<p>Extend with custom endpoints:</p> Python<pre><code>from ninja_aio.decorators import api_post\n\n@api.viewset(User)\nclass UserViewSet(APIViewSet):\n    @api_post(\"/{pk}/activate\")\n    async def activate(self, request, pk: int):\n        user = await User.objects.aget(pk=pk)\n        user.is_active = True\n        await user.asave()\n        return {\"message\": \"User activated\"}\n</code></pre>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"#support","title":"\u2615 Support","text":"<p>If you find Django Ninja Aio CRUD useful, consider supporting the project:</p> <p></p>"},{"location":"#links","title":"\ud83d\udd17 Links","text":"<ul> <li>Documentation: https://django-ninja-aio.com</li> <li>GitHub: https://github.com/caspel26/django-ninja-aio-crud</li> <li>PyPI: https://pypi.org/project/django-ninja-aio-crud/</li> <li>Django Ninja: https://django-ninja.dev/</li> <li>Example repository: https://github.com/caspel26/ninja-aio-blog-example</li> </ul> <p>Built with \u2764\ufe0f using Django Ninja</p>"},{"location":"auth/","title":"JWT Authentication and AsyncJwtBearer","text":"<p>This page documents the JWT helpers and the <code>AsyncJwtBearer</code> class in <code>ninja_aio/auth.py</code>, including configuration, validation, and usage in Django Ninja.</p>"},{"location":"auth/#overview","title":"Overview","text":"<ul> <li><code>AsyncJwtBearer</code>: Asynchronous HTTP Bearer auth that verifies JWTs, validates claims via a registry, and delegates user resolution to <code>auth_handler</code>.</li> <li>Helpers:</li> <li><code>validate_key</code>: Ensures JWK keys are present and of the correct type.</li> <li><code>validate_mandatory_claims</code>: Ensures <code>iss</code> and <code>aud</code> are present (from settings if not provided).</li> <li><code>encode_jwt</code>: Signs a JWT with time-based claims (<code>iat</code>, <code>nbf</code>, <code>exp</code>) and mandatory <code>iss/aud</code>.</li> <li><code>decode_jwt</code>: Verifies and decodes a JWT with a public key and allowed algorithms.</li> </ul>"},{"location":"auth/#configuration-without-settings","title":"Configuration without settings","text":"<p>Settings are not required. Provide keys and claims explicitly:</p> <ul> <li>Pass <code>private_key</code> to <code>encode_jwt</code> and <code>public_key</code> to <code>decode_jwt</code>/<code>AsyncJwtBearer.jwt_public</code>.</li> <li>Include <code>iss</code> and <code>aud</code> directly in the <code>claims</code> you encode if you are not using settings.</li> </ul> <p>Example key usage without settings:</p> Python<pre><code># ...existing code...\nfrom joserfc import jwk\nfrom ninja_aio.auth import encode_jwt, decode_jwt\n\nprivate_key = jwk.RSAKey.import_key(open(\"priv.jwk\").read())\npublic_key = jwk.RSAKey.import_key(open(\"pub.jwk\").read())\n\ntoken = encode_jwt(\n    claims={\"sub\": \"123\", \"iss\": \"https://auth.example\", \"aud\": \"my-api\"},\n    duration=3600,\n    private_key=private_key,\n    algorithm=\"RS256\",\n)\n\ndecoded = decode_jwt(token=token, public_key=public_key, algorithms=[\"RS256\"])\n# ...existing code...\n</code></pre>"},{"location":"auth/#mandatory-claims","title":"Mandatory claims","text":"<p>The library enforces <code>iss</code> and <code>aud</code> via <code>JWT_MANDATORY_CLAIMS</code>. If you do not use settings, include them in the payload you pass to <code>encode_jwt</code>.</p>"},{"location":"auth/#configuration-with-settings-optional","title":"Configuration with settings (optional)","text":"<p>You can centralize configuration in Django settings and omit explicit keys/claims:</p> <ul> <li><code>JWT_PRIVATE_KEY</code>: jwk.RSAKey or jwk.ECKey for signing</li> <li><code>JWT_PUBLIC_KEY</code>: jwk.RSAKey or jwk.ECKey for verification</li> <li><code>JWT_ISSUER</code>: issuer string</li> <li><code>JWT_AUDIENCE</code>: audience string</li> </ul> <p>When present:</p> <ul> <li><code>encode_jwt</code> reads <code>JWT_PRIVATE_KEY</code> if <code>private_key</code> is not passed, and fills <code>iss</code>/<code>aud</code> via <code>validate_mandatory_claims</code> if missing.</li> <li><code>decode_jwt</code> reads <code>JWT_PUBLIC_KEY</code> if <code>public_key</code> is not passed.</li> <li><code>AsyncJwtBearer</code> can read the public key from settings by assigning <code>jwt_public = settings.JWT_PUBLIC_KEY</code>.</li> </ul> Python<pre><code># settings.py (example)\nJWT_PRIVATE_KEY = jwk.RSAKey.import_key(open(\"priv.jwk\").read())\nJWT_PUBLIC_KEY = jwk.RSAKey.import_key(open(\"pub.jwk\").read())\nJWT_ISSUER = \"https://auth.example\"\nJWT_AUDIENCE = \"my-api\"\n</code></pre> <p>Usage without passing keys/claims explicitly:</p> Python<pre><code>from ninja_aio.auth import encode_jwt, decode_jwt\n# claims missing iss/aud will be completed from settings\ntoken = encode_jwt(claims={\"sub\": \"123\"}, duration=3600)\n\ndecoded = decode_jwt(token=token)  # uses settings.JWT_PUBLIC_KEY\n</code></pre> <p>AsyncJwtBearer wired to settings:</p> Python<pre><code>from django.conf import settings\nfrom ninja_aio.auth import AsyncJwtBearer\n\nclass SettingsBearer(AsyncJwtBearer):\n    jwt_public = settings.JWT_PUBLIC_KEY\n    claims = {\n        \"iss\": {\"value\": settings.JWT_ISSUER},\n        \"aud\": {\"value\": settings.JWT_AUDIENCE},\n        # Optionally require time-based claims:\n        # \"exp\": {\"essential\": True},\n        # \"nbf\": {\"essential\": True},\n    }\n\n    async def auth_handler(self, request):\n        sub = self.dcd.claims.get(\"sub\")\n        return {\"user_id\": sub}\n</code></pre>"},{"location":"auth/#asyncjwtbearer","title":"AsyncJwtBearer","text":""},{"location":"auth/#key-points","title":"Key points","text":"<ul> <li><code>jwt_public</code>: Must be a JWK (RSA or EC) used to verify signatures.</li> <li><code>claims</code>: Dict passed to <code>jwt.JWTClaimsRegistry</code> defining validations (e.g., <code>iss</code>, <code>aud</code>, <code>exp</code>, <code>nbf</code>).</li> <li><code>algorithms</code>: Allowed algorithms (default <code>[\"RS256\"]</code>).</li> <li><code>dcd</code>: Set after successful decode; instance of <code>jwt.Token</code> containing <code>header</code> and <code>claims</code>.</li> <li><code>get_claims()</code>: Builds the claim registry from <code>claims</code>.</li> <li><code>validate_claims(claims)</code>: Validates decoded claims; raises <code>jose.errors.JoseError</code> on failure.</li> <li><code>auth_handler(request)</code>: Async hook to resolve application user given the decoded token (<code>self.dcd</code>).</li> <li><code>authenticate(request, token)</code>: Decodes, validates, and delegates to <code>auth_handler</code>. Returns user or <code>False</code>.</li> </ul>"},{"location":"auth/#example","title":"Example","text":"Python<pre><code>from joserfc import jwk\nfrom ninja import NinjaAPI\nfrom ninja_aio.auth import AsyncJwtBearer\n\nclass MyBearer(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(open(\"pub.jwk\").read())\n    claims = {\n        \"iss\": {\"value\": \"https://auth.example\"},\n        \"aud\": {\"value\": \"my-api\"},\n        # You can add time-based checks if needed:\n        # \"exp\": {\"essential\": True},\n        # \"nbf\": {\"essential\": True},\n    }\n\n    async def auth_handler(self, request):\n        sub = self.dcd.claims.get(\"sub\")\n        return {\"user_id\": sub}\n\napi = NinjaAPI()\n\n@api.get(\"/secure\", auth=MyBearer())\ndef secure_endpoint(request):\n    return {\"ok\": True}\n</code></pre>"},{"location":"auth/#claims-registry-helper","title":"Claims registry helper","text":"<p>You can construct and reuse a registry from your class-level <code>claims</code>:</p> Python<pre><code>registry = MyBearer.get_claims()\n# registry.validate(token_claims)  # raises JoseError on failure\n</code></pre>"},{"location":"auth/#encode_jwt","title":"encode_jwt","text":"<p>Signs a JWT with safe defaults:</p> <ul> <li>Adds <code>iat</code>, <code>nbf</code>, and <code>exp</code> using timezone-aware <code>timezone.now()</code>.</li> <li>Ensures <code>iss</code> and <code>aud</code> are present via <code>validate_mandatory_claims</code> (include them in <code>claims</code> if not using settings).</li> <li>Header includes <code>alg</code>, <code>typ=JWT</code>, and optional <code>kid</code>.</li> </ul> Python<pre><code>from joserfc import jwk\nfrom ninja_aio.auth import encode_jwt\n\nprivate_key = jwk.RSAKey.import_key(open(\"priv.jwk\").read())\n\nclaims = {\"sub\": \"123\", \"scope\": \"read\", \"iss\": \"https://auth.example\", \"aud\": \"my-api\"}\ntoken = encode_jwt(\n    claims=claims,\n    duration=3600,\n    private_key=private_key,\n    algorithm=\"RS256\",\n)\n</code></pre>"},{"location":"auth/#decode_jwt","title":"decode_jwt","text":"<p>Verifies and decodes a JWT with a public key and algorithm allow-list.</p> Python<pre><code>from joserfc import jwk\nfrom ninja_aio.auth import decode_jwt\n\npublic_key = jwk.RSAKey.import_key(open(\"pub.jwk\").read())\n\ndecoded = decode_jwt(\n    token=token,\n    public_key=public_key,\n    algorithms=[\"RS256\"],\n)\n\nclaims = decoded.claims\nsub = claims.get(\"sub\")\n</code></pre>"},{"location":"auth/#validate_key","title":"validate_key","text":"<p>If you do not use settings, pass keys directly. <code>validate_key</code> will raise <code>ValueError</code> only when neither an explicit key nor a configured setting is provided.</p> Python<pre><code>from ninja_aio.auth import validate_key\nfrom joserfc import jwk\n\npkey = validate_key(jwk.RSAKey.import_key(open(\"priv.jwk\").read()), \"JWT_PRIVATE_KEY\")\n</code></pre>"},{"location":"auth/#validate_mandatory_claims","title":"validate_mandatory_claims","text":"<p>Ensures <code>iss</code> and <code>aud</code> are present; if settings are not used, include them in your input claims.</p> Python<pre><code>from ninja_aio.auth import validate_mandatory_claims\n\nclaims = {\"sub\": \"123\", \"iss\": \"https://auth.example\", \"aud\": \"my-api\"}\nclaims = validate_mandatory_claims(claims)\n</code></pre>"},{"location":"auth/#error-handling","title":"Error handling","text":"<ul> <li><code>authenticate</code> returns <code>False</code> on decode (<code>ValueError</code>) or claim validation failure (<code>JoseError</code>). Map this to 401/403 in your views as needed.</li> <li><code>validate_claims</code> raises <code>jose.errors.JoseError</code> for invalid claims.</li> <li><code>encode_jwt</code> and <code>decode_jwt</code> raise <code>ValueError</code> for missing/invalid keys or configuration.</li> </ul>"},{"location":"auth/#security-notes","title":"Security notes","text":"<ul> <li>Rotate keys and use <code>kid</code> headers to support key rotation.</li> <li>Validate critical claims (<code>exp</code>, <code>nbf</code>, <code>iss</code>, <code>aud</code>) via the registry.</li> <li>Do not log raw tokens or sensitive claims.</li> </ul>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions. Ways to help:</p> <ol> <li>Report Bugs \u2013 Open an issue on GitHub.</li> <li>Suggest Features \u2013 Share ideas in issues or discussions.</li> <li>Submit PRs \u2013 Improve code, tests, or docs.</li> <li>Improve Docs \u2013 Clarify, expand, or add examples.</li> <li>Add Tests \u2013 Increase coverage and reliability.</li> <li>Review PRs \u2013 Provide constructive feedback.</li> </ol>"},{"location":"contributing/#support-the-project","title":"\u2b50 Support the Project","text":"<p>If this project helps you, please give it a GitHub star to show support.</p>"},{"location":"contributing/#buy-me-a-coffee","title":"\u2615 Buy Me a Coffee","text":"<p>Optional tip: Buy Me a Coffee.</p>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<ul> <li>Keep PRs focused and small.</li> <li>Follow existing code style.</li> <li>Add or update tests when relevant.</li> <li>Update docs for user-facing changes.</li> <li>Link related issue in the PR description.</li> </ul>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"Bash<pre><code>git clone https://github.com/caspel26/django-ninja-aio-crud.git\ncd django-ninja-aio-crud\npython -m venv .venv\nsource .venv/bin/activate\npip install -r requirements.dev.txt\n</code></pre>"},{"location":"contributing/#issue-reports","title":"Issue Reports","text":"<p>Include: - Python/Django versions - Steps to reproduce - Expected vs actual behavior - Tracebacks or logs (if any)</p> <p>Thank you for helping improve the project.</p>"},{"location":"release_notes/","title":"Release NotesRelease NotesRelease NotesRelease NotesRelease NotesBoth list and retrieve use QuerySet.read optimizationsgenerate_detail_s() returns same schema as generate_read_s()For list operationsFor single object retrievalFor serializationBefore (v2.8.0)After (v2.9.0)Before (v2.8.0) - Same optimizations for list and retrieveAfter (v2.9.0) - Different optimizations per operationRelease NotesExisting code continues to work (no DetailSerializer = uses schema_out for retrieve)New: Add DetailSerializer for different retrieve responseBefore (v2.7.0) - Must provide related_schema manuallyAfter (v2.8.0) - Can use serializer_class insteadBefore (v2.7.0)After (v2.8.0)Step 1: Define your model with ReadSerializer and DetailSerializerStep 2: Create your ViewSet (schemas auto-generated!)That's it! Your API now has optimized list and detail endpoints:GET /articles/      \u2192 Returns list with minimal fieldsGET /articles/{pk}  \u2192 Returns single article with all fieldsRelease Notesmyapp/serializers.pyusers/serializers.pyExisting code continues to workNew Union syntax availableBefore (v2.6.1) - Only local references workedAfter (v2.7.0) - Absolute paths supportedStep 1: Define your serializersStep 2: Use Union in relations_serializersStep 3: Use with APIViewSet (automatic!)Release NotesBefore (v2.5.0) - NO LONGER WORKSAfter (v2.6.0) - Explicit generation requiredBefore (v2.5.0)After (v2.6.0)Before (v2.5.0) - Workarounds needed for circular refsAfter (v2.6.0) - String references make it easyAPIViewSet handles schema generation automaticallyExplicit schema generation when neededCache schemas at module level if generating repeatedlyBefore (v2.5.0)Access schemas (no longer works)After (v2.6.0)Explicit schema generationUsing with APIViewSet (no changes needed)Release NotesAutomatic transaction wrapping (new in v2.5.0)Before (v2.4.0)After (v2.5.0)v2.5.0 - Standardized (always receive instance)Release NotesRelease NotesRelease NotesRelease NotesRelease NotesRelease NotesRelease NotesRelease NotesRelease NotesRelease NotesRelease NotesRelease NotesDisable ops per relation if needed:M2MRelationSchema(model=Tag, related_name=\"tags\", add=False, remove=False, get=True)BeforeAfter","text":"VersionDateSummaryv2.11.0diff2026-01-19Release notes [v2.11.0] - 2026-01-19 \u2728 Added <ul> <li>MatchCaseFilterViewSetMixin [<code>ninja_aio/views/mixins.py</code>]:</li> <li>New mixin for conditional filtering based on boolean query parameters.</li> <li>Maps boolean API parameters (<code>?is_active=true</code>) to different Django ORM filter conditions for <code>True</code> and <code>False</code> cases.</li> <li>Supports both <code>filter()</code> (include) and <code>exclude()</code> operations via the <code>include</code> attribute.</li> <li> <p>Automatically registers query params from <code>filters_match_cases</code> configuration.</p> </li> <li> <p>New Filter Schemas [<code>ninja_aio/schemas/filters.py</code>]:</p> </li> <li><code>MatchCaseFilterSchema</code>: Configures match-case filters with <code>query_param</code> and <code>cases</code> attributes.</li> <li><code>MatchConditionFilterSchema</code>: Defines individual filter conditions with <code>query_filter</code> (dict) and <code>include</code> (bool).</li> <li><code>BooleanMatchFilterSchema</code>: Groups <code>true</code> and <code>false</code> case conditions.</li> <li><code>FilterSchema</code>: New base class for filter schemas with <code>filter_type</code> and <code>query_param</code> attributes.</li> </ul> \ud83d\udd27 Improvements <ul> <li>Unified Special Filter Detection [<code>ninja_aio/views/api.py</code>]:</li> <li>Added <code>APIViewSet._check_match_cases_filters(filter: str)</code> helper method.</li> <li> <p>Added <code>APIViewSet._is_special_filter(filter: str)</code> method combining relation and match-case filter detection.</p> </li> <li> <p>Filter Mixin Skip Logic [<code>ninja_aio/views/mixins.py</code>]:</p> </li> <li>Updated all filter mixins to use <code>_is_special_filter()</code> instead of <code>_check_relations_filters()</code>:<ul> <li><code>IcontainsFilterViewSetMixin</code></li> <li><code>BooleanFilterViewSetMixin</code></li> <li><code>NumericFilterViewSetMixin</code></li> <li><code>DateFilterViewSetMixin</code></li> </ul> </li> <li> <p>Ensures match-case filter params are not double-processed by type-based mixins.</p> </li> <li> <p>RelationFilterSchema Refactoring [<code>ninja_aio/schemas/filters.py</code>]:</p> </li> <li><code>RelationFilterSchema</code> now extends <code>FilterSchema</code> base class.</li> <li>Moved from <code>ninja_aio/schemas/api.py</code> to dedicated <code>ninja_aio/schemas/filters.py</code> module.</li> </ul> \ud83d\udcd6 Documentation <ul> <li>Mixins Documentation [<code>docs/api/views/mixins.md</code>]:</li> <li>Added comprehensive documentation for <code>MatchCaseFilterViewSetMixin</code>.</li> <li>Includes usage examples for simple status filtering and complex multi-condition filtering.</li> <li>Documents all schema requirements and configuration options.</li> </ul> \ud83e\uddea Tests <ul> <li>New Test Cases [<code>tests/views/test_viewset.py</code>]:</li> <li><code>MatchCaseFilterViewSetMixinTestCase</code>: Tests include behavior with <code>True</code>/<code>False</code>/<code>None</code> values.</li> <li><code>MatchCaseFilterViewSetMixinExcludeTestCase</code>: Tests exclude behavior when <code>include=False</code>.</li> <li> <p>Tests cover query params registration and <code>filters_match_cases_fields</code> property.</p> </li> <li> <p>Test ViewSets [<code>tests/test_app/views.py</code>]:</p> </li> <li><code>TestModelSerializerMatchCaseFilterAPI</code>: Tests <code>is_approved</code> filter with include/exclude logic.</li> <li> <p><code>TestModelSerializerMatchCaseExcludeFilterAPI</code>: Tests <code>hide_pending</code> filter with inverse logic.</p> </li> <li> <p>Test Model Update [<code>tests/test_app/models.py</code>]:</p> </li> <li>Added <code>status</code> field to <code>TestModelSerializer</code> for match-case filter testing.</li> </ul> \ud83d\udca1 Usage Example <p>```python from ninja_aio.views.mixins import MatchCaseFilterViewSetMixin from ninja_aio.views.api import APIViewSet from ninja_aio.schemas import (     MatchCaseFilterSchema,     MatchConditionFilterSchema,     BooleanMatchFilterSchema, )</p> <p>class OrderViewSet(MatchCaseFilterViewSetMixin, APIViewSet):     model = models.Order     api = api     filters_match_cases = [         MatchCaseFilterSchema(             query_param=\"is_completed\",             cases=BooleanMatchFilterSchema(                 true=MatchConditionFilterSchema(                     query_filter={\"status\": \"completed\"},                 ),                 false=MatchConditionFilterSchema(                     query_filter={\"status\": \"completed\"},                     include=False,  # excludes completed orders                 ),             ),         ),     ] ```</p> <p>API Behavior: - <code>GET /orders?is_completed=true</code> \u2192 <code>queryset.filter(status=\"completed\")</code> - <code>GET /orders?is_completed=false</code> \u2192 <code>queryset.exclude(status=\"completed\")</code></p> v2.10.1diff2026-01-16Release notes [v2.10.1] - 2026-01-16 \ud83d\udc1b Fixed <ul> <li>Filter Mixin Conflict Resolution [file:2]:</li> <li>Added <code>APIViewSet._check_relations_filters(filter: str)</code> helper method to detect if a filter key belongs to <code>relations_filters</code>.</li> <li> <p>Added <code>RelationFilterViewSetMixin.relations_filters_fields</code> property that extracts all <code>query_param</code> names from configured <code>relations_filters</code>.</p> </li> <li> <p>Filter Handler Skip Logic [file:2]:</p> </li> <li>IcontainsFilterViewSetMixin: Now skips relation filter keys (<code>if isinstance(value, str) and not self._check_relations_filters(key)</code>).</li> <li>BooleanFilterViewSetMixin: Now skips relation filter keys when applying boolean filters.</li> <li>NumericFilterViewSetMixin: Now skips relation filter keys when applying numeric filters.</li> <li>DateFilterViewSetMixin: Now skips relation filter keys when applying date comparisons (<code>__lte</code>, etc.).</li> </ul> <p>Impact: Prevents double-processing of relation filters when combining <code>RelationFilterViewSetMixin</code> with other filter mixins. Relation filters are handled exclusively by <code>RelationFilterViewSetMixin.query_params_handler</code>, avoiding conflicts like: - String relation params (<code>?author_id=5</code>) being misinterpreted as <code>icontains</code> filters. - Numeric relation params being applied twice. - Boolean/date relation params triggering incorrect transformations.</p> \ud83d\udd27 Internal Changes <ul> <li>Mixin Inheritance Chain:</li> <li>Filter mixins (<code>IcontainsFilterViewSetMixin</code>, etc.) now respect <code>RelationFilterViewSetMixin</code> configuration via shared <code>_check_relations_filters()</code> method.</li> <li> <p>Ensures proper layering: base filters \u2192 relation filters (exclusive handling).</p> </li> <li> <p>Query Params Handler Flow:</p> </li> </ul>v2.10.0diff2026-01-16Release notes [v2.10.0] - 2026-01-16 \u2728 Added <ul> <li>Relation-Based Filtering Mixin:</li> <li>New <code>RelationFilterViewSetMixin</code> for filtering by related model fields via query parameters.</li> <li>New <code>RelationFilterSchema</code> for declarative mapping of <code>query_param</code> \u2192 Django ORM <code>query_filter</code> with typed <code>filter_type</code> tuples.</li> <li> <p>Automatic registration of <code>relations_filters</code> entries into <code>query_params</code> on subclasses.</p> </li> <li> <p>Schema &amp; Import Enhancements:</p> </li> <li>Exported <code>RelationFilterSchema</code> from <code>ninja_aio.schemas</code> and added to <code>__all__</code>.</li> <li>Added <code>RelationFilterSchema</code> import to <code>ninja_aio.views.mixins</code> and example usages in docs and test views.</li> </ul> \ud83d\udee0 Changed <ul> <li>ModelUtil Relation Detection Fix:</li> <li>Corrected relation ordering in <code>ModelUtil.get_select_relateds()</code>:<ul> <li>Now detects <code>ForwardOneToOneDescriptor</code> before <code>ForwardManyToOneDescriptor</code> for building <code>select_related</code> lists.</li> </ul> </li> <li> <p>Ensures one-to-one relations are properly included in query optimizations.</p> </li> <li> <p>Documentation Updates:</p> </li> <li>Extended <code>docs/api/views/mixins.md</code> with a new section for <code>RelationFilterViewSetMixin</code>.</li> <li>Added examples showing how to configure <code>relations_filters</code> and resulting query behavior.</li> </ul> \ud83d\udc1b Fixed <ul> <li>ModelUtil Primary Key Type Error Handling:</li> <li><code>ModelUtil.pk_field_type</code> now raises a clear <code>ConfigError</code> when encountering unknown primary key field types.</li> <li> <p>Error message explicitly reports unsupported field type and suggests missing mapping in <code>ninja.orm.fields.TYPES</code>.</p> </li> <li> <p>ModelUtil Configuration Edge Cases:</p> </li> <li> <p><code>ModelUtil</code> now raises <code>ConfigError</code> when instantiated with a <code>ModelSerializer</code> model and an explicit <code>serializer_class</code> at the same time, avoiding ambiguous configuration.</p> </li> <li> <p>ORJSON Renderer Primitive Handling:</p> </li> <li>ORJSON renderer now correctly handles non-dict payloads (strings, lists, primitives) without assuming <code>.items()</code> presence.</li> <li> <p>Added coverage for list and primitive responses to ensure consistent rendering behavior.</p> </li> <li> <p>Async JWT Auth Robustness:</p> </li> <li><code>AsyncJwtBearer.authenticate</code> now safely handles invalid or malformed tokens where <code>jwt.decode</code> raises <code>ValueError</code>, returning <code>False</code> instead of propagating the exception.</li> <li>Base <code>auth_handler</code> path verified to return <code>None</code> when not overridden, and mandatory claims validation now preserves pre-set <code>iss</code> and <code>aud</code> values.</li> </ul> \ud83e\uddea Tests <ul> <li>New Test Suites for Edge Cases:</li> <li><code>ModelUtilConfigErrorTestCase</code> to validate <code>ConfigError</code> raising when mixing <code>ModelSerializer</code> model and <code>serializer_class</code>.</li> <li><code>ModelUtilPkFieldTypeTestCase</code> to ensure unknown PK types trigger <code>ConfigError</code> with informative message.</li> <li>`ModelUtilObjectsQueryDefaultTest</li> </ul>v2.9.0diff2026-01-14Release notes [v2.9.0] - 2026-01-14 \u2728 Added <ul> <li>Detail-Specific Query Optimizations:</li> <li>New <code>QuerySet.detail</code> configuration for detail-specific <code>select_related</code> and <code>prefetch_related</code></li> <li>New <code>serializable_detail_fields</code> property on <code>ModelUtil</code> for accessing detail-specific fields</li> <li>New <code>_get_serializable_field_names()</code> helper method for DRY field retrieval</li> <li> <p>New <code>DETAIL</code> scope added to <code>QueryUtilBaseScopesSchema</code></p> </li> <li> <p>Fallback Mechanism for Detail Schema:</p> </li> <li><code>generate_detail_s()</code> now falls back to read schema when no <code>DetailSerializer</code> is defined</li> <li><code>get_fields(\"detail\")</code> falls back to read fields when no detail fields are declared</li> <li><code>_get_read_optimizations(\"detail\")</code> falls back to <code>QuerySet.read</code> when <code>QuerySet.detail</code> is not defined</li> </ul> \ud83d\udee0 Changed <ul> <li>API Parameter Change: <code>is_for_read</code> \u2192 <code>is_for</code>:</li> <li>Renamed <code>is_for_read: bool</code> parameter to <code>is_for: Literal[\"read\", \"detail\"] | None</code> across all <code>ModelUtil</code> methods:<ul> <li><code>get_objects()</code></li> <li><code>get_object()</code></li> <li><code>read_s()</code></li> <li><code>list_read_s()</code></li> <li><code>_get_base_queryset()</code></li> <li><code>_apply_query_optimizations()</code></li> <li><code>_serialize_queryset()</code></li> <li><code>_serialize_single_object()</code></li> <li><code>_handle_query_mode()</code></li> <li><code>_read_s()</code></li> </ul> </li> <li> <p>This enables explicit control over which optimization strategy to use</p> </li> <li> <p>Query Optimization Methods Now Accept <code>is_for</code> Parameter:</p> </li> <li><code>get_select_relateds(is_for: Literal[\"read\", \"detail\"] = \"read\")</code></li> <li><code>get_reverse_relations(is_for: Literal[\"read\", \"detail\"] = \"read\")</code></li> <li> <p><code>_get_read_optimizations(is_for: Literal[\"read\", \"detail\"] = \"read\")</code></p> </li> <li> <p>APIViewSet Retrieve Endpoint:</p> </li> <li>Now uses <code>is_for=\"detail\"</code> when <code>schema_detail</code> is available</li> <li> <p>Falls back to <code>is_for=\"read\"</code> when no detail schema is configured</p> </li> <li> <p>Code Formatting Improvements:</p> </li> <li>Reformatted multi-line tuples in <code>_is_reverse_relation()</code></li> <li>Reformatted conditional in <code>_warn_missing_relation_serializer()</code></li> <li>Reformatted error message in <code>get_schema_out_data()</code></li> </ul> \ud83d\udc1b Fixed <ul> <li>Query Optimization Fallback Bug:</li> <li>Fixed <code>_get_read_optimizations()</code> to fall back to <code>read</code> config when <code>detail</code> config is not defined</li> <li>Previously returned empty <code>ModelQuerySetSchema()</code> when <code>QuerySet.detail</code> was missing, losing all optimizations</li> </ul> \ud83d\udcdd Documentation <ul> <li>ModelUtil Documentation (docs/api/models/model_util.md):</li> <li>Updated all method signatures from <code>is_for_read: bool</code> to <code>is_for: Literal[\"read\", \"detail\"] | None</code></li> <li>Added <code>QuerySet.detail</code> configuration example</li> <li>Added <code>serializable_detail_fields</code> property documentation</li> <li>Updated examples to show <code>is_for=\"read\"</code> and <code>is_for=\"detail\"</code> usage</li> <li> <p>Added fallback behavior notes for detail optimizations</p> </li> <li> <p>ModelSerializer Documentation (docs/api/models/model_serializer.md):</p> </li> <li>Added Fallback Behavior note in <code>DetailSerializer</code> section</li> <li>Updated <code>generate_detail_s()</code> comment to indicate fallback to read schema</li> <li> <p>Updated fields table to mention fallback behavior</p> </li> <li> <p>Serializer Documentation (docs/api/models/serializers.md):</p> </li> <li>Added <code>QuerySet.detail</code> configuration example</li> <li>Added explanation of how each QuerySet config is applied (<code>read</code>, <code>detail</code>, <code>queryset_request</code>, <code>extras</code>)</li> </ul> \ud83e\uddea Tests <ul> <li>Updated Test Cases:</li> <li>Updated all <code>is_for_read=True</code> to <code>is_for=\"read\"</code> across test files</li> <li>Updated all <code>is_for_read=False</code> to <code>is_for=None</code> across test files</li> <li>Renamed <code>test_generate_detail_schema_returns_none_when_not_configured</code> to <code>test_generate_detail_schema_falls_back_to_read_when_not_configured</code></li> <li> <p>Updated <code>test_fallback_to_schema_out_when_no_detail</code> to <code>test_detail_schema_falls_back_to_read_schema</code></p> </li> <li> <p>New Test Cases:</p> </li> <li><code>DetailFieldsModelSerializer</code> - Test model with different read vs detail fields including a relation</li> <li><code>ModelUtilIsForDetailTestCase</code> - Tests for <code>is_for='detail'</code> parameter:<ul> <li><code>test_serializable_fields_returns_read_fields()</code></li> <li><code>test_serializable_detail_fields_returns_detail_fields()</code></li> <li><code>test_get_select_relateds_read_no_relations()</code></li> <li><code>test_get_select_relateds_detail_includes_relation()</code></li> <li><code>test_apply_query_optimizations_read_vs_detail()</code></li> <li><code>test_get_serializable_field_names_read()</code></li> <li><code>test_get_serializable_field_names_detail()</code></li> </ul> </li> <li><code>ReadOnlyQuerySetModelSerializer</code> - Test model with <code>QuerySet.read</code> but no <code>QuerySet.detail</code></li> <li><code>ModelUtilOptimizationFallbackTestCase</code> - Tests for optimization fallback behavior:<ul> <li><code>test_get_read_optimizations_read()</code></li> <li><code>test_get_read_optimizations_detail_falls_back_to_read()</code></li> <li><code>test_apply_query_optimizations_detail_uses_read_fallback()</code></li> </ul> </li> </ul> \ud83d\udd27 Internal Changes <ul> <li>BaseSerializer Changes:</li> <li>Added <code>detail = ModelQuerySetSchema()</code> to inner <code>QuerySet</code> class</li> <li> <p>Added fallback logic in <code>get_fields()</code> for detail type</p> </li> <li> <p>QueryUtilBaseScopesSchema Changes:</p> </li> <li> <p>Added <code>DETAIL: str = \"detail\"</code> scope constant</p> </li> <li> <p>QueryUtil Changes:</p> </li> <li>Added <code>detail_config</code> property for accessing detail query configuration</li> </ul> \ud83d\ude80 Use Cases &amp; Examples Detail-Specific Query Optimizations <p>```python from ninja_aio.models import ModelSerializer from ninja_aio.schemas.helpers import ModelQuerySetSchema</p> <p>class Article(ModelSerializer):     title = models.CharField(max_length=200)     summary = models.TextField()     content = models.TextField()     author = models.ForeignKey(User, on_delete=models.CASCADE)     tags = models.ManyToManyField(Tag)     comments = models.ManyToManyField(Comment)</p> <pre><code>class ReadSerializer:\n    # List view: minimal fields\n    fields = [\"id\", \"title\", \"summary\", \"author\"]\n\nclass DetailSerializer:\n    # Detail view: all fields including expensive relations\n    fields = [\"id\", \"title\", \"summary\", \"content\", \"author\", \"tags\", \"comments\"]\n\nclass QuerySet:\n    # Optimizations for list endpoint\n    read = ModelQuerySetSchema(\n        select_related=[\"author\"],\n        prefetch_related=[],\n    )\n    # Optimizations for retrieve endpoint (more aggressive prefetching)\n    detail = ModelQuerySetSchema(\n        select_related=[\"author\", \"author__profile\"],\n        prefetch_related=[\"tags\", \"comments\", \"comments__author\"],\n    )\n</code></pre> <p>```</p> <p>Behavior: - <code>GET /articles/</code> uses <code>QuerySet.read</code> optimizations (light prefetching) - <code>GET /articles/{pk}</code> uses <code>QuerySet.detail</code> optimizations (full prefetching)</p> Fallback Behavior <p>```python class Article(ModelSerializer):     class ReadSerializer:         fields = [\"id\", \"title\", \"content\"]</p> <pre><code>class QuerySet:\n    read = ModelQuerySetSchema(\n        select_related=[\"author\"],\n        prefetch_related=[\"tags\"],\n    )\n    # No detail config - will fall back to read!\n</code></pre> <p>```</p> Using is_for Parameter Directly <p>```python from ninja_aio.models import ModelUtil</p> <p>util = ModelUtil(Article)</p> <p>qs = await util.get_objects(request, is_for=\"read\")</p> <p>obj = await util.get_object(request, pk=1, is_for=\"detail\")</p> <p>data = await util.read_s(schema, request, instance=obj, is_for=\"detail\") items = await util.list_read_s(schema, request, instances=qs, is_for=\"read\") ```</p> \ud83d\udd0d Migration Guide Breaking Change: <code>is_for_read</code> \u2192 <code>is_for</code> <p>If you call <code>ModelUtil</code> methods directly with <code>is_for_read</code>, update to use <code>is_for</code>:</p> <p>```python</p> <p>await util.get_objects(request, is_for_read=True) await util.get_object(request, pk=1, is_for_read=True) await util.read_s(schema, request, instance=obj, is_for_read=True)</p> <p>await util.get_objects(request, is_for=\"read\") await util.get_object(request, pk=1, is_for=\"detail\") await util.read_s(schema, request, instance=obj, is_for=\"detail\") ```</p> <p>Mapping: | Old Parameter | New Parameter | |---------------|---------------| | <code>is_for_read=True</code> | <code>is_for=\"read\"</code> (for list) or <code>is_for=\"detail\"</code> (for retrieve) | | <code>is_for_read=False</code> | <code>is_for=None</code> |</p> Adding Detail-Specific Optimizations <p>```python</p> <p>class QuerySet:     read = ModelQuerySetSchema(         select_related=[\"author\"],         prefetch_related=[\"tags\", \"comments\"],  # Always loaded!     )</p> <p>class QuerySet:     read = ModelQuerySetSchema(         select_related=[\"author\"],         prefetch_related=[],  # Light for list     )     detail = ModelQuerySetSchema(         select_related=[\"author\", \"author__profile\"],         prefetch_related=[\"tags\", \"comments\"],  # Full for retrieve     ) ```</p> \ud83d\udcca Performance Benefits <p>| Scenario | Without Detail Config | With Detail Config | |----------|----------------------|-------------------| | List 100 articles | Prefetches tags + comments for all | Only prefetches what's needed for list | | Retrieve single | Uses list optimizations | Uses detail-specific optimizations | | N+1 queries | May occur if list over-fetches | Optimized per endpoint | | Memory usage | Higher (unnecessary prefetch) | Optimized per operation |</p> \u26a0\ufe0f Important Notes <ul> <li>Breaking Change: <code>is_for_read: bool</code> parameter renamed to <code>is_for: Literal[\"read\", \"detail\"] | None</code></li> <li>Fallback Behavior: All fallbacks are automatic - no configuration needed for backward compatibility</li> <li>QuerySet.detail: Optional - falls back to <code>QuerySet.read</code> if not defined</li> <li>DetailSerializer fields: Optional - falls back to <code>ReadSerializer</code> fields if not defined</li> <li>generate_detail_s(): Now always returns a schema (falls back to read schema)</li> </ul> \ud83d\udd17 Links <ul> <li>Documentation</li> <li>GitHub Repository</li> <li>Issue Tracker</li> <li>v2.8.0 Release Notes</li> </ul> Version History <p>For older versions, please refer to the GitHub releases page.</p>v2.8.0diff2026-01-14Release notes [v2.8.0] - 2026-01-14 \u2728 Added <ul> <li>Detail Schema Support for Retrieve Endpoints:</li> <li>New <code>DetailSerializer</code> configuration class for <code>ModelSerializer</code></li> <li>New <code>schema_detail</code> configuration option for <code>Serializer</code> Meta class</li> <li>New <code>schema_detail</code> attribute on <code>APIViewSet</code> for custom detail schemas</li> <li>New <code>generate_detail_s()</code> method for generating detail schemas</li> <li>Retrieve endpoint (<code>GET /{base}/{pk}</code>) now uses <code>schema_detail</code> when available, falling back to <code>schema_out</code></li> <li> <p>Enables performance optimization: minimal fields for list views, full details for single object retrieval</p> </li> <li> <p><code>serializer_class</code> Support for M2MRelationSchema:</p> </li> <li><code>M2MRelationSchema</code> now accepts <code>serializer_class</code> parameter for plain Django models</li> <li>Auto-generates <code>related_schema</code> from the serializer when provided</li> <li>Alternative to manually providing <code>related_schema</code> for plain models</li> <li>Validation ensures <code>serializer_class</code> cannot be used when <code>model</code> is already a <code>ModelSerializer</code></li> </ul> \ud83d\udee0 Changed <ul> <li>APIViewSet Schema Generation:</li> <li><code>get_schemas()</code> now returns a 4-tuple: <code>(schema_out, schema_detail, schema_in, schema_update)</code></li> <li>New <code>_get_retrieve_schema()</code> helper method for retrieve endpoint schema selection</li> <li> <p><code>retrieve_view()</code> updated to use detail schema when available</p> </li> <li> <p>Refactored <code>get_schema_out_data()</code> Function:</p> </li> <li>Extracted helper methods for better code organization:<ul> <li><code>_is_reverse_relation()</code> - Check if field is a reverse relation</li> <li><code>_is_forward_relation()</code> - Check if field is a forward relation</li> <li><code>_warn_missing_relation_serializer()</code> - Emit warning for missing serializer mappings</li> <li><code>_process_field()</code> - Process single field and determine classification</li> </ul> </li> <li>Renamed parameter <code>type</code> to <code>schema_type</code> to avoid shadowing built-in</li> <li>Renamed internal variable <code>rels</code> to <code>forward_rels</code> for clarity</li> <li> <p>Now accepts <code>schema_type: Literal[\"Out\", \"Detail\"]</code> parameter</p> </li> <li> <p>Performance Optimization in <code>_generate_union_schema()</code>:</p> </li> <li>Fixed double method call issue using walrus operator</li> <li> <p><code>generate_related_s()</code> now called once per serializer instead of twice</p> </li> <li> <p>Updated Type Definitions:</p> </li> <li><code>S_TYPES</code> now includes <code>\"detail\"</code>: <code>Literal[\"read\", \"detail\", \"create\", \"update\"]</code></li> <li><code>SCHEMA_TYPES</code> now includes <code>\"Detail\"</code>: <code>Literal[\"In\", \"Out\", \"Detail\", \"Patch\", \"Related\"]</code></li> </ul> \ud83d\udcdd Documentation <ul> <li>ModelSerializer Documentation (docs/api/models/model_serializer.md):</li> <li>New DetailSerializer section with complete documentation</li> <li>Updated schema generation table to include <code>generate_detail_s()</code></li> <li>Added example showing List vs Detail output differences</li> <li> <p>Updated \"Auto-Generated Schemas\" to show five schema types</p> </li> <li> <p>Serializer Documentation (docs/api/models/serializers.md):</p> </li> <li>Added <code>schema_detail</code> to Meta configuration options</li> <li>New \"Detail Schema for Retrieve Endpoint\" section</li> <li> <p>Updated schema generation examples to include <code>generate_detail_s()</code></p> </li> <li> <p>APIViewSet Documentation (docs/api/views/api_view_set.md):</p> </li> <li>Updated CRUD endpoints table to show retrieve uses <code>schema_detail</code></li> <li>Added <code>schema_detail</code> to Core Attributes table</li> <li>New \"Detail Schema for Retrieve Endpoint\" section with examples</li> <li>Updated automatic schema generation section</li> <li>Added <code>serializer_class</code> documentation for <code>M2MRelationSchema</code></li> <li>Added tabbed examples for <code>related_schema</code> vs <code>serializer_class</code> usage</li> </ul> \ud83e\uddea Tests <ul> <li>New Detail Schema Test Cases:</li> <li> <p><code>DetailSerializerTestCase</code> in tests/test_serializers.py:</p> <ul> <li><code>test_generate_detail_schema_with_serializer()</code> - Basic detail schema generation</li> <li><code>test_generate_detail_schema_returns_none_when_not_configured()</code> - None when not configured</li> <li><code>test_detail_schema_with_relations()</code> - Relations in detail schema</li> <li><code>test_detail_schema_with_custom_fields()</code> - Custom fields support</li> <li><code>test_detail_schema_with_optionals()</code> - Optional fields support</li> </ul> </li> <li> <p><code>DetailSchemaModelSerializerTestCase</code> in tests/views/test_viewset.py:</p> <ul> <li><code>test_read_schema_has_minimal_fields()</code> - ReadSerializer has minimal fields</li> <li><code>test_detail_schema_has_extended_fields()</code> - DetailSerializer has extended fields</li> <li><code>test_get_retrieve_schema_returns_detail()</code> - Retrieve uses detail schema</li> <li><code>test_get_schemas_returns_four_tuple()</code> - get_schemas returns 4-tuple</li> </ul> </li> <li> <p><code>DetailSchemaSerializerTestCase</code> - Tests for Serializer class with schema_detail</p> </li> <li> <p><code>DetailSchemaFallbackTestCase</code> - Tests fallback to schema_out when no detail defined</p> </li> <li> <p>New M2M serializer_class Test Cases:</p> </li> <li><code>M2MRelationSchemaSerializerClassTestCase</code> - Tests M2M with serializer_class</li> <li> <p><code>M2MRelationSchemaValidationTestCase</code>:</p> <ul> <li><code>test_serializer_class_with_plain_model_succeeds()</code></li> <li><code>test_model_serializer_auto_generates_related_schema()</code></li> <li><code>test_serializer_class_with_model_serializer_raises_error()</code></li> <li><code>test_plain_model_without_serializer_class_or_related_schema_raises_error()</code></li> <li><code>test_explicit_related_schema_takes_precedence()</code></li> </ul> </li> <li> <p>New Test Model:</p> </li> <li><code>TestModelSerializerWithDetail</code> in tests/test_app/models.py</li> <li> <p>Demonstrates separate <code>ReadSerializer</code> and <code>DetailSerializer</code> configurations</p> </li> <li> <p>Updated Existing Tests:</p> </li> <li>All <code>schemas</code> property definitions updated to return 4-tuple format</li> <li><code>test_get_schemas</code> updated to expect 4 elements instead of 3</li> <li>Refactored <code>ManyToManyAPITestCase</code> into <code>Tests.BaseManyToManyAPITestCase</code> base class</li> </ul> \ud83d\udd27 Internal Changes <ul> <li>Schema Mapping Updates:</li> <li><code>_SCHEMA_META_MAP</code> now includes <code>\"detail\": \"DetailSerializer\"</code> for ModelSerializer</li> <li><code>_SERIALIZER_CONFIG_MAP</code> now includes <code>\"detail\": \"detail\"</code> for Serializer</li> <li> <p><code>_get_serializer_config()</code> updated to handle <code>\"detail\"</code> case</p> </li> <li> <p>ModelSerializer Changes:</p> </li> <li>New <code>DetailSerializer</code> inner class with <code>fields</code>, <code>customs</code>, <code>optionals</code>, <code>excludes</code> attributes</li> <li><code>_generate_model_schema()</code> updated to handle <code>\"Detail\"</code> schema type</li> <li> <p>Schema naming: <code>\"Out\"</code> \u2192 <code>{model}SchemaOut</code>, <code>\"Detail\"</code> \u2192 <code>{model}DetailSchemaOut</code></p> </li> <li> <p>Serializer.Meta Changes:</p> </li> <li>New <code>schema_detail: Optional[SchemaModelConfig]</code> attribute</li> <li> <p><code>model_dump()</code> now uses detail schema when available for single object serialization</p> </li> <li> <p>M2MRelationSchema Changes:</p> </li> <li>New <code>serializer_class: Optional[SerializerMeta]</code> field</li> <li><code>validate_related_schema()</code> validator updated to handle serializer_class</li> <li>ManyToManyAPI updated to pass serializer_class to ModelUtil</li> </ul> \ud83d\ude80 Use Cases &amp; Examples Detail Schema for Performance Optimization <p>```python from ninja_aio.models import ModelSerializer from django.db import models</p> <p>class Article(ModelSerializer):     title = models.CharField(max_length=200)     summary = models.TextField()     content = models.TextField()     author = models.ForeignKey(User, on_delete=models.CASCADE)     tags = models.ManyToManyField(Tag)     view_count = models.IntegerField(default=0)</p> <pre><code>class ReadSerializer:\n    # List view: minimal fields for performance\n    fields = [\"id\", \"title\", \"summary\", \"author\"]\n\nclass DetailSerializer:\n    # Detail view: all fields including expensive relations\n    fields = [\"id\", \"title\", \"summary\", \"content\", \"author\", \"tags\", \"view_count\"]\n    customs = [\n        (\"reading_time\", int, lambda obj: len(obj.content.split()) // 200),\n    ]\n</code></pre> <p>@api.viewset(model=Article) class ArticleViewSet(APIViewSet):     pass  # Schemas auto-generated from model ```</p> <p>Endpoint Behavior: - <code>GET /articles/</code> returns <code>[{\"id\": 1, \"title\": \"...\", \"summary\": \"...\", \"author\": {...}}, ...]</code> - <code>GET /articles/1</code> returns <code>{\"id\": 1, \"title\": \"...\", \"summary\": \"...\", \"content\": \"...\", \"author\": {...}, \"tags\": [...], \"view_count\": 1234, \"reading_time\": 5}</code></p> Detail Schema with Serializer Class <p>```python from ninja_aio.models import serializers</p> <p>class ArticleSerializer(serializers.Serializer):     class Meta:         model = models.Article         schema_out = serializers.SchemaModelConfig(             # List view: minimal fields             fields=[\"id\", \"title\", \"summary\"]         )         schema_detail = serializers.SchemaModelConfig(             # Detail view: all fields             fields=[\"id\", \"title\", \"summary\", \"content\", \"author\", \"tags\"],             customs=[(\"reading_time\", int, lambda obj: len(obj.content.split()) // 200)]         )</p> <p>@api.viewset(model=models.Article) class ArticleViewSet(APIViewSet):     serializer_class = ArticleSerializer ```</p> M2M with serializer_class <p>```python from ninja_aio.models import serializers from ninja_aio.schemas import M2MRelationSchema</p> <p>class TagSerializer(serializers.Serializer):     class Meta:         model = Tag         schema_out = serializers.SchemaModelConfig(fields=[\"id\", \"name\"])</p> <p>@api.viewset(model=Article) class ArticleViewSet(APIViewSet):     m2m_relations = [         M2MRelationSchema(             model=Tag,                        # plain Django model             related_name=\"tags\",             serializer_class=TagSerializer,   # auto-generates related_schema             add=True,             remove=True,             get=True,         )     ] ```</p> \ud83d\udd0d Migration Guide Using Detail Schemas <p>No migration required! Detail schema support is fully backward compatible:</p> <p>```python</p> <p>class Article(ModelSerializer):     class ReadSerializer:         fields = [\"id\", \"title\", \"content\"]  # Used for both list AND retrieve</p> <p>class Article(ModelSerializer):     class ReadSerializer:         fields = [\"id\", \"title\"]  # Used for list only</p> <pre><code>class DetailSerializer:\n    fields = [\"id\", \"title\", \"content\", \"author\", \"tags\"]  # Used for retrieve\n</code></pre> <p>```</p> Using serializer_class in M2MRelationSchema <p>```python</p> <p>M2MRelationSchema(     model=Tag,     related_name=\"tags\",     related_schema=TagOut,  # Must define this schema manually )</p> <p>M2MRelationSchema(     model=Tag,     related_name=\"tags\",     serializer_class=TagSerializer,  # Auto-generates related_schema! ) ```</p> Updating Custom ViewSet Subclasses <p>If you override <code>get_schemas()</code>, update to return 4-tuple:</p> <p>```python</p> <p>def get_schemas(self):     return (schema_out, schema_in, schema_update)</p> <p>def get_schemas(self):     return (schema_out, schema_detail, schema_in, schema_update) ```</p> \ud83c\udfaf When to Use Detail Schema <ul> <li>Performance Optimization: Return minimal fields in list views, full details in retrieve</li> <li>API Design: Clients get summaries in lists, full objects on individual requests</li> <li>Expensive Relations: Avoid loading M2M/reverse relations for list endpoints</li> <li>Computed Fields: Only compute expensive fields for single object retrieval</li> <li>Bandwidth Optimization: Reduce payload size for list responses</li> </ul> \ud83d\udcca Performance Benefits <p>| Scenario | Without Detail Schema | With Detail Schema | |----------|----------------------|-------------------| | List 100 articles | Returns 100 \u00d7 full content | Returns 100 \u00d7 summary only | | Load M2M tags | Loaded for all 100 items | Only loaded for single retrieve | | Computed fields | Calculated for all items | Only calculated on retrieve | | Response size | Large (full content) | Optimized per endpoint |</p> \u26a0\ufe0f Important Notes <ul> <li>Fallback Behavior: If <code>DetailSerializer</code>/<code>schema_detail</code> not defined, retrieve uses <code>schema_out</code></li> <li>Schema Generation: <code>generate_detail_s()</code> returns <code>None</code> if no detail config exists</li> <li>Backward Compatibility: All existing code works without changes</li> <li>4-Tuple Return: <code>get_schemas()</code> now returns 4 values instead of 3</li> <li>M2M Validation: Cannot use <code>serializer_class</code> with <code>ModelSerializer</code> models</li> </ul> \ud83d\ude4f Acknowledgments <p>This release focuses on: - Enhanced API design flexibility with separate list/detail schemas - Performance optimization for list endpoints - Better M2M relation configuration options - Improved code organization and maintainability</p> \ud83d\udd17 Links <ul> <li>Documentation</li> <li>GitHub Repository</li> <li>Issue Tracker</li> <li>v2.7.0 Release Notes</li> </ul> \ud83d\udce6 Quick Start with Detail Schema <p>```python from ninja_aio.models import ModelSerializer from ninja_aio.views import APIViewSet from ninja_aio import NinjaAIO from django.db import models</p> <p>api = NinjaAIO(title=\"My API\")</p> <p>class Article(ModelSerializer):     title = models.CharField(max_length=200)     summary = models.TextField()     content = models.TextField()     author = models.ForeignKey(User, on_delete=models.CASCADE)     tags = models.ManyToManyField(Tag)</p> <pre><code>class ReadSerializer:\n    fields = [\"id\", \"title\", \"summary\"]  # Minimal for list\n\nclass DetailSerializer:\n    fields = [\"id\", \"title\", \"summary\", \"content\", \"author\", \"tags\"]  # Full for retrieve\n</code></pre> <p>@api.viewset(model=Article) class ArticleViewSet(APIViewSet):     pass</p> <p>```</p> Version History <p>For older versions, please refer to the GitHub releases page.</p>v2.7.0diff2026-01-13Release notes [v2.7.0] - 2026-01-13 \u2728 Added <ul> <li>Union Type Support for Polymorphic Relations:</li> <li><code>relations_serializers</code> now accepts <code>Union[SerializerA, SerializerB]</code> to handle polymorphic relationships</li> <li>Enables flexible handling of generic foreign keys, content types, and multi-model relations</li> <li>Direct class references: <code>Union[SerializerA, SerializerB]</code></li> <li>String references: <code>Union[\"SerializerA\", \"SerializerB\"]</code></li> <li>Mixed references: <code>Union[SerializerA, \"SerializerB\"]</code></li> <li>Absolute import paths: <code>Union[\"myapp.serializers.SerializerA\", SerializerB]</code></li> <li>Lazy resolution of union members supports forward/circular dependencies</li> <li> <p>Schema generator creates union of all possible schemas automatically</p> </li> <li> <p>Absolute Import Path Support for String References:</p> </li> <li>String references now support absolute import paths using dot notation</li> <li>Example: <code>\"myapp.serializers.UserSerializer\"</code> or <code>\"users.serializers.UserSerializer\"</code></li> <li>Enables cross-module serializer references without circular import issues</li> <li>Automatic module importing when needed (uses <code>importlib.import_module()</code>)</li> <li>Resolves lazily when schemas are generated</li> <li>Works seamlessly with Union types</li> </ul> \ud83d\udee0 Changed <ul> <li>Enhanced Serializer Reference Resolution:</li> <li>Now handles Union types by recursively resolving each member</li> <li>Handles ForwardRef objects created by string type hints in unions (e.g., <code>Union[\"StringType\"]</code>)</li> <li> <p>Optimizes single-type unions by returning the single type directly</p> </li> <li> <p>Enhanced Relation Schema Generation:</p> </li> <li>Generates union schemas when serializer reference is a Union type</li> <li>Maintains full backward compatibility with single serializer references</li> <li> <p>Automatically filters out None schemas from union members</p> </li> <li> <p>Updated Type Hints:</p> </li> <li>All serializer methods updated to reflect Union support</li> <li>Better type safety for Union[Schema, ...] return values</li> <li>Clearer documentation of acceptable input types</li> </ul> \ud83d\udcdd Documentation <ul> <li>Comprehensive Union Types Documentation in docs/api/models/serializers.md:</li> <li> <p>New \"Union Types for Polymorphic Relations\" section:</p> <ul> <li>Complete explanation of Union support with real-world examples</li> <li>Basic polymorphic example with Video and Image serializers</li> <li>All four Union type format variations documented with code samples</li> <li>Use cases: polymorphic relations, flexible APIs, gradual migrations, multi-tenant systems</li> <li>Complete polymorphic example using Django's GenericForeignKey</li> <li>BlogPost/Product/Event example showing complex multi-model relations</li> </ul> </li> <li> <p>New \"String Reference Formats\" section:</p> <ul> <li>Local class name format: <code>\"ArticleSerializer\"</code></li> <li>Absolute import path format: <code>\"myapp.serializers.ArticleSerializer\"</code></li> <li>Requirements and resolution behavior documented</li> <li>Cross-module references example with circular dependencies</li> </ul> </li> <li> <p>Enhanced Configuration Section:</p> <ul> <li><code>relations_serializers</code> parameter updated to document Union support</li> <li>Clear explanation: \"Serializer class, string reference, or Union of serializers\"</li> <li>Forward/circular dependencies and polymorphic relations highlighted</li> <li>Updated comparison table showing Union support feature</li> </ul> </li> <li> <p>Updated Key Features:</p> <ul> <li>Added Union types for polymorphic relations to key features list</li> <li>Updated notes to mention Union type lazy resolution</li> <li>Added note about schema generator creating unions</li> </ul> </li> <li> <p>Code Examples and Best Practices:</p> </li> <li>Video/Image comment example for basic polymorphic relations</li> <li>BlogPost/Product/Event example for complex GenericForeignKey usage</li> <li>Cross-module circular reference example (Article \u2194 User)</li> <li>All four Union format variations with syntax examples</li> </ul> \ud83e\uddea Tests <ul> <li> <p>New Comprehensive Test Suite - <code>UnionSerializerTestCase</code> in tests/test_serializers.py</p> </li> <li> <p>Module-Level Test Serializers:</p> </li> <li><code>AltSerializer</code> - Alternative serializer with different field set (id, name)</li> <li><code>AltStringSerializer</code> - String reference test serializer (id, description)</li> <li><code>MixedAltSerializer</code> - Mixed reference test serializer (id, name, description)</li> <li><code>LocalTestSerializer</code> - Local reference test serializer (id only)</li> </ul> \ud83d\udd27 Internal Changes <ul> <li>Python 3.10+ Compatibility Fix:</li> <li>Union types created using <code>Union[tuple]</code> syntax for compatibility</li> <li>Replaced incompatible <code>reduce(or_, resolved_types)</code> pattern</li> <li>Works correctly across Python 3.10, 3.11, 3.12+</li> <li>No dependency on <code>functools.reduce</code> or <code>operator.or_</code></li> <li> <p>Uses Python's typing system to expand <code>Union[tuple]</code> automatically</p> </li> <li> <p>Code Organization:</p> </li> <li>Extracted string resolution logic into dedicated <code>_resolve_string_reference()</code> method</li> <li>Extracted union schema generation into dedicated <code>_generate_union_schema()</code> method</li> <li>Improved separation of concerns and code reusability</li> <li>Better error messages with full import paths in exceptions</li> </ul> \ud83d\ude80 Use Cases &amp; Examples Basic Polymorphic Relations <p>```python from typing import Union from ninja_aio.models import serializers</p> <p>class VideoSerializer(serializers.Serializer):     class Meta:         model = models.Video         schema_out = serializers.SchemaModelConfig(             fields=[\"id\", \"title\", \"duration\", \"url\"]         )</p> <p>class ImageSerializer(serializers.Serializer):     class Meta:         model = models.Image         schema_out = serializers.SchemaModelConfig(             fields=[\"id\", \"title\", \"width\", \"height\", \"url\"]         )</p> <p>class CommentSerializer(serializers.Serializer):     class Meta:         model = models.Comment         schema_out = serializers.SchemaModelConfig(             fields=[\"id\", \"text\", \"content_object\"]         )         relations_serializers = {             \"content_object\": Union[VideoSerializer, ImageSerializer],         } ```</p> Cross-Module References <p>```python</p> <p>class ArticleSerializer(serializers.Serializer):     class Meta:         model = models.Article         schema_out = serializers.SchemaModelConfig(             fields=[\"id\", \"title\", \"author\"]         )         relations_serializers = {             \"author\": \"users.serializers.UserSerializer\",  # Absolute path         }</p> <p>class UserSerializer(serializers.Serializer):     class Meta:         model = models.User         schema_out = serializers.SchemaModelConfig(             fields=[\"id\", \"username\", \"articles\"]         )         relations_serializers = {             \"articles\": \"myapp.serializers.ArticleSerializer\",  # Circular ref!         } ```</p> Generic Foreign Keys <p>```python from django.contrib.contenttypes.fields import GenericForeignKey from typing import Union</p> <p>class CommentSerializer(serializers.Serializer):     class Meta:         model = Comment         schema_out = serializers.SchemaModelConfig(             fields=[\"id\", \"text\", \"created_at\", \"content_object\"]         )         relations_serializers = {             \"content_object\": Union[                 BlogPostSerializer,                 ProductSerializer,                 EventSerializer             ],         } ```</p> \ud83d\udd0d Migration Guide Using Union Types <p>No migration needed! Union support is fully backward compatible:</p> <p>```python</p> <p>class MySerializer(serializers.Serializer):     class Meta:         model = MyModel         relations_serializers = {             \"author\": AuthorSerializer,  # \u2705 Still works         }</p> <p>class MySerializer(serializers.Serializer):     class Meta:         model = MyModel         relations_serializers = {             \"content\": Union[VideoSerializer, ImageSerializer],  # \u2705 New!         } ```</p> Using Absolute Import Paths <p>Update string references to use absolute paths for cross-module references:</p> <p>```python</p> <p>relations_serializers = {     \"author\": \"AuthorSerializer\",  # Must be in same module }</p> <p>relations_serializers = {     \"author\": \"users.serializers.AuthorSerializer\",  # \u2705 Cross-module! } ```</p> String Reference Formats <p>Both formats are supported:</p> <p>```python relations_serializers = {     # Local reference (same module)     \"field1\": \"LocalSerializer\",</p> <pre><code># Absolute import path (any module)\n\"field2\": \"myapp.serializers.RemoteSerializer\",\n\n# Union with mixed formats\n\"field3\": Union[\"LocalSerializer\", \"myapp.other.RemoteSerializer\"],\n</code></pre> <p>} ```</p> \ud83c\udfaf When to Use Union Types <ul> <li>Polymorphic Relations: Generic foreign keys, Django ContentType relations</li> <li>Flexible APIs: Different response formats based on runtime type</li> <li>Gradual Migrations: Transitioning between serializer implementations</li> <li>Multi-Tenant Systems: Different serialization per tenant</li> <li>Dynamic Content: CMS systems with multiple content types</li> <li>Activity Feeds: Mixed content types in single endpoint</li> </ul> \ud83d\udcca Performance Notes <ul> <li>Lazy Resolution: Union members resolved only when schemas generated (no startup overhead)</li> <li>Schema Caching: Generated schemas can be cached for better performance</li> <li>Memory Efficient: Only generates schemas for types actually used</li> <li>Import Optimization: Absolute paths only import modules when needed</li> </ul> \u26a0\ufe0f Important Notes <ul> <li>String References: Resolve within same module by default; use absolute paths for cross-module</li> <li>Union Schema Generation: Creates union of all possible schemas from union members</li> <li>Backward Compatibility: All existing code continues to work without changes</li> <li>Python Version: Requires Python 3.10+ (Union syntax compatibility)</li> <li>Type Validation: Union types provide type hints but runtime validation depends on your model logic</li> </ul> \ud83d\ude4f Acknowledgments <p>This release focuses on: - Enhanced flexibility for polymorphic relationships - Better support for complex project architectures - Improved developer experience with cross-module references - Python 3.10+ compatibility and modern typing features</p> \ud83d\udd17 Links <ul> <li>Documentation</li> <li>GitHub Repository</li> <li>Issue Tracker</li> <li>v2.6.1 Release Notes</li> </ul> \ud83d\udce6 Quick Start with Union Types <p>```python from typing import Union from ninja_aio.models import serializers</p> <p>class VideoSerializer(serializers.Serializer):     class Meta:         model = Video         schema_out = serializers.SchemaModelConfig(fields=[\"id\", \"title\", \"url\"])</p> <p>class ImageSerializer(serializers.Serializer):     class Meta:         model = Image         schema_out = serializers.SchemaModelConfig(fields=[\"id\", \"title\", \"url\"])</p> <p>class CommentSerializer(serializers.Serializer):     class Meta:         model = Comment         schema_out = serializers.SchemaModelConfig(             fields=[\"id\", \"text\", \"content_object\"]         )         relations_serializers = {             \"content_object\": Union[VideoSerializer, ImageSerializer],         }</p> <p>@api.viewset(model=Comment) class CommentViewSet(APIViewSet):     serializer_class = CommentSerializer     # Union types work automatically! ```</p> Version History <p>For older versions, please refer to the GitHub releases page.</p>v2.6.1diff2026-01-12Release notes [v2.6.1] - 2026-01-12 \u2728 Added <ul> <li>String Reference Support for Relations:</li> <li><code>relations_serializers</code> now accepts string references (e.g., <code>\"ArticleSerializer\"</code>) in addition to class references</li> <li>Enables forward references and circular dependencies between serializers</li> <li> <p>Lazy resolution of serializer references when schemas are generated</p> </li> <li> <p>New Internal Methods:</p> </li> <li><code>BaseSerializer._resolve_serializer_reference()</code> - Resolves string or class serializer references</li> <li><code>BaseSerializer._resolve_relation_schema()</code> - Centralized relation schema resolution logic</li> </ul> \ud83d\udee0 Changed <ul> <li>Schema Generation Lifecycle:</li> <li>Removed eager schema generation from <code>Serializer.__init_subclass__()</code></li> <li>Schemas are now generated on-demand via explicit calls to <code>generate_*()</code> methods</li> <li>Removed cached schema properties (<code>.schema_in</code>, <code>.schema_out</code>, <code>.schema_update</code>, <code>.schema_related</code>)</li> <li> <p>Breaking: Must use <code>generate_create_s()</code>, <code>generate_read_s()</code>, etc. instead of accessing properties</p> </li> <li> <p>Internal Refactoring:</p> </li> <li>Replaced <code>match/case</code> with <code>if/elif</code> statements in <code>_generate_model_schema()</code> for better readability</li> <li>Added configuration mapping dictionaries (<code>_SERIALIZER_CONFIG_MAP</code>) to simplify lookups</li> <li>Consolidated duplicate schema resolution logic in relation handling methods</li> <li> <p>Improved code organization with clearer comments and structure</p> </li> <li> <p>APIViewSet Integration:</p> </li> <li>Added <code>serializer</code> instance property initialized from <code>serializer_class()</code></li> <li>Better integration with on-demand schema generation</li> </ul> \ud83d\udcdd Documentation <ul> <li>Updated Serializer Documentation:</li> <li>Added \"String References for Forward/Circular Dependencies\" section with examples</li> <li>Updated \"Schema Generation\" section to clarify on-demand generation</li> <li>Removed outdated references to eager schema generation</li> <li>Updated comparison table: \"Auto-binding\" \u2192 \"Schema generation\"</li> <li> <p>Enhanced configuration section with bold formatting and clearer descriptions</p> </li> <li> <p>Key Documentation Changes:</p> </li> <li>Emphasized that <code>generate_*()</code> methods must be called explicitly</li> <li>Documented string reference requirements (same module, lazy resolution)</li> <li>Added circular dependency example with <code>AuthorSerializer</code> \u2194 <code>ArticleSerializer</code></li> </ul> \u26a0 Breaking Changes &amp; Migration Notes Removed Schema Properties <p>Schema properties have been removed from <code>Serializer</code> class. You must now explicitly call generation methods:</p> <p>```python</p> <p>ArticleSerializer.schema_in       # \u274c AttributeError ArticleSerializer.schema_out      # \u274c AttributeError ArticleSerializer.schema_update   # \u274c AttributeError ArticleSerializer.schema_related  # \u274c AttributeError</p> <p>ArticleSerializer.generate_create_s()   # \u2705 Returns create schema ArticleSerializer.generate_read_s()     # \u2705 Returns read schema ArticleSerializer.generate_update_s()   # \u2705 Returns update schema ArticleSerializer.generate_related_s()  # \u2705 Returns related schema ```</p> <p>Note: This change typically doesn't affect user code since these methods are called internally by <code>APIViewSet</code>. Only relevant if you're calling these methods directly.</p> \ud83d\udd0d Migration Guide 1. Update Schema Access in Custom Code <p>If you're directly accessing schema properties, update to use generation methods:</p> <p>```python</p> <p>class ArticleViewSet(APIViewSet):     def get_schemas(self):         return {             \"in\": self.serializer_class.schema_in,      # \u274c No longer works             \"out\": self.serializer_class.schema_out,    # \u274c No longer works         }</p> <p>class ArticleViewSet(APIViewSet):     def get_schemas(self):         return {             \"in\": self.serializer_class.generate_create_s(),   # \u2705 Explicit generation             \"out\": self.serializer_class.generate_read_s(),    # \u2705 Explicit generation         } ```</p> 2. Use String References for Circular Dependencies <p>Take advantage of string references to simplify circular dependencies:</p> <p>```python</p> <p>class AuthorSerializer(serializers.Serializer):     class Meta:         model = models.Author         schema_out = serializers.SchemaModelConfig(             fields=[\"id\", \"name\", \"articles\"]         )         # Had to carefully order class definitions or use late binding</p> <p>class AuthorSerializer(serializers.Serializer):     class Meta:         model = models.Author         schema_out = serializers.SchemaModelConfig(             fields=[\"id\", \"name\", \"articles\"]         )         relations_serializers = {             \"articles\": \"ArticleSerializer\",  # \u2705 Forward reference         }</p> <p>class ArticleSerializer(serializers.Serializer):     class Meta:         model = models.Article         schema_out = serializers.SchemaModelConfig(             fields=[\"id\", \"title\", \"author\"]         )         relations_serializers = {             \"author\": \"AuthorSerializer\",  # \u2705 Circular reference works!         } ```</p> <p>String Reference Requirements: - Must be the exact class name as a string - Serializer must be defined in the same module - Resolution happens lazily when <code>generate_*()</code> is called - Both forward and circular references are supported</p> 3. Schema Generation Best Practices <p>In APIViewSet (no changes needed): ```python</p> <p>@api.viewset(model=Article) class ArticleViewSet(APIViewSet):     serializer_class = ArticleSerializer     # No changes needed - works automatically ```</p> <p>In Custom Code (call generate methods): ```python</p> <p>from ninja import Router</p> <p>router = Router()</p> <p>@router.post(\"/articles/\", response=ArticleSerializer.generate_read_s()) async def create_article(request, payload: ArticleSerializer.generate_create_s()):     serializer = ArticleSerializer()     instance = await serializer.create(payload.model_dump())     return await serializer.model_dump(instance) ```</p> <p>Caching Schemas (if needed for performance): ```python</p> <p>ARTICLE_CREATE_SCHEMA = ArticleSerializer.generate_create_s() ARTICLE_READ_SCHEMA = ArticleSerializer.generate_read_s()</p> <p>@router.post(\"/articles/\", response=ARTICLE_READ_SCHEMA) async def create_article(payload: ARTICLE_CREATE_SCHEMA):     # Use cached schemas     pass ```</p> 4. Complete Migration Example <p>Here's a complete before/after example:</p> <p>```python</p> <p>from ninja_aio.models import serializers from ninja_aio import NinjaAIO from ninja_aio.views import APIViewSet</p> <p>class AuthorSerializer(serializers.Serializer):     class Meta:         model = models.Author         schema_out = serializers.SchemaModelConfig(             fields=[\"id\", \"name\"]         )</p> <p>class ArticleSerializer(serializers.Serializer):     class Meta:         model = models.Article         schema_out = serializers.SchemaModelConfig(             fields=[\"id\", \"title\", \"author\"]         )         relations_serializers = {             \"author\": AuthorSerializer,  # Required class ordering         }</p> <p>create_schema = ArticleSerializer.schema_in      # \u274c read_schema = ArticleSerializer.schema_out       # \u274c</p> <p>from ninja_aio.models import serializers from ninja_aio import NinjaAIO from ninja_aio.views import APIViewSet</p> <p>class AuthorSerializer(serializers.Serializer):     class Meta:         model = models.Author         schema_out = serializers.SchemaModelConfig(             fields=[\"id\", \"name\", \"articles\"]         )         relations_serializers = {             \"articles\": \"ArticleSerializer\",  # \u2705 String reference         }</p> <p>class ArticleSerializer(serializers.Serializer):     class Meta:         model = models.Article         schema_out = serializers.SchemaModelConfig(             fields=[\"id\", \"title\", \"author\"]         )         relations_serializers = {             \"author\": \"AuthorSerializer\",  # \u2705 Circular reference!         }</p> <p>create_schema = ArticleSerializer.generate_create_s()  # \u2705 read_schema = ArticleSerializer.generate_read_s()      # \u2705</p> <p>api = NinjaAIO()</p> <p>@api.viewset(model=Article) class ArticleViewSet(APIViewSet):     serializer_class = ArticleSerializer     # Automatically works with on-demand generation ```</p> \ud83d\udc1b Bug Fixes <ul> <li>Fixed lazy resolution issues with forward and circular serializer references</li> <li>Improved error messages when string references cannot be resolved</li> <li>Corrected <code>model_dump()</code> and <code>models_dump()</code> to use explicit schema generation</li> <li>Fixed potential issues with <code>model_util</code> vs <code>util</code> attribute naming</li> </ul> \ud83d\ude80 Performance Improvements <ul> <li>Reduced Initialization Overhead: Schemas only generated when actually needed</li> <li>Memory Efficiency: Unused schemas are never created</li> <li>Lazy Resolution: String references resolved on-demand, reducing startup time</li> <li>Faster Imports: Removed eager schema generation from module import time</li> </ul> \ud83d\udcca Code Quality Improvements <ul> <li>Reduced Code Duplication:</li> <li>Extracted common relation resolution logic into <code>_resolve_relation_schema()</code></li> <li>Consolidated duplicate code in <code>_build_schema_reverse_rel()</code> and <code>_build_schema_forward_rel()</code></li> <li> <p>Reduced relation handling code by ~40 lines</p> </li> <li> <p>Improved Maintainability:</p> </li> <li>Replaced <code>match/case</code> with clearer <code>if/elif</code> statements</li> <li>Added configuration mapping dictionaries for cleaner lookups</li> <li>Better code organization with descriptive comments</li> <li> <p>Consistent use of <code>any()</code> for empty checks</p> </li> <li> <p>Better Readability:</p> </li> <li>Flattened nesting in <code>_generate_model_schema()</code></li> <li>Clearer separation between special cases and standard logic</li> <li>Improved docstrings and parameter descriptions</li> <li>More descriptive variable names</li> </ul> \ud83d\ude4f Acknowledgments <p>This release focuses on: - Architectural improvements for forward/circular dependency support - Cleaner, more maintainable internal code structure - On-demand resource generation for better performance - Enhanced developer experience with string references</p> \ud83d\udcdd Notes <ul> <li> <p>Schema Generation: While properties were removed, <code>APIViewSet</code> automatically calls <code>generate_*()</code> methods, so most applications won't need code changes</p> </li> <li> <p>Performance: On-demand generation typically improves startup time. If you need schemas multiple times, consider caching them at module level</p> </li> <li> <p>String References: Only resolve within the same module. For cross-module references, use direct class imports</p> </li> <li> <p>Backward Compatibility: Code using <code>APIViewSet</code> continues to work without changes. Direct schema property access will raise <code>AttributeError</code></p> </li> <li> <p>Internal Refactoring: This release includes significant internal refactoring for code quality without changing public APIs (except removal of schema properties)</p> </li> </ul> \ud83d\udd17 Links <ul> <li>Documentation</li> <li>GitHub Repository</li> <li>Issue Tracker</li> <li>v2.5.0 Release Notes</li> </ul> \ud83d\udce6 Upgrade Checklist <p>Use this checklist when upgrading from v2.5.0 to v2.6.0:</p> <ul> <li>[ ] Search codebase for <code>.schema_in</code>, <code>.schema_out</code>, <code>.schema_update</code>, <code>.schema_related</code> property access</li> <li>[ ] Replace with <code>generate_create_s()</code>, <code>generate_read_s()</code>, <code>generate_update_s()</code>, <code>generate_related_s()</code> calls</li> <li>[ ] Update any circular serializer references to use string references</li> <li>[ ] Review custom <code>create()</code> and <code>update()</code> method implementations (if any)</li> <li>[ ] Test all CRUD endpoints to ensure proper functionality</li> <li>[ ] Update any schema caching logic to use explicit generation</li> <li>[ ] Review and update API documentation if it references old property access</li> </ul> v2.5.0diff2026-01-12Release notes [v2.5.0] - 2026-01-12 \u2728 Added <ul> <li>APIViewSet Enhancements:</li> <li><code>model_verbose_name</code> and <code>model_verbose_name_plural</code> attributes for display name customization</li> <li> <p>Automatic transaction wrapping on create, update, and delete operations</p> </li> <li> <p>ModelUtil Query Methods:</p> </li> <li>New properties:<ul> <li><code>with_serializer</code> - Check if serializer_class is attached</li> <li><code>pk_field_type</code> - Python type corresponding to the primary key field</li> <li><code>model_name</code> - Django internal model name</li> </ul> </li> </ul> \ud83d\udee0 Changed <ul> <li>APIViewSet:</li> <li>CRUD views now automatically decorated with <code>@aatomic</code> for transactional integrity</li> <li> <p>Enhanced <code>get_schemas()</code> method for unified schema generation from both ModelSerializer and Serializer</p> </li> <li> <p>ModelUtil:</p> </li> <li> <p>Query optimization merging logic improved to respect both model and serializer configurations</p> </li> <li> <p>Serializer Lifecycle Hooks:</p> </li> <li>All Serializer hooks now consistently receive <code>instance</code> parameter</li> <li>Inline execution of before/after save hooks integrated with <code>@aatomic</code> decorator</li> <li>Hook signatures standardized: <code>custom_actions(payload, instance)</code>, <code>post_create(instance)</code>, <code>before_save(instance)</code>, etc.</li> </ul> \ud83d\udcdd Documentation <ul> <li>New Documentation Pages:</li> <li>Transaction Management section in APIViewSet docs</li> <li>Extra Decorators section with examples and configuration</li> <li>Enhanced ModelUtil properties documentation</li> <li> <p>Query method parameter documentation with detailed examples</p> </li> <li> <p>Enhanced Content:</p> </li> <li>APIViewSet Core Attributes table updated with new fields</li> <li>Serializer lifecycle hooks section with complete signature examples</li> <li>ModelUtil method signatures with all parameters documented</li> <li>CRUD operation flows documented for Serializer pattern</li> </ul> \u26a0 Breaking Changes &amp; Migration Notes Transaction Behavior (New Default) <p>Create, update, and delete operations are now automatically wrapped in database transactions:</p> <p>```python</p> <p>@api.viewset(model=Article) class ArticleViewSet(APIViewSet):     pass  # create/update/delete wrapped in @aatomic ```</p> <p>Migration: If you were manually managing transactions in lifecycle hooks, you may encounter nested transaction issues. Remove manual transaction management:</p> <p>```python</p> <p>async def post_create(self, instance):     async with transaction.atomic():  # Remove this         await AuditLog.objects.acreate(...)</p> <p>async def post_create(self, instance):     # Transaction already managed by @aatomic     await AuditLog.objects.acreate(...) ```</p> Serializer Hook Signatures <p>Added Serializer hooks signatures, they are standardized to always receive <code>instance</code>:</p> <p>```python</p> <p>class MySerializer(Serializer):     async def custom_actions(self, payload, instance):         # instance parameter required         pass</p> <pre><code>async def post_create(self, instance):\n    # instance parameter required\n    pass\n\ndef before_save(self, instance):\n    # instance parameter required\n    pass\n\ndef after_save(self, instance):\n    # instance parameter required\n    pass\n\ndef on_delete(self, instance):\n    # instance parameter required\n    pass\n</code></pre> <p>```</p> \ud83d\udd0d Migration Guide 1. Updating Serializer Lifecycle Hooks <p>If you're using Serializer (Meta-driven pattern), update hook signatures to receive <code>instance</code> parameter:</p> <p>```python from ninja_aio.models import serializers from asgiref.sync import sync_to_async</p> <p>class ArticleSerializer(serializers.Serializer):     class Meta:         model = Article         schema_in = serializers.SchemaModelConfig(             fields=[\"title\", \"content\", \"author\"],             customs=[(\"send_notification\", bool, True)]         )         schema_out = serializers.SchemaModelConfig(             fields=[\"id\", \"title\", \"content\", \"author\", \"created_at\"]         )</p> <pre><code># Async hooks - receive instance parameter\nasync def custom_actions(self, payload, instance):\n    \"\"\"Execute custom logic after field assignment.\"\"\"\n    if payload.get(\"send_notification\"):\n        # Access instance fields\n        await send_email(\n            instance.author.email,\n            f\"Article created: {instance.title}\"\n        )\n\nasync def post_create(self, instance):\n    \"\"\"Hook after first save (creation only).\"\"\"\n    await AuditLog.objects.acreate(\n        action=\"article_created\",\n        article_id=instance.id,\n        user_id=instance.author_id\n    )\n\n# Sync hooks - also receive instance parameter\ndef before_save(self, instance):\n    \"\"\"Modify instance before save.\"\"\"\n    from django.utils.text import slugify\n    if not instance.slug:\n        instance.slug = slugify(instance.title)\n\ndef after_save(self, instance):\n    \"\"\"Execute logic after save.\"\"\"\n    # Clear cache\n    from django.core.cache import cache\n    cache.delete(f\"article:{instance.id}\")\n\ndef on_create_before_save(self, instance):\n    \"\"\"Before save, creation only.\"\"\"\n    instance.view_count = 0\n\ndef on_create_after_save(self, instance):\n    \"\"\"After save, creation only.\"\"\"\n    # Log creation\n    import logging\n    logger = logging.getLogger(__name__)\n    logger.info(f\"Article {instance.id} created\")\n\ndef on_delete(self, instance):\n    \"\"\"After deletion.\"\"\"\n    import logging\n    logger = logging.getLogger(__name__)\n    logger.info(f\"Article {instance.id} deleted\")\n</code></pre> <p>```</p> <p>Key Points: - All hooks receive <code>instance</code> as a parameter - Async hooks: <code>custom_actions(payload, instance)</code>, <code>post_create(instance)</code> - Sync hooks: <code>before_save(instance)</code>, <code>after_save(instance)</code>, <code>on_delete(instance)</code> - Creation-specific hooks: <code>on_create_before_save(instance)</code>, <code>on_create_after_save(instance)</code></p> 2. Configuring QuerySet Optimization <p>Add QuerySet configuration to your Serializer or ModelSerializer for automatic query optimization:</p> <p>```python from ninja_aio.models import serializers from ninja_aio.schemas.helpers import ModelQuerySetSchema, ModelQuerySetExtraSchema</p> <p>class ArticleSerializer(serializers.Serializer):     class Meta:         model = Article         schema_out = serializers.SchemaModelConfig(             fields=[\"id\", \"title\", \"content\", \"author\", \"category\", \"tags\"]         )         relations_serializers = {             \"author\": AuthorSerializer,             \"category\": CategorySerializer,             \"tags\": TagSerializer,         }</p> <pre><code>class QuerySet:\n    # Applied to list and retrieve operations\n    read = ModelQuerySetSchema(\n        select_related=[\"author\", \"category\"],\n        prefetch_related=[\"tags\"],\n    )\n\n    # Applied when queryset_request hook is called\n    queryset_request = ModelQuerySetSchema(\n        select_related=[\"author__profile\"],\n        prefetch_related=[\"comments\", \"comments__author\"],\n    )\n\n    # Named scopes for specific use cases\n    extras = [\n        ModelQuerySetExtraSchema(\n            scope=\"detail_view\",\n            select_related=[\"author\", \"author__profile\", \"category\"],\n            prefetch_related=[\"tags\", \"comments\", \"comments__author\"],\n        ),\n        ModelQuerySetExtraSchema(\n            scope=\"list_view\",\n            select_related=[\"author\", \"category\"],\n            prefetch_related=[\"tags\"],\n        ),\n    ]\n\n@classmethod\nasync def queryset_request(cls, request):\n    \"\"\"\n    Optional: Customize queryset based on request.\n    Automatically enhanced with QuerySet.queryset_request optimizations.\n    \"\"\"\n    qs = cls._meta.model.objects.all()\n\n    # Filter based on user permissions\n    if not request.user.is_staff:\n        qs = qs.filter(is_published=True)\n\n    # Add request-specific filters\n    if request.GET.get(\"featured\"):\n        qs = qs.filter(is_featured=True)\n\n    return qs\n</code></pre> <p>```</p> <p>For ModelSerializer:</p> <p>```python from ninja_aio.models import ModelSerializer from ninja_aio.schemas.helpers import ModelQuerySetSchema from django.db import models</p> <p>class Article(ModelSerializer):     title = models.CharField(max_length=200)     content = models.TextField()     author = models.ForeignKey(User, on_delete=models.CASCADE)     category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True)     tags = models.ManyToManyField(Tag, related_name=\"articles\")</p> <pre><code>class ReadSerializer:\n    fields = [\"id\", \"title\", \"content\", \"author\", \"category\", \"tags\"]\n\nclass QuerySet:\n    read = ModelQuerySetSchema(\n        select_related=[\"author\", \"category\"],\n        prefetch_related=[\"tags\"],\n    )\n    queryset_request = ModelQuerySetSchema(\n        select_related=[\"author__profile\"],\n        prefetch_related=[\"comments\"],\n    )\n\n@classmethod\nasync def queryset_request(cls, request):\n    \"\"\"Optimize queries for this model.\"\"\"\n    return cls.objects.select_related(\"author\", \"category\")\n</code></pre> <p>```</p> <p>How QuerySet Configuration Works:</p> <ol> <li><code>read</code>: Applied automatically to list and retrieve operations when <code>is_for_read=True</code></li> <li><code>queryset_request</code>: Applied when <code>with_qs_request=True</code> (default) in <code>get_objects()</code> or <code>get_object()</code></li> <li><code>extras</code>: Named scopes accessible via <code>QueryUtil.SCOPES</code> for custom scenarios</li> <li>Merging: Optimizations from multiple sources are merged (no duplicates)</li> </ol> <p>Benefits: - Eliminates N+1 queries automatically - Centralizes query optimization configuration - Works with both ModelSerializer and Serializer patterns - Optimizations apply to all CRUD operations</p> 3. Customizing Model Display Names <p>Override verbose names without modifying models:</p> <p><code>python @api.viewset(model=Article) class ArticleViewSet(APIViewSet):     model_verbose_name = \"Blog Post\"     model_verbose_name_plural = \"Blog Posts\"     # OpenAPI will use \"Blog Post\" instead of \"Article\"</code></p> \ud83d\udc1b Bug Fixes <ul> <li>Fixed query optimization merging when both model and serializer provide hints</li> <li>Corrected <code>read_s()</code> behavior when both <code>instance</code> and <code>query_data</code> provided (now raises clear error)</li> <li>Improved error messages for missing primary key in <code>get_object()</code></li> <li>Fixed duplicate route registration with <code>@unique_view</code> decorator</li> </ul> \ud83d\ude80 Performance Improvements <ul> <li>Transaction management with <code>@aatomic</code> reduces database round-trips</li> <li>Query optimization merging eliminates redundant select_related/prefetch_related</li> <li><code>with_qs_request</code> parameter allows skipping hook when not needed</li> </ul> \ud83d\ude4f Acknowledgments <p>This release focuses on: - Enhanced transaction safety - Flexible query control - Per-operation customization - Comprehensive documentation</p> \ud83d\udcdd Notes <ul> <li> <p>Backward Compatibility: All v2.4.0 code continues to work. New parameters have sensible defaults.</p> </li> <li> <p>Transaction Overhead: The <code>@aatomic</code> decorator adds minimal overhead. If you need non-transactional operations, override the view methods directly.</p> </li> <li> <p>Query Parameters: <code>with_qs_request</code> defaults to <code>True</code> to maintain v2.4.0 behavior. Set to <code>False</code> to skip the queryset_request hook.</p> </li> <li> <p>Serializer Hooks: If migrating from v2.4.0 Serializer usage, ensure all hooks accept the <code>instance</code> parameter.</p> </li> </ul> \ud83d\udd17 Links <ul> <li>Documentation</li> <li>GitHub Repository</li> <li>Issue Tracker</li> <li>v2.4.0 Release Notes</li> </ul> v2.4.0diff2026-01-09Release notes [v2.4.0] - 2026-01-09 \u2728 Added <ul> <li>Serializer (Meta-driven):</li> <li>New Serializer for vanilla Django models configured via nested Meta (no ModelSerializer inheritance).</li> <li>Dynamic schema generation helpers: generate_read_s, generate_create_s, generate_update_s, generate_related_s.</li> <li>Relation handling via relations_serializers for forward and reverse relations.</li> <li>APIViewSet:</li> <li>serializer_class to auto-generate missing schemas for non-ModelSerializer models and drive queryset_request.</li> <li>ModelUtil:</li> <li>Accepts serializer_class to build querysets using Serializer.queryset_request when provided.</li> <li>Docs/README:</li> <li>New docs page: api/models/serializers.md with usage and examples.</li> <li>README sections/examples for Meta-driven Serializer.</li> <li>MkDocs nav entry for Serializer.</li> <li>Tests:</li> <li>Serializer tests (forward and reverse relations).</li> <li>Viewset tests using serializer_class-backed endpoints.</li> </ul> \ud83d\udee0 Changed <ul> <li>Package layout:</li> <li>ninja_aio/models/init.py now exports ModelUtil and ModelSerializer.</li> <li>models.py refactored to models/utils.py; ModelSerializer moved to models/serializers.py.</li> <li>API internals:</li> <li>APIViewSet.compute_schema generates schemas from serializer_class for vanilla models; retains model-backed generation for ModelSerializer.</li> <li>ModelUtil.get_queryset_request uses serializer_class when provided.</li> <li>Docs:</li> <li>Index formatting tweaks; added links and examples for Serializer docs.</li> </ul> \ud83d\udcdd Documentation <ul> <li>Serializer (Meta-driven):</li> <li>Configure via Meta: model, schema_in, schema_out, schema_update, relations_serializers.</li> <li>Examples for FK and reverse relations; customs and optionals.</li> <li>APIViewSet:</li> <li>Using serializer_class to auto-generate schemas and plug into queryset_request.</li> <li>README:</li> <li>Quick example attaching Serializer to APIViewSet.</li> <li>MkDocs:</li> <li>Added nav entry under Models: Serializer (Meta-driven).</li> </ul> \u26a0 Notes / Potential Impact <ul> <li>Relation serializers:</li> <li>Reverse relations on vanilla models need relations_serializers entries to include nested schemas; otherwise skipped unless the related model is a ModelSerializer.</li> <li>A UserWarning is emitted when a reverse relation is listed without a mapping; suppressed in tests via NINJA_AIO_TESTING=True.</li> <li>Refactor:</li> <li>Imports may need updates due to ModelUtil relocation and new serializers module.</li> </ul> \ud83d\udd0d Migration / Action <ol> <li>Define a Meta-driven Serializer for existing Django models and attach it to APIViewSet via serializer_class.</li> <li>Provide relations_serializers for reverse relations to include nested schemas on read.</li> <li>Update imports:</li> <li>from ninja_aio.models import ModelUtil, ModelSerializer</li> <li>from ninja_aio.models.serializers import Serializer, SchemaModelConfig</li> <li>If relying on queryset_request with vanilla models, implement Serializer.queryset_request; APIViewSet and ModelUtil will use it automatically.</li> </ol>v2.3.2diff2026-01-08Release notes[v2.3.2] - 2026-01-08 \u2728 Added <ul> <li>Support Url pydantic field serialization</li> <li>Support for django ninja until 1.6</li> </ul> v2.3.1diff2026-01-07Release notes[v2.3.1] - 2026-01-07 \u2728 Added <ul> <li>CI/Docs Deployment:</li> <li>GitHub workflow updated to recognize and manage version \"2.3\" for docs deploy/delete.</li> <li>Documentation/README:</li> <li>Added link to the external example repository: https://github.com/caspel26/ninja-aio-blog-example.</li> </ul> \ud83d\udee0 Changed <ul> <li>README/Docs:</li> <li>Switched examples to decorator-first style with <code>@api.viewset(Model)</code> and in-class method decorators (e.g., <code>@api_post</code>).</li> <li>Removed explicit <code>api = api</code> and <code>model = ...</code> from examples where <code>@api.viewset(...)</code> is used; emphasized automatic registration.</li> <li>Cleaned and reformatted examples and quick links table; clarified usage in the index page and decorators page.</li> <li>Packaging:</li> <li>Python version spec adjusted from <code>&gt;=3.10, &lt;=3.14</code> to <code>&gt;=3.10, &lt;3.15</code> in pyproject metadata.</li> </ul> \ud83d\uddd1 Removed <ul> <li>In-repo example apps:</li> <li>Deleted <code>examples/ex_1</code> and <code>examples/ex_2</code> (models, views, urls, and auth). Examples are now hosted in the external repository linked in the README.</li> </ul> \ud83d\udcdd Documentation <ul> <li>Index and README updated to prefer <code>@api.viewset(Model)</code> and decorator-based custom endpoints.</li> <li>Decorators page (<code>docs/api/views/decorators.md</code>) revised to reflect decorator-first usage.</li> <li>Added references to the external example repository for complete, runnable samples.</li> </ul> v2.3.0diff2026-01-04Release notes [v2.3.0] - 2026-01-04 \u2728 Added <ul> <li>Decorators:</li> <li>New operation decorators for class methods: <code>api_get</code>, <code>api_post</code>, <code>api_put</code>, <code>api_patch</code>, <code>api_delete</code>, <code>api_options</code>, <code>api_head</code> (import from <code>ninja_aio.decorators</code>).</li> <li>Utilities: <code>decorate_view</code>, <code>aatomic</code>, <code>unique_view</code> (now under <code>ninja_aio.decorators</code>).</li> <li>Factory-backed decorators ensure clean OpenAPI signatures (exclude <code>self</code>) and support extra decorators like pagination.</li> <li>Views:</li> <li>APIView/APIViewSet auto-register decorated methods via lazy binding; no manual <code>add_views_to_route()</code> when using <code>@api.view</code> / <code>@api.viewset</code>.</li> <li>APIViewSet supports global trailing slash setting via <code>settings.NINJA_AIO_APPEND_SLASH</code> (default True).</li> <li>M2M:</li> <li><code>M2MRelationSchema.append_slash</code> to control trailing slash on the GET relation route.</li> <li>Relation path normalization for consistent URLs whether <code>path</code> includes leading slash or not.</li> <li>Tests/Examples:</li> <li>Added decorator-based examples and tests for custom endpoints on views and viewsets.</li> </ul> \ud83d\udee0 Changed <ul> <li>README/Docs:</li> <li>Prefer <code>@api.viewset(Model)</code> with decorator-based endpoints; legacy <code>views()</code> remains supported.</li> <li>Clarified trailing slash behavior for CRUD retrieve paths and M2M relations.</li> <li>Decorator-first examples across APIView and APIViewSet pages; cleaner OpenAPI notes.</li> <li>API internals:</li> <li>Base API class now binds decorator-registered methods via <code>_add_views()</code>; APIView/APIViewSet call <code>super()._add_views()</code> before legacy <code>views()</code>.</li> <li>APIViewSet path generation respects <code>NINJA_AIO_APPEND_SLASH</code> for retrieve path (<code>/{pk}/</code> vs <code>/{pk}</code>).</li> <li>Exceptions/Helpers:</li> <li>Added docstrings for clearer behavior in exceptions, query helpers, and schemas.</li> </ul> \ud83d\udcdd Documentation <ul> <li>APIView/APIViewSet:</li> <li>Decorator-first usage with examples; automatic lazy registration; signature preservation.</li> <li>Decorators:</li> <li>Using operation decorators with extra decorators (e.g., <code>paginate(PageNumberPagination)</code>, <code>unique_view(name)</code>).</li> <li>ViewSet relations:</li> <li>Per-relation <code>append_slash</code>; path normalization rules; trailing slash settings.</li> <li>README:</li> <li>Simplified setup: <code>@api.viewset(Model)</code> and decorator-based custom endpoints.</li> </ul> \u26a0 Notes / Potential Impact <ul> <li>Trailing slash:</li> <li>Global <code>NINJA_AIO_APPEND_SLASH</code> defaults to True. Disable to remove trailing slash from retrieve paths.</li> <li>M2M GET relation endpoints default to no trailing slash; enable per relation with <code>append_slash=True</code>.</li> <li>Registration:</li> <li>When using <code>@api.view</code> / <code>@api.viewset</code>, endpoints defined via decorators are mounted automatically; avoid redundant manual registration.</li> <li>OpenAPI:</li> <li>Decorator-backed handlers exclude <code>self</code> and preserve type hints for cleaner specs.</li> </ul> \ud83d\udd0d Migration / Action <ol> <li>Adopt decorators for extra endpoints:</li> <li>APIView: annotate the class with <code>@api.view(...)</code>, then decorate methods with <code>@api_get(\"/path\", ...)</code>.</li> <li>APIViewSet: annotate with <code>@api.viewset(Model, ...)</code>, then use <code>@api_get(\"/path\", ...)</code>, <code>@api_post(...)</code>, etc.</li> <li>Trailing slash configuration:</li> <li>Set <code>NINJA_AIO_APPEND_SLASH=False</code> in Django settings to drop trailing slash on retrieve paths globally.</li> <li>For M2M GET relations, use <code>M2MRelationSchema(append_slash=True/False)</code> to control trailing slash.</li> <li>Legacy support:</li> <li><code>views()</code> continues to work; prefer decorators for clearer code and better OpenAPI.</li> <li>Docs/examples:</li> <li>Update references to new decorator modules and follow decorator-first examples.</li> </ol>v2.2.0diff2026-01-03Release notes [2.2.0] - 2026-01-03 \u2728 Added <ul> <li>API:</li> <li>Decorators: <code>NinjaAIO.view(prefix, tags)</code> and <code>NinjaAIO.viewset(model, prefix, tags)</code> for automatic registration.</li> <li>Base API class: shared attributes for APIView and APIViewSet (api, router_tags, api_route_path).</li> <li>Views:</li> <li>APIView: supports constructor args <code>(api, prefix, tags)</code> with <code>router_tags</code> and standardized <code>error_codes</code>.</li> <li>APIViewSet: constructor <code>(api, model, prefix, tags)</code>; infers base path from model when not provided; <code>router_tags</code> support.</li> <li>Auth:</li> <li>JwtKeys type expands to include <code>jwk.OctKey</code> (HMAC).</li> <li><code>validate_key</code> accepts <code>jwk.OctKey</code>.</li> <li><code>encode_jwt</code>/<code>decode_jwt</code> type hints generalized to <code>JwtKeys</code>.</li> <li>Tests:</li> <li>Added decorator-based tests for APIView and APIViewSet (ModelSerializer and plain Django model).</li> <li>Updated ManyToMany tests to construct viewset with <code>api</code> argument.</li> <li>Docs:</li> <li>APIView and APIViewSet docs: \u201cRecommended\u201d decorator-based examples.</li> <li>Mixins doc moved to <code>docs/api/views/mixins.md</code>.</li> <li>Index updated with modern ModelSchema-based examples and async ORM usage.</li> </ul> \ud83d\udee0 Changed <ul> <li>Version:</li> <li>Bumped to 2.2.0 in <code>ninja_aio/__init__.py</code>.</li> <li>Error codes:</li> <li>Standardized to {400, 401, 404}; removed 428 references in code and docs.</li> <li>Docs:</li> <li><code>docs/api/authentication.md</code>: use list-based auth <code>[JWTAuth(), APIKeyAuth()]</code> instead of bitwise OR.</li> <li><code>docs/api/views/api_view.md</code> and <code>api_view_set.md</code>: emphasize decorator usage; cleaner examples; notes updated.</li> <li>MkDocs nav: Mixins path updated to <code>api/views/mixins.md</code>.</li> <li>API internals:</li> <li>APIView/APIViewSet refactored to share base attributes, constructor supports <code>api</code>, <code>prefix</code>, and <code>tags</code>.</li> <li>Docs workflow:</li> <li><code>mike set-default --push latest</code> when MAKE_LATEST is true.</li> <li>Packaging:</li> <li>Python requirement set to <code>&gt;=3.10, &lt;=3.14</code> in <code>pyproject.toml</code>.</li> </ul> \ud83d\udcdd Documentation <ul> <li>Updated:</li> <li>Authentication: list-based auth configuration and clarified behavior.</li> <li>APIView/APIViewSet: decorator-first usage, async compatibility, and standard error codes.</li> <li>Index: ModelSchema In/Out patterns with async ORM examples.</li> <li>Moved:</li> <li>Mixins doc to <code>api/views/mixins.md</code>; MkDocs navigation adjusted.</li> </ul> \u26a0 Notes / Potential Impact <ul> <li>Error handling:</li> <li>428 code removed; rely on {400, 401, 404}.</li> <li>Auth configuration:</li> <li>Use lists for multiple auth methods; bitwise OR in docs deprecated.</li> <li>Docs deployment:</li> <li>Default alias set to \u201clatest\u201d on deploy when MAKE_LATEST=true.</li> <li>Python compatibility:</li> <li>Upper bound set to 3.14.</li> </ul> \ud83d\udd0d Migration / Action <ol> <li>Adopt decorators:</li> <li>APIView: <code>@api.view(prefix=\"/path\", tags=[...])</code></li> <li>APIViewSet: <code>@api.viewset(model=MyModel, prefix=\"/path\", tags=[...])</code></li> <li>Update auth configuration:</li> <li>HMAC keys supported via <code>jwk.OctKey</code> where applicable.</li> <li>Error codes:</li> <li>Remove references/handlers for 428; standardize to {400, 401, 404}.</li> <li>Docs links:</li> <li>Update references to Mixins at <code>api/views/mixins.md</code>.</li> <li>Runtime:</li> <li>Ensure Python version is &lt;= 3.14 per <code>pyproject.toml</code>.</li> </ol>v2.1.0diff2026-01-02Release notes [2.1.0] - 2026-01-01 \u2728 Added <ul> <li>Views:</li> <li>ReadOnlyViewSet: list and retrieve-only endpoints.</li> <li>WriteOnlyViewSet: create, update, and delete-only endpoints.</li> <li>Exported via <code>ninja_aio.views.__init__</code> for cleaner imports.</li> <li>Mixins:</li> <li>New filtering mixins under <code>ninja_aio/views/mixins.py</code>: IcontainsFilterViewSetMixin, BooleanFilterViewSetMixin, NumericFilterViewSetMixin, DateFilterViewSetMixin, and specialized Greater/Less variants.</li> <li>Auth docs:</li> <li>New <code>docs/auth.md</code> with JWT helpers and <code>AsyncJwtBearer</code> usage and configuration.</li> <li>Tests:</li> <li>Extended test model with <code>age</code>, <code>active</code>, and <code>active_from</code> fields.</li> <li>Added viewset tests for mixins (icontains, boolean, numeric, date comparisons).</li> <li>Added auth tests for JWT encode/decode and AsyncJwtBearer claim validation.</li> <li>Docs navigation:</li> <li>Added Mixins page and JWT &amp; AsyncJwtBearer page to MkDocs nav.</li> <li>MkDocs <code>mike</code> config sets <code>default: latest</code>.</li> </ul> \ud83d\udee0 Changed <ul> <li>Docs workflow (<code>.github/workflows/docs.yml</code>):</li> <li>Safer deletion: requires explicit <code>delete_version</code> choice and <code>delete_confirm</code>, protects <code>latest</code>, <code>stable</code>, and current default.</li> <li><code>make_latest</code> default set to false.</li> <li>Coverage workflow:</li> <li>Bump <code>codecov/codecov-action</code> from v5.5.1 to v5.5.2.</li> <li>API helpers:</li> <li>Use <code>decorate_view</code> to compose <code>unique_view</code> and <code>paginate</code> for related GET endpoints.</li> <li>APIViewSet (imports and behavior):</li> <li>Module reorganized to <code>ninja_aio/views/api.py</code> with updated internal imports.</li> <li><code>get_schemas</code>: generates schemas only if missing when model is a <code>ModelSerializerMeta</code>, else returns explicitly set schemas.</li> <li>Hook docs clarified to allow sync or async handlers for query params.</li> <li>Auth:</li> <li><code>encode_jwt</code>: header now includes <code>kid</code> only when present (conditional merge).</li> <li>Docs:</li> <li><code>docs/api/views/api_view_set.md</code> updated to document ReadOnlyViewSet and WriteOnlyViewSet.</li> <li><code>docs/mixins.md</code> aligned with implemented mixins and examples.</li> </ul> \ud83d\udcdd Documentation <ul> <li>New:</li> <li>JWT &amp; AsyncJwtBearer guide with examples for settings and direct JWK usage.</li> <li>Updated:</li> <li>Mixins reference to match implemented classes and recommended query param types.</li> <li>APIViewSet docs extended with ReadOnly/WriteOnly usage.</li> </ul> \u26a0 Notes / Potential Impact <ul> <li>Docs deployment:</li> <li>Deletion requires explicit confirmation and cannot remove protected aliases or current default.</li> <li>Mixins:</li> <li>Date filters expect values that implement <code>isoformat</code>; prefer Pydantic <code>date</code>/<code>datetime</code> in query params.</li> </ul> \ud83d\udd0d Migration / Action <ol> <li>Update imports:</li> <li><code>from ninja_aio.views import APIViewSet, ReadOnlyViewSet, WriteOnlyViewSet</code></li> <li><code>from ninja_aio.views import mixins</code> for filter mixins.</li> <li>For related list endpoints using custom decorators, consider adopting <code>decorate_view</code> for consistent composition.</li> <li>If using JWT:</li> <li>Optionally set <code>JWT_PRIVATE_KEY</code>, <code>JWT_PUBLIC_KEY</code>, <code>JWT_ISSUER</code>, <code>JWT_AUDIENCE</code> in Django settings.</li> <li>Validate claims via <code>AsyncJwtBearer.claims</code> registry and verify allowed algorithms.</li> <li>Review docs workflow inputs before deleting versions; use <code>delete_confirm: true</code>.</li> </ol>v2.0.0diff2025-12-16Release notes [2.0.0] - 2025-12-16 \u2728 Added <ul> <li>QueryUtil and query scopes:</li> <li>New <code>QueryUtil</code> with <code>SCOPES</code> (READ, QUERYSET_REQUEST, plus extras) and <code>apply_queryset_optimizations</code>.</li> <li><code>ModelSerializer.query_util</code> bound per model via <code>__init_subclass__</code>.</li> <li><code>ModelSerializer.QuerySet</code> supports <code>read</code>, <code>queryset_request</code>, <code>extras</code>.</li> <li>Query schemas:</li> <li><code>QuerySchema</code>, <code>ObjectQuerySchema</code>, <code>ObjectsQuerySchema</code>, <code>ModelQuerySetSchema</code>, <code>ModelQuerySetExtraSchema</code>, <code>QueryUtilBaseScopesSchema</code>.</li> <li>ModelUtil:</li> <li><code>get_objects(...)</code>: optimized queryset fetching with filters and select/prefetch hints.</li> <li><code>get_object(...)</code>: single-object retrieval by pk or getters with optimizations.</li> <li><code>read_s(...)</code> and <code>list_read_s(...)</code>: serialize instances or auto-fetch via query schemas.</li> <li>Relation discovery helpers: <code>get_select_relateds()</code>, <code>get_reverse_relations()</code>.</li> <li>PK type resolution: <code>pk_field_type</code> with helpful error for unknown field types.</li> <li>ManyToManyAPI:</li> <li>GET related endpoints return <code>{items: [...], count: N}</code>.</li> <li>Relation filter handlers accept sync or async functions.</li> <li>Related items use <code>ModelUtil.list_read_s</code> for serialization.</li> <li>Per-relation single-object resolution handler for POST: <code>&lt;related_name&gt;_query_handler(...)</code>.</li> <li>Schemas modularization:</li> <li>New modules: <code>ninja_aio/schemas/api.py</code>, <code>ninja_aio/schemas/generics.py</code>, and exported names under <code>ninja_aio/schemas/__init__.py</code>.</li> <li>Decorators:</li> <li><code>decorate_view</code> utility to compose multiple decorators (sync/async), skipping <code>None</code>.</li> <li><code>APIViewSet.extra_decorators</code> via <code>DecoratorsSchema</code> for per-operation decoration.</li> <li>Renderer:</li> <li>ORJSON renderer option via <code>settings.NINJA_AIO_ORJSON_RENDERER_OPTION</code> (bitmask, supports <code>|</code>).</li> </ul> \ud83d\udee0 Changed <ul> <li>APIViewSet:</li> <li>List uses <code>ModelUtil.get_objects</code> and <code>list_read_s</code> with read optimizations; filter hooks retained.</li> <li>Retrieve uses <code>read_s</code> with <code>QuerySchema(getters={\"pk\": ...})</code>.</li> <li>Path PK schema type inferred from model PK via <code>ModelUtil.pk_field_type</code>.</li> <li>Default read query data comes from <code>ModelSerializer.QuerySet.read</code> via <code>query_util</code>.</li> <li>Built-ins and custom decorators composed with <code>decorate_view</code> (e.g., <code>paginate</code>, <code>unique_view</code>, extras).</li> <li>ModelSerializer:</li> <li>Binds <code>util = ModelUtil(cls)</code> and <code>query_util = QueryUtil(cls)</code> to subclasses.</li> <li><code>queryset_request</code> applies configured optimizations from <code>QuerySet.queryset_request</code>.</li> <li>ModelUtil internals:</li> <li>Unified <code>_apply_query_optimizations</code> merges explicit select/prefetch with auto-discovered relations when <code>is_for_read=True</code>.</li> <li>Serialization paths standardized through internal helpers; <code>read_s</code>/<code>list_read_s</code> accept <code>schema</code> first.</li> <li>Auth:</li> <li><code>AsyncJwtBearer.verify_token</code> simplifies error handling; drops explicit <code>AuthError</code>.</li> <li>Imports:</li> <li><code>ManyToManyAPI</code> consumed from <code>ninja_aio/helpers/api.py</code>.</li> <li>Runtime requirements:</li> <li>Upper bounds added: <code>django-ninja &lt;=1.5.1</code>, <code>joserfc &lt;=1.4.1</code>, <code>orjson &lt;=3.11.5</code>.</li> <li>Docs and site:</li> <li>MkDocs/mike integration for versioned docs; new workflow <code>docs.yml</code>.</li> </ul> \ud83d\udd34 Breaking Changes <ul> <li>Path PK schema type:</li> <li>PK type is inferred from the model PK. Code relying on <code>int | str</code> in path schemas may need adjustments.</li> <li>ManyToMany GET response shape:</li> <li>Response changed from a plain list to <code>{items: [...], count: N}</code>. Clients must adapt parsing.</li> <li>Import paths:</li> <li>Schema helpers moved under <code>ninja_aio/schemas/helpers.py</code> and re-exported by <code>ninja_aio/schemas/__init__.py</code>.</li> <li><code>ManyToManyAPI</code> import is now <code>from ninja_aio.helpers.api import ManyToManyAPI</code>.</li> <li>ModelUtil read API:</li> <li><code>read_s</code> and <code>list_read_s</code> signatures accept <code>schema</code> first and support <code>instance</code> or <code>query_data</code>. Code passing <code>(request, obj, schema)</code> must switch to <code>(schema, request, instance=obj)</code>.</li> </ul> \ud83d\udcdd Documentation <ul> <li>Updated:</li> <li>ModelUtil reference: QuerySet config, QueryUtil, query schemas, <code>get_objects</code>, <code>get_object</code>, <code>read_s</code>, <code>list_read_s</code>.</li> <li>APIViewSet: list/retrieve flow, PK type inference, M2M GET envelope, async/sync filter handlers, operation decorators.</li> <li>Tutorial (model): QuerySet config and <code>query_util</code> examples; fetch/serialize using query schemas.</li> <li>Index: overview of query optimizations and schemas.</li> <li>ORJSON renderer: configuration guide.</li> </ul> \u26a0 Notes / Potential Impact <p>| Area                | Observation                                                       | Impact                                                                | | ------------------- | ----------------------------------------------------------------- | --------------------------------------------------------------------- | | Query optimizations | <code>is_for_read=True</code> merges explicit and auto-discovered relations. | More joins/prefetches; re-check performance for heavy endpoints.      | | Requirements caps   | Upper bounds added for core deps.                                 | Ensure compatible versions in your environment.                       | | Decorator order     | <code>decorate_view</code> applies standard Python stacking order.           | Verify nesting with <code>paginate</code>, <code>unique_view</code>, and custom decorators. |</p> \ud83d\udd0d Migration / Action <ol> <li>Update imports:</li> <li><code>from ninja_aio.schemas.helpers import QuerySchema, ObjectQuerySchema, ObjectsQuerySchema, ModelQuerySetSchema, ModelQuerySetExtraSchema</code></li> <li><code>from ninja_aio.helpers.api import ManyToManyAPI</code></li> <li>Adjust M2M GET consumers to handle <code>{items, count}</code>.</li> <li>Update <code>read_s</code>/<code>list_read_s</code> calls to new parameter order.</li> <li>Verify path PK handling in custom routes that relied on a generic PK type.</li> <li>Review <code>QuerySet.read</code> / <code>QuerySet.queryset_request</code> for desired select/prefetch behavior.</li> <li>Optionally configure ORJSON via <code>NINJA_AIO_ORJSON_RENDERER_OPTION</code>.</li> </ol>v2.0.0-rc1diff2025-12-07Release notes [2.0.0-rc1] - 2025-12-07 \u2728 Added <ul> <li>QueryUtil and query scopes:</li> <li>New <code>QueryUtil</code> with <code>SCOPES</code> (READ, QUERYSET_REQUEST, plus extras) and <code>apply_queryset_optimizations</code>.</li> <li><code>ModelSerializer.query_util</code> bound per model via <code>__init_subclass__</code>.</li> <li><code>ModelSerializer.QuerySet</code> supports <code>read</code>, <code>queryset_request</code>, <code>extras</code>.</li> <li>Query schemas:</li> <li><code>QuerySchema</code>, <code>ObjectQuerySchema</code>, <code>ObjectsQuerySchema</code>, <code>ModelQuerySetSchema</code>, <code>ModelQuerySetExtraSchema</code>, <code>QueryUtilBaseScopesSchema</code>.</li> <li>ModelUtil:</li> <li><code>get_objects(...)</code>: optimized queryset fetching with filters and select/prefetch hints.</li> <li><code>get_object(...)</code>: single-object retrieval by pk or getters with optimizations.</li> <li><code>read_s(...)</code> and <code>list_read_s(...)</code>: serialize instances or auto-fetch via query schemas.</li> <li>Relation discovery helpers: <code>get_select_relateds()</code>, <code>get_reverse_relations()</code>.</li> <li>PK type resolution: <code>pk_field_type</code> with helpful error for unknown field types.</li> <li>ManyToManyAPI:</li> <li>GET related endpoints return <code>{items: [...], count: N}</code>.</li> <li>Relation filter handlers accept sync or async functions.</li> <li>Related items use <code>ModelUtil.list_read_s</code> for serialization.</li> <li>Schemas modularization:</li> <li>New modules: <code>ninja_aio/schemas/api.py</code>, <code>ninja_aio/schemas/generics.py</code>, and exported names under <code>ninja_aio/schemas/__init__.py</code>.</li> <li>Decorators:</li> <li>Minor hardening and docs for <code>aatomic</code> and <code>unique_view</code>.</li> </ul> \ud83d\udee0 Changed <ul> <li>APIViewSet:</li> <li>List view uses <code>ModelUtil.get_objects</code> and <code>list_read_s</code> with read optimizations; filter hooks retained.</li> <li>Retrieve view uses <code>read_s</code> with <code>QuerySchema(getters={\"pk\": ...})</code>.</li> <li>Path PK schema type inferred from model PK via <code>ModelUtil.pk_field_type</code>.</li> <li>Default read query data comes from <code>ModelSerializer.QuerySet.read</code> via <code>query_util</code>.</li> <li>ModelSerializer:</li> <li>Binds <code>util = ModelUtil(cls)</code> and <code>query_util = QueryUtil(cls)</code> to subclasses.</li> <li><code>queryset_request</code> applies configured optimizations from <code>QuerySet.queryset_request</code>.</li> <li>ModelUtil internals:</li> <li>Unified <code>_apply_query_optimizations</code> merges explicit select/prefetch with auto-discovered relations when <code>is_for_read=True</code>.</li> <li>Serialization paths standardized through internal bump helpers.</li> <li>Auth:</li> <li><code>AsyncJwtBearer.verify_token</code> simplifies error handling; drops explicit <code>AuthError</code>.</li> <li>Imports:</li> <li><code>ManyToManyAPI</code> consumed from <code>ninja_aio/helpers/api.py</code>.</li> <li>Runtime requirements:</li> <li>Pinned upper bounds for <code>django-ninja</code>, <code>joserfc</code>, <code>orjson</code>.</li> </ul> \ud83d\udcdd Documentation <ul> <li>Updated:</li> <li>ModelUtil reference: QuerySet config, QueryUtil, query schemas, <code>get_objects</code>, <code>get_object</code>, <code>read_s</code>, <code>list_read_s</code>.</li> <li>APIViewSet: list/retrieve flow, PK type inference, M2M GET envelope, async/sync filter handlers.</li> <li>Tutorial (model): QuerySet config and <code>query_util</code> examples; fetch/serialize using query schemas.</li> <li>Index: overview of query optimizations and schemas.</li> </ul> \ud83d\udd34 Breaking Changes <ul> <li>Path PK schema type:</li> <li>PK type is now inferred from the model PK. Code relying on <code>int | str</code> in path schemas may need adjustments.</li> <li>ManyToMany GET response shape:</li> <li>Response changed from a plain list to an envelope <code>{items: [...], count: N}</code>. Clients must adapt parsing.</li> <li>Import paths:</li> <li>Schema helpers moved under <code>ninja_aio/schemas/helpers.py</code> and re-exported by <code>ninja_aio/schemas/__init__.py</code>.</li> <li><code>ManyToManyAPI</code> import is now <code>from ninja_aio.helpers.api import ManyToManyAPI</code>.</li> <li>ModelUtil read API:</li> <li><code>read_s</code> and <code>list_read_s</code> signatures accept <code>schema</code> first and support <code>instance</code> or <code>query_data</code>. Code passing <code>(request, obj, schema)</code> must switch to <code>(schema, request, instance=obj)</code>.</li> </ul> \u26a0 Notes / Potential Impact <p>| Area | Observation | Impact | | ---- | ----------- | ------ | | Query optimizations | <code>is_for_read=True</code> merges explicit and auto-discovered relations. | More joins/prefetches; re-check performance for heavy endpoints. | | Requirements caps | Upper bounds added for core deps. | Ensure compatible versions in your environment. |</p> \ud83d\udd0d Migration / Action <ol> <li>Update imports:</li> <li><code>from ninja_aio.schemas.helpers import QuerySchema, ObjectQuerySchema, ObjectsQuerySchema, ModelQuerySetSchema, ModelQuerySetExtraSchema</code></li> <li><code>from ninja_aio.helpers.api import ManyToManyAPI</code></li> <li>Adjust M2M GET consumers to handle <code>{items, count}</code>.</li> <li>Update <code>read_s</code>/<code>list_read_s</code> calls to new parameter order.</li> <li>Verify path PK handling in custom routes that relied on a generic PK type.</li> <li>Review <code>QuerySet.read</code> / <code>QuerySet.queryset_request</code> for desired select/prefetch behavior.</li> </ol> \u2705 Suggested Follow-Ups <ul> <li>Add perf checks around list/retrieve with merged relations.</li> <li>Expand tests for:</li> <li>PK type inference in path schemas.</li> <li>Sync vs async relation filter handlers.</li> <li>QueryUtil extras scopes resolution and application.</li> </ul> v2.0.0-rc2diff2025-12-12Release notes [2.0.0-rc2] - 2025-12-12 \u2728 Added <ul> <li>support for django-ninja 1.5.1</li> <li>support for orjson 3.11.5</li> </ul>v2.0.0-rc3diff2025-12-12Release notes [2.0.0-rc3] - 2025-12-12 \u2728 Added <ul> <li>ManyToManyAPI:</li> <li>New per-relation POST object resolution handler: <code>&lt;related_name&gt;_query_handler(self, request, pk, instance)</code> returning a queryset, resolved via <code>.afirst()</code>.</li> <li>Endpoint registration details documented: GET without trailing slash, POST with trailing slash; operationId conventions (<code>get_{base}_{rel}</code>, <code>manage_{base}_{rel}</code>).</li> </ul> \ud83d\udee0 Changed <ul> <li>ManyToManyAPI:</li> <li>Split handlers: GET uses <code>&lt;related_name&gt;_query_params_handler(self, queryset, filters_dict)</code>; POST uses <code>&lt;related_name&gt;_query_handler(...)</code> for per-PK validation.</li> <li>Manage view uses <code>_collect_m2m(...)</code> with additional context (<code>related_name</code>, <code>instance</code>) and falls back to <code>ModelUtil.get_objects(...)</code> when query handler is absent.</li> <li>Improved docs and docstrings for concurrency, error semantics, and request/response payloads.</li> <li>Docs:</li> <li>Refined M2M section: clarified handlers, paths, operationIds, request bodies, and concurrency.</li> <li>Minor wording and formatting improvements; standardized examples.</li> <li>Version:</li> <li>Bump to <code>2.0.0-rc3</code>.</li> </ul> \ud83d\udcdd Documentation <ul> <li>APIViewSet M2M docs updated:</li> <li>Clarified GET filters vs POST per-PK resolution.</li> <li>Documented response semantics and per-PK success/error messages.</li> <li>Added an example showcasing both handlers.</li> </ul> \ud83d\udd34 Breaking Changes <ul> <li>Handler naming:</li> <li>GET filters must use <code>&lt;related_name&gt;_query_params_handler</code>; POST add/remove resolution must use <code>&lt;related_name&gt;_query_handler</code>. Existing single-handler implementations should be split accordingly.</li> <li>Endpoint paths:</li> <li>GET relation: <code>/{base}/{pk}/{rel_path}</code> (no trailing slash).</li> <li>POST relation: <code>/{base}/{pk}/{rel_path}/</code> (trailing slash).</li> </ul> \u26a0 Notes / Potential Impact <p>| Area | Observation | Impact | | ---- | ----------- | ------ | | Validation | POST uses per-PK resolution handler when present; fallback uses <code>ModelUtil.get_objects</code>. | Tighten access control and scoping per relation. | | Concurrency | <code>aadd</code> and <code>aremove</code> run concurrently via <code>asyncio.gather</code>. | Faster bulk mutations; ensure thread-safety of custom logic. |</p> \ud83d\udd0d Migration / Action <ol> <li>Implement per-relation handlers:</li> <li>GET filters: <code>def|async def &lt;rel&gt;_query_params_handler(self, qs, filters: dict) -&gt; qs</code>.</li> <li>POST resolution: <code>async def &lt;rel&gt;_query_handler(self, request, pk, instance) -&gt; queryset</code>.</li> <li>Verify clients and OpenAPI consumers against the documented endpoint paths and operationIds.</li> <li>Ensure manage responses are consumed as documented (<code>results</code>, <code>errors</code> with <code>count</code> and <code>details</code>).</li> </ol> \u2705 Suggested Follow-Ups <ul> <li>Add tests for:</li> <li>Presence/absence of <code>&lt;related_name&gt;_query_handler</code> fallback behavior.</li> <li>Sync vs async GET filter handlers.</li> <li>Per-PK error and success detail aggregation.</li> </ul>v2.0.0-rc4diff2025-12-12Release notes [2.0.0-rc4] - 2025-12-12 \u2728 Added <ul> <li>possibility to override router tag in APIViewSet</li> </ul> v2.0.0-rc5diff2025-12-12Release notes [2.0.0-rc5] - 2025-12-12 \ud83d\udee0 Changed <ul> <li>fix: update log messages to use 'pk' instead of 'id' for consistency in ManyToManyAPI</li> </ul> v2.0.0-rc6diff2025-12-12Release notes [2.0.0-rc6] - 2025-12-12 \u2728 Added <ul> <li>ORJSONRenderer:</li> <li>Configurable orjson option via Django settings: <code>NINJA_AIO_ORJSON_RENDERER_OPTION</code>.</li> <li>New <code>dumps</code> classmethod applying the configured option to all JSON responses.</li> </ul> \ud83d\udee0 Changed <ul> <li>Version bump:</li> <li><code>__version__</code> updated from <code>2.0.0-rc5</code> to <code>2.0.0-rc6</code>.</li> <li>Rendering internals:</li> <li><code>render</code> now calls <code>self.dumps(...)</code> instead of <code>orjson.dumps(...)</code> directly.</li> </ul> \ud83d\udcdd Documentation <ul> <li>Mention <code>NINJA_AIO_ORJSON_RENDERER_OPTION</code> in setup/config docs with example values (e.g., <code>orjson.OPT_NAIVE_UTC</code>, <code>orjson.OPT_SERIALIZE_DATACLASS</code>).</li> </ul> \ud83d\udd0d Migration / Action <ol> <li>If you need specific JSON encoding behavior, set in Django settings:</li> <li><code>NINJA_AIO_ORJSON_RENDERER_OPTION = orjson.OPT_NAIVE_UTC | orjson.OPT_SERIALIZE_NUMPY</code> (example).</li> <li>No code changes required for consumers; behavior is backward compatible when the setting is absent.</li> </ol> \u26a0 Notes / Potential Impact <p>| Area | Observation | Impact | | ---- | ----------- | ------ | | JSON options | Renderer honors global orjson options. | Unified behavior across endpoints; verify compatibility with clients. |</p> v2.0.0-rc7diff2025-12-16Release notes [2.0.0-rc7] - 2025-12-16 \u2728 Added <ul> <li>Decorators:</li> <li><code>decorate_view</code>: compose multiple decorators (sync/async), preserves normal stacking order, skips <code>None</code>.</li> <li><code>APIViewSet.extra_decorators</code>: declarative per-operation decorators.</li> <li><code>DecoratorsSchema</code> in <code>ninja_aio.schemas.helpers</code> to configure per-op decorators.</li> </ul> \ud83d\udee0 Changed <ul> <li>APIViewSet:</li> <li><code>create</code>, <code>list</code>, <code>retrieve</code>, <code>update</code>, <code>delete</code> compose built-ins (<code>unique_view</code>, <code>paginate</code>) and user-provided extras via <code>decorate_view</code> for consistent ordering.</li> </ul> \ud83d\udcdd Documentation <ul> <li>New:</li> <li><code>docs/api/views/decorators.md</code>: <code>decorate_view</code> usage, conditional decoration, and <code>extra_decorators</code> with <code>DecoratorsSchema</code>.</li> <li><code>docs/api/renderers/orjson_renderer.md</code>: how to configure ORJSON options in <code>settings.py</code>.</li> </ul> \u26a0 Notes / Potential Impact <ul> <li>Decorator order:</li> <li><code>decorate_view</code> applies decorators in standard Python stacking semantics. If you relied on a specific nesting between <code>paginate</code>, <code>unique_view</code>, and custom decorators, verify behavior.</li> </ul> \ud83d\udd0d Migration / Action <ol> <li>Optionally move per-operation decorators to <code>APIViewSet.extra_decorators = DecoratorsSchema(...)</code>.</li> <li>If desired, configure ORJSON behavior via <code>NINJA_AIO_ORJSON_RENDERER_OPTION</code> in <code>settings.py</code>.</li> </ol>v1.0.5diff2025-12-07Release notes[1.0.5] - 2025-12-07 \ud83d\udee0 Changed <ul> <li>limited support up to django ninja 1.4.5</li> </ul>v1.0.4diff2025-11-03Release notes[1.0.4] - 2025-11-03 \u2728 Added <ul> <li><code>ModelUtil._rewrite_nested_foreign_keys</code>: reintroduced helper to rename nested FK keys from <code>&lt;field&gt;</code> to <code>&lt;field&gt;_id</code> inside nested dicts (currently invoked conditionally in <code>parse_output_data</code>).</li> </ul> \ud83d\udee0 Changed <ul> <li><code>ModelUtil._extract_field_obj</code> converted to async; now uses <code>agetattr</code> for safer async attribute access.</li> <li><code>ModelUtil.parse_output_data</code>:</li> <li>Awaits the new async <code>_extract_field_obj</code>.</li> <li>Fetches related instance first, then (conditionally) calls <code>_rewrite_nested_foreign_keys</code> when the outer field is a <code>ForeignKey</code>.</li> </ul> \ud83d\udcdd Documentation <ul> <li>Table in <code>docs/api/models/model_serializer.md</code> (CreateSerializer attributes) reformatted:</li> <li>Condensed multiline description for <code>customs</code> into a single line with semicolons.</li> <li>Adjusted column widths / alignment for cleaner diff footprint.</li> </ul> \u26a0 Note / Potential Issue <p>| Area | Observation | Impact | | ---- | ----------- | ------ | | <code>parse_output_data</code> | Result of <code>_rewrite_nested_foreign_keys</code> is assigned to local <code>v</code> but not reattached to <code>payload</code> (final output still sets <code>payload[k] = rel_instance</code>). | FK key rewriting may be a no-op for consumers; behavior might not match intent. |</p> \ud83d\udd0d Migration / Action <ol> <li>If you relied on the absence of FK key rewriting (1.0.3), verify whether the restored helper actually affects payloads (it likely does not yet).</li> <li>If rewriting is desired, ensure the transformed dict (or additional metadata) is surfaced in the serialized output or adjust logic accordingly.</li> </ol> \u2705 Suggested Follow-Ups <ul> <li>Add a test asserting expected presence (or absence) of <code>&lt;field&gt;_id</code> keys in nested output.</li> <li>Decide whether payload should expose both the related object and rewritten key map, or deprecate the helper again if not needed.</li> </ul> v1.0.3diff2025-11-03Release notes[1.0.3] - 2025-11-03 \u2728 Added <ul> <li><code>M2MRelationSchema</code>: New optional field <code>related_schema</code> documented (auto-generated when using a <code>ModelSerializer</code>).</li> </ul> \ud83d\udee0 Changed <ul> <li>Documentation tables (CRUD, Core Attributes, Auth, M2M Endpoints, Hooks) reformatted for alignment &amp; readability.</li> <li>Extra blank lines inserted to improve Markdown rendering clarity.</li> <li><code>ModelUtil.parse_output_data</code>: simplified nested relation handling (direct instance assignment).</li> </ul> \ud83d\uddd1 Removed <ul> <li><code>ModelUtil._rewrite_nested_foreign_keys</code> helper.</li> <li>Foreign key nested dict rewriting logic (<code>&lt;field&gt;</code> \u2192 <code>&lt;field&gt;_id</code>) during output serialization.</li> </ul> \ud83d\udcc4 Documentation <ul> <li>Added warning block describing support for plain Django <code>Model</code> in <code>M2MRelationSchema.model</code> and mandatory <code>related_schema</code> when used.</li> <li>Added <code>related_schema</code> bullet to M2M relation capabilities list.</li> <li>Ensured file ends with a trailing newline.</li> </ul> \u26a0 Breaking Change <p>| Change | Impact | | ------ | ------ | | Removal of FK key rewriting in nested outputs | Clients expecting <code>&lt;nested_fk&gt;_id</code> keys must adjust parsing logic |</p> \ud83d\udd0d Migration Notes <ol> <li>If consumers relied on <code>&lt;nested_fk&gt;_id</code> keys, add a post-serialization adapter to inject them, or reintroduce prior logic.</li> <li>When declaring M2M relations with plain Django models, always provide <code>related_schema</code>; omission now results in validation errors.</li> </ol> \ud83d\udccc Highlights <ul> <li>Cleaner docs + explicit M2M plain model guidance.</li> <li>Leaner serialization path (less mutation, clearer intent).</li> </ul> \ud83e\uddea Suggested Follow\u2011Ups <ul> <li>Add regression test ensuring nested FK dicts are no longer rewritten.</li> <li>Consider exposing an optional flag to restore legacy FK key rewriting if demand appears.</li> </ul>v1.0.2diff2025-11-01Release notes[1.0.2] - 2025-11-01 \u2728 Added <ul> <li>SonarCloud Quality Gate badge (README + docs index).</li> <li>Custom domain support (docs/CNAME).</li> <li>Release Notes page with dynamic macros (<code>docs/release_notes.md</code> + <code>mkdocs-macros-plugin</code>).</li> <li>Release automation script (<code>main.py</code>) generating tables, full changelog, and cards.</li> <li>ManyToManyAPI helper (<code>ninja_aio/helpers/api.py</code>) with dynamic GET / ADD / REMOVE endpoints, filter schemas, concurrent operations, and query handler support.</li> <li>Helpers package export (<code>helpers/__init__.py</code>).</li> <li>Extended schema support in <code>M2MRelationSchema</code> (auto <code>related_schema</code> via validator).</li> <li>Refactored M2M integration in <code>APIViewSet</code> (now uses <code>ManyToManyAPI</code>).</li> <li>New test suites: decorators, exceptions/API, renderer/parser, many-to-many API.</li> <li>Centralized literal for \u201cnot found\u201d (<code>tests/generics/literals.py</code>).</li> </ul> \ud83d\udee0 Changed <ul> <li><code>NotFoundError</code>: error key now uses underscored verbose name.</li> <li><code>ORJSONRenderer</code>: replaced nested mutation with recursive <code>transform</code>.</li> <li><code>ModelUtil</code> / <code>ModelSerializer</code>: added comprehensive docstrings, normalized custom field tuples, improved FK and nested output handling.</li> <li>Removed inline M2M view logic from <code>APIViewSet</code>.</li> <li>Enriched model serializer docs (tables, normalization, error cases).</li> <li><code>M2MRelationSchema</code>: validation for related schema generation.</li> </ul> \ud83e\uddfe Documentation <ul> <li>Major rewrite of <code>docs/api/models/model_serializer.md</code>: normalization workflow, error cases, best practices, expanded examples.</li> <li>Added Release Notes navigation in <code>mkdocs.yml</code>.</li> <li>Inline internal-use warning for <code>ManyToManyAPI</code>.</li> <li>Improved readability (spacing, tables, JSON formatting).</li> </ul> \u2705 Tests <ul> <li>Coverage for:</li> <li>ORJSON transformations (bytes\u2192base64, IP\u2192string).</li> <li><code>unique_view</code> name suffix logic.</li> <li>Exception parsing and API defaults.</li> <li>M2M add/remove flows + duplicate/error handling.</li> <li>Updated NotFoundError key format.</li> <li>Reused shared literal for 404 assertions.</li> </ul> \ud83d\udce6 Tooling <ul> <li>Added <code>mkdocs-macros-plugin</code>.</li> <li>Automated release visualization (HTML tables, cards).</li> <li>Cleaner MkDocs theme (font configuration).</li> </ul> \u26a0 Impact <p>| Change | Potential Effect | | ------ | ---------------- | | Underscored error keys | Clients parsing old keys must adjust | | Extracted M2M logic | Custom subclasses relying on internals must migrate | | 2\u2011tuple customs now required | Missing values trigger validation errors |</p> \ud83d\udd0d Upgrade Notes <ol> <li>Update error handling for new 404 key shape.</li> <li>Migrate any manual M2M endpoint wiring to <code>ManyToManyAPI</code>.</li> <li>Review custom field tuples\u2014add defaults if optional behavior desired.</li> </ol> \ud83e\uddea Follow\u2011Ups <ul> <li>Tag release (<code>git tag -a vX.Y.Z -m \"Release vX.Y.Z\" &amp;&amp; git push --tags</code>).</li> <li>Optionally add top-level <code>CHANGELOG.md</code>.</li> <li>Decide on public stability of <code>ManyToManyAPI</code> (remove warning when ready).</li> </ul> \ud83d\udccc Release Template <p>```markdown</p> vX.Y.Z (YYYY-MM-DD) <p>Highlights: - ...</p> <p>Full release table: /release_notes/</p>v1.0.1diff2025-10-30Release notes1.0.1 - 2025-10-30 Added <ul> <li>Docs: New dev dependencies file <code>requirements.dev.txt</code>.</li> <li>MkDocs: Additional plugins (<code>mkdocstrings</code>, <code>section-index</code>, <code>autorefs</code>) and extended <code>markdown_extensions</code>.</li> <li>Theme extras: social links, analytics stub, version metadata.</li> <li>CSS: Logo sizing rules in <code>docs/extra.css</code>.</li> </ul> Changed <ul> <li>README: Reduced length, modernized intro, added concise feature + quick start sections.</li> <li>Pagination docs: Reformatted tables, spacing, clarified examples.</li> <li>Contributing docs: Expanded with setup, PR guidelines, issue template hints.</li> <li>Tutorial (CRUD &amp; Filtering): Table formatting, spacing normalization, improved examples.</li> <li>Favicon path moved <code>docs/img/favicon.ico</code> \u2192 <code>docs/images/favicon.ico</code>; logo updated.</li> <li>Index docs: Documentation URL switched to custom domain.</li> <li>MkDocs config:</li> <li><code>site_url</code> updated to <code>https://django-ninja-aio.com/</code>.</li> <li>Added logo/favicon references and rich navigation features.</li> <li>Expanded palette + features (search, code copy/select, tooltips, etc.).</li> <li>PyProject metadata: Documentation URL updated to new domain.</li> <li>Pagination imports switched to <code>from ninja.pagination</code> instead of local alias in examples.</li> <li>Refactor: <code>_m2m_views</code> now takes a single <code>M2MRelationSchema</code> and is invoked in a loop (improves clarity).</li> <li>Minor docstring spacing added before CRUD endpoint decorators.</li> <li>M2M registration: Logic unchanged functionally but simplified iteration pattern.</li> </ul> Removed <ul> <li>Legacy automatic loop inside <code>_m2m_views</code> (replaced by external loop in <code>_add_views</code>).</li> <li>Redundant long README sections (old serializer deep examples, extended auth/pagination prose).</li> </ul> Internal <ul> <li><code>_add_views</code> now iterates <code>self.m2m_relations</code> and calls <code>_m2m_views(relation)</code> for each.</li> <li>Consistent path/auth resolution maintained; no schema changes to public API.</li> <li>Added <code>use_directory_urls: true</code> explicitly in <code>mkdocs.yml</code>.</li> </ul> Impact <ul> <li>No breaking API changes.</li> <li>Documentation structure improved; search indexing benefits from new plugins.</li> <li>M2M internals slightly cleaner; external behavior stable.</li> </ul> Migration Notes <p>No action required for existing users.</p>v1.0.0diff2025-10-28Release notes1.0.0 - 2025-10-28 Added <ul> <li>Per\u2011relation M2M configuration via <code>M2MRelationSchema</code> (replaces tuples).</li> <li>Per\u2011relation flags: <code>add</code>, <code>remove</code>, <code>get</code>.</li> <li>Per\u2011relation <code>filters</code> with dynamic schema generation and hook <code>&lt;related_name&gt;_query_params_handler</code>.</li> <li>Method <code>_generate_m2m_filters_schemas</code> to build all M2M filter schemas.</li> <li>Query param injection for M2M GET: <code>filters: Query[filters_schema] = None</code>.</li> <li>Extended docstrings for <code>APIViewSet</code> and internal helper methods.</li> <li>Overridable hooks documented in docs (<code>query_params_handler</code>, per\u2011relation handlers).</li> <li>Changelog: version bump to <code>__version__ = \"1.0.0\"</code>.</li> </ul> Changed <ul> <li><code>api_view_set.md</code> rewritten: tuple-based M2M section replaced with <code>M2MRelationSchema</code> docs, new sections for filters, hooks, examples.</li> <li>CRUD table wording (schema_out formatting, notes clarified).</li> <li>Auth resolution notes now include M2M fallback logic.</li> <li>Internal view registration: per-relation flags extracted (<code>m2m_add/remove/get</code> replaced by schema attributes).</li> <li>Error message spacing adjusted in <code>_check_m2m_objs</code>.</li> <li>Refactored internal function docs (more concise, purpose-focused).</li> <li>Dynamic filter/path schemas built through unified <code>_generate_schema</code>.</li> </ul> Removed <ul> <li>Class attributes: <code>m2m_add</code>, <code>m2m_remove</code>, <code>m2m_get</code>.</li> <li>Tuple-based <code>m2m_relations</code> formats.</li> <li>Legacy verbose examples inside <code>views()</code> docstring.</li> <li>Redundant <code>m2m_auth</code> entry in auth table (moved to core attributes table).</li> </ul> Internal <ul> <li>Added per-method docstrings (<code>create_view</code>, <code>list_view</code>, <code>retrieve_view</code>, <code>update_view</code>, <code>delete_view</code>, <code>_m2m_views</code>, <code>_add_views</code>, etc.).</li> <li><code>_crud_views</code> now described as a mapping.</li> <li>Added storage of <code>self.m2m_filters_schemas</code> during init.</li> <li>GET M2M handler applies optional per-relation filter hook if present.</li> <li>Manage M2M handler chooses input schema dynamically (<code>M2MSchemaIn</code> / <code>M2MAddSchemaIn</code> / <code>M2MRemoveSchemaIn</code>).</li> </ul> Migration Notes <p>Old: <code>python m2m_relations = [     (Tag, \"tags\"),     (Category, \"categories\", \"article-categories\"),     (Author, \"authors\", \"co-authors\", [AdminAuth()]) ] m2m_add = True m2m_remove = True m2m_get = True</code></p> <p>New: ```python from ninja_aio.schemas import M2MRelationSchema</p> <p>m2m_relations = [     M2MRelationSchema(model=Tag, related_name=\"tags\"),     M2MRelationSchema(model=Category, related_name=\"categories\", path=\"article-categories\"),     M2MRelationSchema(model=Author, related_name=\"authors\", path=\"co-authors\", auth=[AdminAuth()]) ]</p> <p>```</p> <p>Per\u2011relation filters: ```python M2MRelationSchema(     model=Tag,     related_name=\"tags\",     filters={\"name\": (str, \"\")} )</p> <p>async def tags_query_params_handler(self, queryset, filters):     if filters.get(\"name\"):         queryset = queryset.filter(name__icontains=filters[\"name\"])     return queryset ```</p> Breaking Changes <ul> <li><code>m2m_relations</code> must use <code>M2MRelationSchema</code> (no tuples).</li> <li>Removed <code>m2m_add</code>, <code>m2m_remove</code>, <code>m2m_get</code> (use per-relation flags).</li> <li>Any code unpacking relation tuples must be updated to attribute access.</li> </ul> Summary <p>Release focuses on granular M2M configuration, per\u2011relation filtering, cleaner internals, and clearer documentation for extensibility.</p>v0.11.4diff2025-10-28Release notes0.11.4 - 2025-10-28 Changed <ul> <li>Documentation heading renamed from <code># API ViewSet</code> to <code># APIViewSet</code>.</li> <li>Docs rewritten: long examples replaced with concise endpoint table and structured attribute sections.</li> <li>Core attributes table expanded (added <code>pagination_class</code>, <code>query_params</code>, <code>disable</code>, endpoint doc strings).</li> <li>Clarified authentication resolution; explicit mention of <code>m2m_auth</code>.</li> </ul> Added <ul> <li>Per-relation M2M configuration: support for 3- and 4-element tuples in <code>m2m_relations</code>.</li> <li>3 elements: <code>(model, related_name, custom_path)</code></li> <li>4 elements: <code>(model, related_name, custom_path, per_relation_auth)</code></li> <li>Per-relation auth override (local <code>m2m_auth</code> inside <code>_m2m_views</code> loop).</li> <li>Documentation of M2M path/auth resolution rules.</li> </ul> Removed <ul> <li>Global <code>m2m_path</code> attribute (replaced by per-relation path tuple element).</li> <li>Old <code>m2m_relations</code> signature <code>list[tuple[ModelSerializer | Model, str]]</code>.</li> </ul> Internal Implementation <ul> <li>M2M loop updated: <code>for m2m_data in self.m2m_relations:</code> with dynamic tuple length parsing.</li> <li>Path resolution:   <code>python   rel_path = rel_util.verbose_name_path_resolver() if not m2m_path else m2m_path</code></li> <li>Auth passed to decorators as <code>auth=m2m_auth</code> instead of <code>auth=self.m2m_auth</code>.</li> <li>Continued use of <code>@unique_view(...)</code> for stable handler naming.</li> </ul> Migration Notes <p>```python</p> <p>m2m_relations = [(Tag, \"tags\")] m2m_path = \"custom-tags\"  # no longer supported</p> <p>m2m_relations = [     (Tag, \"tags\"),                                 # auto path + fallback auth     (Category, \"categories\", \"custom-categories\"), # custom path     (Author, \"authors\", \"article-authors\", [AdminAuth()])  # custom path + custom auth ] <code>`` - Remove any</code>m2m_path` usage. - 2-element tuples remain valid (no breaking change).</p> Summary <p>Improved flexibility and granularity for M2M relation configuration and streamlined documentation.</p>v0.11.3diff2025-10-28Release notes[0.11.3] - 2025-10-28 Added <ul> <li>M2M Path Customization: Added <code>m2m_path</code> attribute to <code>APIViewSet</code> for custom many-to-many relationship endpoint paths</li> <li>Default: empty string (uses auto-generated path from model verbose name)</li> <li>Allows overriding the default path resolution for M2M endpoints</li> </ul> Changed APIViewSet Class Attributes <ul> <li>m2m_relations type annotation: Changed from <code>tuple[ModelSerializer | Model, str]</code> to <code>list[tuple[ModelSerializer | Model, str]]</code></li> <li>More flexible and mutable data structure</li> <li>Allows dynamic modification of M2M relations at runtime</li> </ul> Code Quality &amp; Formatting <ul> <li>Consistent blank lines: Added blank lines after function returns for better code readability</li> <li>Applied to: <code>create_view()</code>, <code>list_view()</code>, <code>retrieve_view()</code>, <code>update_view()</code>, <code>delete_view()</code></li> <li>Removed extra blank line: Cleaned up unnecessary blank line in <code>delete_view()</code> method</li> <li>M2M views refactoring: Improved code structure for many-to-many relationship views</li> <li>Applied <code>@unique_view</code> decorator to M2M endpoints (<code>get_related</code>, <code>manage_related</code>)</li> <li>Removed manual <code>__name__</code> assignment in favor of decorator pattern</li> <li>Better separation of concerns between GET and POST operations</li> <li>Moved conditional M2M add/remove logic outside of the GET endpoint block</li> </ul> M2M Endpoint Generation <ul> <li>Dynamic path resolution: M2M endpoints now respect custom <code>m2m_path</code> attribute   ```python   rel_path = (       rel_util.verbose_name_path_resolver()       if not self.m2m_path       else self.m2m_path   )</li> </ul>v0.11.1diff2025-10-28-Release notes<p>No release notes.</p>v0.11.0diff2025-10-26-Release notes<p>No release notes.</p>v0.10.3diff2025-09-23-Release notes<p>No release notes.</p>v0.10.2diff2025-09-18-Release notes<p>No release notes.</p>v0.10.1diff2025-09-18-Release notes<p>No release notes.</p>v0.10.0diff2025-09-15-Release notes<p>No release notes.</p>0.9.2diff2025-08-25-Release notes<p>No release notes.</p>v0.9.1diff2025-08-25-Release notes<p>No release notes.</p>v0.9.0diff2025-07-18-Release notes<p>No release notes.</p>v0.8.4diff2025-06-20-Release notes<p>No release notes.</p>v0.8.3diff2025-06-18-Release notes<p>No release notes.</p>v0.8.2diff2025-06-18-Release notes<p>No release notes.</p>v0.8.1diff2025-06-18-Release notes<p>No release notes.</p>v0.8.0diff2025-05-15-Release notes<p>No release notes.</p>v0.7.8diff2025-03-21-Release notes<p>No release notes.</p>v0.7.7diff2025-03-05-Release notes<p>No release notes.</p>v0.7.6diff2025-02-24-Release notes<p>No release notes.</p>v0.7.5diff2025-02-22-Release notes<p>No release notes.</p>v0.7.4diff2025-02-20-Release notes<p>No release notes.</p>v0.7.3diff2025-02-19-Release notes<p>No release notes.</p>v0.7.2diff2025-01-30-Release notes<p>No release notes.</p>v0.7.1diff2025-01-29-Release notes<p>No release notes.</p>v0.7.0diff2025-01-29-Release notes<p>No release notes.</p>v0.6.4diff2025-01-22-Release notes<p>No release notes.</p>v0.6.3diff2025-01-22-Release notes<p>No release notes.</p>v0.6.2diff2025-01-19-Release notes<p>No release notes.</p>v0.6.1diff2025-01-13-Release notes<p>No release notes.</p>v0.6.0diff2025-01-12-Release notes<p>No release notes.</p>v0.5.0diff2025-01-09-Release notes<p>No release notes.</p>v0.4.0diff2025-01-08-Release notes<p>No release notes.</p>v0.3.1diff2024-11-07-Release notes<p>No release notes.</p>v0.3.0diff2024-10-10-Release notes<p>No release notes.</p>v0.2.2diff2024-10-03-Release notes<p>No release notes.</p>v0.2.1diff2024-10-02-Release notes<p>No release notes.</p>v0.2.0diff2024-10-01-Release notes<p>No release notes.</p>v0.1.4diff2024-09-29-Release notes<p>No release notes.</p>v0.1.3diff2024-09-28-Release notes<p>No release notes.</p>v0.1.2diff2024-09-26-Release notes<p>No release notes.</p>v0.1.1diff2024-09-26-Release notes<p>No release notes.</p>"},{"location":"api/authentication/","title":"Authentication","text":"<p>Django Ninja Aio CRUD provides built-in async JWT authentication support with flexible configuration and easy integration with your API endpoints.</p>"},{"location":"api/authentication/#overview","title":"Overview","text":"<p>Authentication in Django Ninja Aio CRUD: - Fully Async - No blocking operations - JWT-Based - Industry-standard JSON Web Tokens - Type-Safe - Proper type hints and validation - Flexible - Per-endpoint or global authentication - Customizable - Override default behavior - RSA/HMAC Support - Multiple signing algorithms</p>"},{"location":"api/authentication/#quick-start","title":"Quick Start","text":""},{"location":"api/authentication/#1-create-authentication-class","title":"1. Create Authentication Class","text":"Python<pre><code># auth.py\nfrom ninja_aio.auth import AsyncJwtBearer\nfrom joserfc import jwk\n\nPUBLIC_KEY = \"\"\"-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...\n-----END PUBLIC KEY-----\"\"\"\n\n\nclass JWTAuth(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(PUBLIC_KEY)\n    claims = {\n        \"iss\": {\"essential\": True, \"value\": \"https://your-issuer.com\"},\n        \"aud\": {\"essential\": True, \"value\": \"your-api\"}\n    }\n\n    async def auth_handler(self, request):\n        user_id = self.dcd.claims.get(\"sub\")\n        user = await User.objects.aget(id=user_id)\n        return user\n</code></pre>"},{"location":"api/authentication/#2-apply-to-viewset","title":"2. Apply to ViewSet","text":"Python<pre><code># views.py\nfrom ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom .models import Article\nfrom .auth import JWTAuth\n\napi = NinjaAIO()\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    auth = [JWTAuth()]  # Apply to all endpoints\n\n\nArticleViewSet().add_views_to_route()\n</code></pre>"},{"location":"api/authentication/#3-make-authenticated-request","title":"3. Make Authenticated Request","text":"Bash<pre><code>curl -H \"Authorization: Bearer eyJhbGciOiJSUzI1NiIs...\" \\\n     http://localhost:8000/api/article/\n</code></pre>"},{"location":"api/authentication/#asyncjwtbearer","title":"AsyncJwtBearer","text":"<p>Base class for JWT authentication.</p>"},{"location":"api/authentication/#class-definition","title":"Class Definition","text":"Python<pre><code>from ninja_aio.auth import AsyncJwtBearer\nfrom joserfc import jwk\n\nclass MyAuth(AsyncJwtBearer):\n    jwt_public: jwk.RSAKey | jwk.OctKey  # Public key for verification\n    jwt_alg: str = \"RS256\"  # Signing algorithm\n    claims: dict = {}  # Required claims\n\n    async def auth_handler(self, request):\n        # Return user object or custom auth context\n        pass\n</code></pre>"},{"location":"api/authentication/#required-attributes","title":"Required Attributes","text":""},{"location":"api/authentication/#jwt_public","title":"<code>jwt_public</code>","text":"<p>Public key for JWT verification.</p> <p>RSA Key (Recommended):</p> Python<pre><code>from joserfc import jwk\n\nPUBLIC_KEY = \"\"\"-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...\n-----END PUBLIC KEY-----\"\"\"\n\nclass JWTAuth(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(PUBLIC_KEY)\n    jwt_alg = \"RS256\"\n</code></pre> <p>HMAC Key (Shared Secret):</p> Python<pre><code>from joserfc import jwk\n\nSECRET = \"your-secret-key\"\n\nclass JWTAuth(AsyncJwtBearer):\n    jwt_public = jwk.OctKey.import_key(SECRET)\n    jwt_alg = \"HS256\"\n</code></pre> <p>From JWK (JSON Web Key):</p> Python<pre><code>import json\nfrom joserfc import jwk\n\njwk_data = {\n    \"kty\": \"RSA\",\n    \"n\": \"xGOr-H7A-PWgPZ...\",\n    \"e\": \"AQAB\",\n    \"alg\": \"RS256\",\n    \"use\": \"sig\"\n}\n\nclass JWTAuth(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(jwk_data)\n</code></pre>"},{"location":"api/authentication/#jwt_alg","title":"<code>jwt_alg</code>","text":"<p>JWT signing algorithm (optional, default: <code>\"RS256\"</code>).</p> <p>Supported Algorithms:</p> Algorithm Type Description <code>RS256</code> RSA RSA Signature with SHA-256 (recommended) <code>RS384</code> RSA RSA Signature with SHA-384 <code>RS512</code> RSA RSA Signature with SHA-512 <code>HS256</code> HMAC HMAC with SHA-256 <code>HS384</code> HMAC HMAC with SHA-384 <code>HS512</code> HMAC HMAC with SHA-512 <code>ES256</code> ECDSA ECDSA with SHA-256 <code>ES384</code> ECDSA ECDSA with SHA-384 <code>ES512</code> ECDSA ECDSA with SHA-512 Python<pre><code>class JWTAuth(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(PUBLIC_KEY)\n    jwt_alg = \"RS512\"  # Use RS512 instead of default RS256\n</code></pre>"},{"location":"api/authentication/#claims","title":"<code>claims</code>","text":"<p>Dictionary of required JWT claims for validation.</p> <p>Claim Options:</p> Key Type Description <code>essential</code> <code>bool</code> Claim must be present <code>value</code> <code>Any</code> Exact value required <code>values</code> <code>list</code> One of the values required <p>Examples:</p> Python<pre><code>class JWTAuth(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(PUBLIC_KEY)\n    claims = {\n        # Issuer must be exact match\n        \"iss\": {\n            \"essential\": True,\n            \"value\": \"https://auth.example.com\"\n        },\n        # Audience must be one of these\n        \"aud\": {\n            \"essential\": True,\n            \"values\": [\"api-prod\", \"api-staging\"]\n        },\n        # Subject must be present (any value)\n        \"sub\": {\n            \"essential\": True\n        },\n        # Optional claim with default\n        \"scope\": {\n            \"essential\": False,\n            \"value\": \"read\"\n        }\n    }\n</code></pre>"},{"location":"api/authentication/#required-methods","title":"Required Methods","text":""},{"location":"api/authentication/#auth_handler","title":"<code>auth_handler()</code>","text":"<p>Process authenticated request and return user/auth context.</p> <p>Signature:</p> Python<pre><code>async def auth_handler(self, request: HttpRequest) -&gt; Any\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>request</code> <code>HttpRequest</code> Django HTTP request <p>Return Value:</p> <p>Object attached to <code>request.auth</code> (typically User instance).</p> <p>Access to JWT Data:</p> <ul> <li><code>self.dcd</code> - Decoded JWT claims</li> <li><code>self.dcd.claims</code> - Claims dictionary</li> <li><code>self.dcd.header</code> - JWT header</li> </ul> <p>Examples:</p> <p>Return User Object:</p> Python<pre><code>async def auth_handler(self, request):\n    user_id = self.dcd.claims.get(\"sub\")\n    user = await User.objects.aget(id=user_id)\n    return user\n\n# In view\nasync def my_view(request):\n    user = request.auth  # User instance\n    print(user.username)\n</code></pre> <p>Return Custom Context:</p> Python<pre><code>async def auth_handler(self, request):\n    return {\n        \"user_id\": self.dcd.claims.get(\"sub\"),\n        \"email\": self.dcd.claims.get(\"email\"),\n        \"roles\": self.dcd.claims.get(\"roles\", []),\n        \"scopes\": self.dcd.claims.get(\"scope\", \"\").split()\n    }\n\n# In view\nasync def my_view(request):\n    context = request.auth\n    print(context[\"user_id\"])\n    print(context[\"roles\"])\n</code></pre> <p>With Additional Validation:</p> Python<pre><code>async def auth_handler(self, request):\n    user_id = self.dcd.claims.get(\"sub\")\n\n    # Check if user exists and is active\n    try:\n        user = await User.objects.aget(id=user_id, is_active=True)\n    except User.DoesNotExist:\n        return False\n\n    # Check subscription status\n    if not await user.has_active_subscription():\n        return False\n\n    return user\n</code></pre> <p>With Caching:</p> Python<pre><code>from django.core.cache import cache\n\nasync def auth_handler(self, request):\n    user_id = self.dcd.claims.get(\"sub\")\n\n    # Try cache first\n    cache_key = f\"user:{user_id}\"\n    user = cache.get(cache_key)\n\n    if user is None:\n        user = await User.objects.aget(id=user_id)\n        cache.set(cache_key, user, 300)  # Cache 5 minutes\n\n    return user\n</code></pre>"},{"location":"api/authentication/#authentication-levels","title":"Authentication Levels","text":""},{"location":"api/authentication/#global-authentication","title":"Global Authentication","text":"<p>Apply authentication to all endpoints in a ViewSet:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    auth = [JWTAuth()]  # All endpoints require auth\n</code></pre> <p>Generated Endpoints:</p> Method Endpoint Auth Required GET <code>/article/</code> \u2713 POST <code>/article/</code> \u2713 GET <code>/article/{id}</code> \u2713 PATCH <code>/article/{id}/</code> \u2713 DELETE <code>/article/{id}/</code> \u2713"},{"location":"api/authentication/#per-method-authentication","title":"Per-Method Authentication","text":"<p>Apply authentication to specific HTTP methods:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    get_auth = None  # GET endpoints public\n    post_auth = [JWTAuth()]  # POST requires auth\n    patch_auth = [JWTAuth()]  # PATCH requires auth\n    delete_auth = [JWTAuth()]  # DELETE requires auth\n</code></pre> <p>Generated Endpoints:</p> Method Endpoint Auth Required GET <code>/article/</code> \u2717 (public) POST <code>/article/</code> \u2713 GET <code>/article/{id}</code> \u2717 (public) PATCH <code>/article/{id}/</code> \u2713 DELETE <code>/article/{id}/</code> \u2713"},{"location":"api/authentication/#custom-view-authentication","title":"Custom View Authentication","text":"<p>Apply authentication to custom views:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    auth = None  # CRUD endpoints public\n\n    def views(self):\n        # Authenticated custom endpoint\n        @self.router.post(\"/publish/{pk}/\", auth=JWTAuth())\n        async def publish(request, pk: int):\n            article = await Article.objects.aget(pk=pk)\n            article.is_published = True\n            await article.asave()\n            return {\"message\": \"Article published\"}\n\n        # Public custom endpoint\n        @self.router.get(\"/stats/\")\n        async def stats(request):\n            total = await Article.objects.acount()\n            return {\"total\": total}\n</code></pre>"},{"location":"api/authentication/#mixed-authentication","title":"Mixed Authentication","text":"<p>Combine different authentication strategies:</p> Python<pre><code>class AdminAuth(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(PUBLIC_KEY)\n\n    async def auth_handler(self, request):\n        user_id = self.dcd.claims.get(\"sub\")\n        user = await User.objects.aget(id=user_id)\n        if not user.is_staff:\n            return False\n        return user\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    get_auth = None  # Public read\n    post_auth = [JWTAuth()]  # Regular user can create\n    patch_auth = [JWTAuth()]  # Regular user can edit own\n    delete_auth = [AdminAuth()]  # Only admin can delete\n</code></pre>"},{"location":"api/authentication/#advanced-usage","title":"Advanced Usage","text":""},{"location":"api/authentication/#role-based-access-control-rbac","title":"Role-Based Access Control (RBAC)","text":"Python<pre><code>class RoleAuth(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(PUBLIC_KEY)\n    required_roles: list[str] = []\n\n    async def auth_handler(self, request):\n        user_id = self.dcd.claims.get(\"sub\")\n        user = await User.objects.aget(id=user_id)\n\n        # Check roles\n        user_roles = self.dcd.claims.get(\"roles\", [])\n        if self.required_roles:\n            if not any(role in user_roles for role in self.required_roles):\n                return False\n\n        request.user_roles = user_roles\n        return user\n\n\nclass AdminAuth(RoleAuth):\n    required_roles = [\"admin\"]\n\n\nclass EditorAuth(RoleAuth):\n    required_roles = [\"editor\", \"admin\"]\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    get_auth = None\n    post_auth = [EditorAuth()]  # Editors and admins\n    delete_auth = [AdminAuth()]  # Only admins\n</code></pre>"},{"location":"api/authentication/#permission-based-access","title":"Permission-Based Access","text":"Python<pre><code>class PermissionAuth(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(PUBLIC_KEY)\n    required_permissions: list[str] = []\n\n    async def auth_handler(self, request):\n        user_id = self.dcd.claims.get(\"sub\")\n        user = await User.objects.select_related('role').aget(id=user_id)\n\n        # Get user permissions\n        permissions = await sync_to_async(list)(\n            user.role.permissions.values_list('code', flat=True)\n        )\n\n        # Check permissions\n        if self.required_permissions:\n            missing = set(self.required_permissions) - set(permissions)\n            if missing:\n                return False\n        request.permissions = permissions\n        return user\n\n\nclass ArticleCreateAuth(PermissionAuth):\n    required_permissions = [\"article.create\"]\n\n\nclass ArticleDeleteAuth(PermissionAuth):\n    required_permissions = [\"article.delete\"]\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    post_auth = [ArticleCreateAuth()]\n    delete_auth = [ArticleDeleteAuth()]\n</code></pre>"},{"location":"api/authentication/#tenantorganization-isolation","title":"Tenant/Organization Isolation","text":"Python<pre><code>class TenantAuth(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(PUBLIC_KEY)\n\n    async def auth_handler(self, request):\n        user_id = self.dcd.claims.get(\"sub\")\n        tenant_id = self.dcd.claims.get(\"tenant_id\")\n\n        if not tenant_id:\n            return False\n\n        user = await User.objects.aget(\n            id=user_id,\n            tenant_id=tenant_id,\n            is_active=True\n        )\n\n        request.tenant_id = tenant_id\n        return user\n\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    tenant = models.ForeignKey(Tenant, on_delete=models.CASCADE)\n\n    @classmethod\n    async def queryset_request(cls, request):\n        # Automatically filter by tenant\n        qs = cls.objects.all()\n        if hasattr(request, 'tenant_id'):\n            qs = qs.filter(tenant_id=request.tenant_id)\n        return qs\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    auth = [TenantAuth()]\n</code></pre>"},{"location":"api/authentication/#scope-based-access","title":"Scope-Based Access","text":"Python<pre><code>class ScopeAuth(AsyncJwtBearer):\n    jwt_public = jwk.RSAKey.import_key(PUBLIC_KEY)\n    required_scopes: list[str] = []\n\n    async def auth_handler(self, request):\n        # Get scopes from token\n        scope_str = self.dcd.claims.get(\"scope\", \"\")\n        scopes = scope_str.split()\n\n        # Check required scopes\n        if self.required_scopes:\n            missing = set(self.required_scopes) - set(scopes)\n            if missing:\n                return False\n\n        user_id = self.dcd.claims.get(\"sub\")\n        user = await User.objects.aget(id=user_id)\n\n        request.scopes = scopes\n        return user\n\n\nclass ReadAuth(ScopeAuth):\n    required_scopes = [\"read\"]\n\n\nclass WriteAuth(ScopeAuth):\n    required_scopes = [\"write\"]\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    get_auth = [ReadAuth()]  # read scope\n    post_auth = [WriteAuth()]  # write scope\n    patch_auth = [WriteAuth()]  # write scope\n    delete_auth = [WriteAuth()]  # write scope\n</code></pre>"},{"location":"api/authentication/#api-key-authentication","title":"API Key Authentication","text":"<p>For machine-to-machine communication:</p> Python<pre><code>from ninja.security import APIKeyHeader\n\n\nclass APIKeyAuth(APIKeyHeader):\n    param_name = \"X-API-Key\"\n\n    async def authenticate(self, request, key):\n        try:\n            api_key = await APIKey.objects.select_related('user').aget(\n                key=key,\n                is_active=True\n            )\n\n            # Check expiration\n            if api_key.expires_at and api_key.expires_at &lt; timezone.now():\n                return None\n\n            # Update last used\n            api_key.last_used_at = timezone.now()\n            await api_key.asave(update_fields=['last_used_at'])\n\n            return api_key.user\n        except APIKey.DoesNotExist:\n            return None\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    auth = [APIKeyAuth()]\n</code></pre> <p>Usage:</p> Bash<pre><code>curl -H \"X-API-Key: your-api-key-here\" \\\n     http://localhost:8000/api/article/\n</code></pre>"},{"location":"api/authentication/#multiple-authentication-methods","title":"Multiple Authentication Methods","text":"<p>Support both JWT and API Key:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    auth = [JWTAuth(), APIKeyAuth()]  # Either JWT or API Key\n</code></pre> <p>Django Ninja will try both methods; if either succeeds, the request is authenticated.</p>"},{"location":"api/authentication/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Use RSA (asymmetric) keys for production: Python<pre><code>jwt_public = jwk.RSAKey.import_key(PUBLIC_KEY)\njwt_alg = \"RS256\"\n</code></pre></p> </li> <li> <p>Validate essential claims: Python<pre><code>claims = {\n    \"iss\": {\"essential\": True, \"value\": \"your-issuer\"},\n    \"aud\": {\"essential\": True, \"value\": \"your-api\"},\n    \"sub\": {\"essential\": True}\n}\n</code></pre></p> </li> <li> <p>Keep tokens short-lived: Python<pre><code># In your token issuer\nexp = datetime.utcnow() + timedelta(minutes=15)  # 15 min access token\n</code></pre></p> </li> <li> <p>Cache user objects: Python<pre><code>async def auth_handler(self, request):\n    user_id = self.dcd.claims.get(\"sub\")\n    cache_key = f\"user:{user_id}\"\n    user = cache.get(cache_key)\n    if not user:\n        user = await User.objects.aget(id=user_id)\n        cache.set(cache_key, user, 300)\n    return user\n</code></pre></p> </li> <li> <p>Log authentication failures: Python<pre><code>async def auth_handler(self, request):\n    try:\n        user = await User.objects.aget(id=user_id)\n        return user\n    except User.DoesNotExist:\n        logger.warning(f\"Auth failed for user_id: {user_id}\")\n        return False\n</code></pre></p> </li> <li> <p>Use different auth for different operations: Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    get_auth = None  # Public read\n    post_auth = [UserAuth()]  # User can create\n    delete_auth = [AdminAuth()]  # Only admin can delete\n</code></pre></p> </li> <li> <p>Implement rate limiting for auth endpoints: Python<pre><code>from ninja.throttling import AnonRateThrottle\n\n@api.post(\"/login/\", throttle=[AnonRateThrottle('5/minute')])\nasync def login(request, credentials: LoginSchema):\n    # Login logic\n    pass\n</code></pre></p> </li> </ol>"},{"location":"api/authentication/#integration-examples","title":"Integration Examples","text":""},{"location":"api/authentication/#with-auth0","title":"With Auth0","text":"Python<pre><code>import httpx\nfrom joserfc import jwk\n\n\nclass Auth0JWT(AsyncJwtBearer):\n    jwt_alg = \"RS256\"\n\n    def __init__(self):\n        super().__init__()\n        # Fetch JWKS from Auth0\n        self.domain = \"your-domain.auth0.com\"\n        self.audience = \"your-api-identifier\"\n\n    async def get_jwks(self):\n        async with httpx.AsyncClient() as client:\n            response = await client.get(\n                f\"https://{self.domain}/.well-known/jwks.json\"\n            )\n            return response.json()\n\n    claims = {\n        \"iss\": {\"essential\": True, \"value\": \"https://your-domain.auth0.com/\"},\n        \"aud\": {\"essential\": True, \"value\": \"your-api-identifier\"}\n    }\n\n    async def auth_handler(self, request):\n        user_id = self.dcd.claims.get(\"sub\")\n        # Extract user info from token or fetch from database\n        return {\"user_id\": user_id, \"email\": self.dcd.claims.get(\"email\")}\n</code></pre>"},{"location":"api/authentication/#with-keycloak","title":"With Keycloak","text":"Python<pre><code>class KeycloakJWT(AsyncJwtBearer):\n    jwt_alg = \"RS256\"\n\n    def __init__(self):\n        super().__init__()\n        self.realm_url = \"https://keycloak.example.com/realms/your-realm\"\n\n    async def get_public_key(self):\n        async with httpx.AsyncClient() as client:\n            response = await client.get(f\"{self.realm_url}\")\n            data = response.json()\n            return jwk.RSAKey.import_key(data[\"public_key\"])\n\n    claims = {\n        \"iss\": {\"essential\": True, \"value\": \"https://keycloak.example.com/realms/your-realm\"},\n        \"azp\": {\"essential\": True, \"value\": \"your-client-id\"}\n    }\n\n    async def auth_handler(self, request):\n        user_id = self.dcd.claims.get(\"sub\")\n        roles = self.dcd.claims.get(\"realm_access\", {}).get(\"roles\", [])\n        return {\n            \"user_id\": user_id,\n            \"roles\": roles,\n            \"email\": self.dcd.claims.get(\"email\")\n        }\n</code></pre>"},{"location":"api/authentication/#with-firebase","title":"With Firebase","text":"Python<pre><code>import google.auth.transport.requests\nfrom google.oauth2 import id_token\n\n\nclass FirebaseAuth(HttpBearer):\n    def __init__(self):\n        self.project_id = \"your-firebase-project\"\n\n    async def authenticate(self, request, token):\n        try:\n            # Verify Firebase ID token\n            decoded_token = id_token.verify_firebase_token(\n                token,\n                google.auth.transport.requests.Request(),\n                audience=self.project_id\n            )\n\n            user_id = decoded_token[\"uid\"]\n            user = await User.objects.aget(firebase_uid=user_id)\n            return user\n        except Exception as e:\n            return None\n</code></pre>"},{"location":"api/authentication/#see-also","title":"See Also","text":"<ul> <li>API ViewSet - Applying auth to ViewSets</li> <li>Tutorial: Authentication - Step-by-step guide</li> <li>Model Serializer - Filtering by authenticated user</li> </ul>"},{"location":"api/pagination/","title":"Pagination","text":"<p>Django Ninja Aio CRUD provides built-in async pagination support for efficiently handling large datasets in your API responses.</p>"},{"location":"api/pagination/#overview","title":"Overview","text":"<p>Pagination in Django Ninja Aio CRUD:</p> <ul> <li>Fully async - No blocking database queries</li> <li>Customizable - Override default behavior per ViewSet</li> <li>Type-safe - Proper type hints and validation</li> <li>Automatic - Works out of the box with APIViewSet</li> <li>Flexible - Support for multiple pagination styles</li> </ul>"},{"location":"api/pagination/#default-pagination","title":"Default Pagination","text":""},{"location":"api/pagination/#pagenumberpagination","title":"PageNumberPagination","text":"<p>The default pagination class used by <code>APIViewSet</code>.</p> <p>Features:</p> <ul> <li>Page-based navigation</li> <li>Configurable page size</li> <li>Total count included</li> <li>Next/previous page info</li> </ul> <p>Default Configuration:</p> Parameter Default Description <code>page</code> <code>1</code> Current page number <code>page_size</code> <code>10</code> Items per page <code>max_page_size</code> <code>100</code> Maximum allowed page size"},{"location":"api/pagination/#response-format","title":"Response Format","text":"JSON<pre><code>{\n  \"count\": 45,\n  \"next\": 3,\n  \"previous\": 1,\n  \"results\": [\n    {\n      \"id\": 11,\n      \"title\": \"Article 11\",\n      \"created_at\": \"2024-01-15T10:30:00Z\"\n    },\n    {\n      \"id\": 12,\n      \"title\": \"Article 12\",\n      \"created_at\": \"2024-01-15T11:00:00Z\"\n    }\n  ]\n}\n</code></pre> <p>Response Fields:</p> Field Type Description <code>count</code> <code>int</code> Total number of items <code>next</code> <code>int \\| None</code> Next page number (null if last page) <code>previous</code> <code>int \\| None</code> Previous page number (null if first page) <code>results</code> <code>list</code> Array of items for current page"},{"location":"api/pagination/#basic-usage","title":"Basic Usage","text":""},{"location":"api/pagination/#with-apiviewset","title":"With APIViewSet","text":"<p>Pagination is automatically applied to list endpoints:</p> Python<pre><code>from ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom .models import Article\n\napi = NinjaAIO()\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n\nArticleViewSet().add_views_to_route()\n</code></pre> <p>Generated endpoint:</p> Text Only<pre><code>GET /article/?page=1&amp;page_size=10\n</code></pre>"},{"location":"api/pagination/#manual-usage","title":"Manual Usage","text":"Python<pre><code>from ninja.pagination import PageNumberPagination\nfrom django.http import HttpRequest\n\nasync def my_view(request: HttpRequest):\n    # Get queryset\n    queryset = Article.objects.all()\n\n    # Create paginator\n    paginator = PageNumberPagination()\n\n    # Paginate (accepts query params from request)\n    result = await paginator.apaginate_queryset(\n        queryset=queryset,\n        pagination=paginator,\n        request=request\n    )\n\n    return result\n</code></pre>"},{"location":"api/pagination/#query-parameters","title":"Query Parameters","text":""},{"location":"api/pagination/#page","title":"page","text":"<p>Current page number (1-indexed).</p> Bash<pre><code>GET /article/?page=2\n</code></pre> <p>Validation:</p> <ul> <li>Must be &gt;= 1</li> <li>Returns 404 if page doesn't exist</li> </ul>"},{"location":"api/pagination/#page_size","title":"page_size","text":"<p>Number of items per page.</p> Bash<pre><code>GET /article/?page=1&amp;page_size=20\n</code></pre> <p>Validation:</p> <ul> <li>Must be &gt;= 1</li> <li>Cannot exceed <code>max_page_size</code></li> <li>Defaults to pagination class default</li> </ul>"},{"location":"api/pagination/#examples","title":"Examples","text":"<p>First page with 10 items:</p> Bash<pre><code>GET /article/?page=1&amp;page_size=10\n</code></pre> <p>Second page with 25 items:</p> Bash<pre><code>GET /article/?page=2&amp;page_size=25\n</code></pre> <p>Maximum items per page:</p> Bash<pre><code>GET /article/?page=1&amp;page_size=100\n</code></pre>"},{"location":"api/pagination/#custom-pagination","title":"Custom Pagination","text":""},{"location":"api/pagination/#override-default-page-size","title":"Override Default Page Size","text":"Python<pre><code>from ninja.pagination import PageNumberPagination\n\n\nclass LargePagePagination(PageNumberPagination):\n    page_size = 50  # Default 50 items per page\n    max_page_size = 200  # Allow up to 200 items\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    pagination_class = LargePagePagination\n</code></pre>"},{"location":"api/pagination/#small-page-size-for-mobile","title":"Small Page Size for Mobile","text":"Python<pre><code>class MobilePagination(PageNumberPagination):\n    page_size = 5\n    max_page_size = 20\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    pagination_class = MobilePagination\n</code></pre>"},{"location":"api/pagination/#asyncpaginationbase","title":"AsyncPaginationBase","text":"<p>Base class for creating custom pagination.</p>"},{"location":"api/pagination/#class-definition","title":"Class Definition","text":"Python<pre><code>from ninja.pagination import AsyncPaginationBase\n\nclass MyPagination(AsyncPaginationBase):\n    page_size: int = 10\n    max_page_size: int = 100\n\n    async def apaginate_queryset(\n        self,\n        queryset,\n        pagination,\n        request=None,\n        **params\n    ):\n        # Custom pagination logic\n        pass\n</code></pre>"},{"location":"api/pagination/#required-methods","title":"Required Methods","text":""},{"location":"api/pagination/#apaginate_queryset","title":"<code>apaginate_queryset()</code>","text":"<p>Main pagination method that processes the queryset.</p> <p>Signature:</p> Python<pre><code>async def apaginate_queryset(\n    self,\n    queryset: QuerySet,\n    pagination: AsyncPaginationBase,\n    request: HttpRequest = None,\n    **params\n) -&gt; dict\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>queryset</code> <code>QuerySet</code> Django queryset to paginate <code>pagination</code> <code>AsyncPaginationBase</code> Pagination instance <code>request</code> <code>HttpRequest</code> HTTP request object <code>**params</code> <code>dict</code> Additional parameters <p>Returns:</p> <p>Dictionary with pagination metadata and results.</p>"},{"location":"api/pagination/#custom-pagination-examples","title":"Custom Pagination Examples","text":""},{"location":"api/pagination/#cursor-based-pagination","title":"Cursor-Based Pagination","text":"Python<pre><code>from ninja.pagination import AsyncPaginationBase\nfrom ninja import Schema\n\n\nclass CursorPaginationSchema(Schema):\n    cursor: str | None = None\n    page_size: int = 10\n\n\nclass CursorPagination(AsyncPaginationBase):\n    page_size = 10\n    max_page_size = 100\n\n    async def apaginate_queryset(self, queryset, pagination, request=None, **params):\n        cursor = params.get('cursor')\n        page_size = min(params.get('page_size', self.page_size), self.max_page_size)\n\n        # Apply cursor filtering\n        if cursor:\n            queryset = queryset.filter(id__gt=cursor)\n\n        # Fetch items + 1 to check if there's next page\n        items = []\n        async for item in queryset[:page_size + 1]:\n            items.append(item)\n\n        has_next = len(items) &gt; page_size\n        results = items[:page_size]\n\n        next_cursor = None\n        if has_next and results:\n            next_cursor = str(results[-1].id)\n\n        return {\n            \"next_cursor\": next_cursor,\n            \"results\": results\n        }\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    pagination_class = CursorPagination\n</code></pre> <p>Usage:</p> Bash<pre><code># First page\nGET /article/?page_size=10\n\n# Next page\nGET /article/?cursor=10&amp;page_size=10\n</code></pre> <p>Response:</p> JSON<pre><code>{\n  \"next_cursor\": \"20\",\n  \"results\": [...]\n}\n</code></pre>"},{"location":"api/pagination/#offset-based-pagination","title":"Offset-Based Pagination","text":"Python<pre><code>class OffsetPagination(AsyncPaginationBase):\n    page_size = 10\n    max_page_size = 100\n\n    async def apaginate_queryset(self, queryset, pagination, request=None, **params):\n        offset = params.get('offset', 0)\n        limit = min(params.get('limit', self.page_size), self.max_page_size)\n\n        # Get total count\n        total_count = await queryset.acount()\n\n        # Slice queryset\n        items = []\n        async for item in queryset[offset:offset + limit]:\n            items.append(item)\n\n        return {\n            \"count\": total_count,\n            \"offset\": offset,\n            \"limit\": limit,\n            \"results\": items\n        }\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    pagination_class = OffsetPagination\n</code></pre> <p>Usage:</p> Bash<pre><code># First 10 items\nGET /article/?offset=0&amp;limit=10\n\n# Next 10 items\nGET /article/?offset=10&amp;limit=10\n\n# Skip 20, get 15\nGET /article/?offset=20&amp;limit=15\n</code></pre> <p>Response:</p> JSON<pre><code>{\n  \"count\": 100,\n  \"offset\": 20,\n  \"limit\": 15,\n  \"results\": [...]\n}\n</code></pre>"},{"location":"api/pagination/#link-header-pagination","title":"Link Header Pagination","text":"Python<pre><code>from django.http import HttpResponse\n\n\nclass LinkHeaderPagination(AsyncPaginationBase):\n    page_size = 10\n    max_page_size = 100\n\n    async def apaginate_queryset(self, queryset, pagination, request=None, **params):\n        page = params.get('page', 1)\n        page_size = min(params.get('page_size', self.page_size), self.max_page_size)\n\n        total_count = await queryset.acount()\n        total_pages = (total_count + page_size - 1) // page_size\n\n        start = (page - 1) * page_size\n        end = start + page_size\n\n        items = []\n        async for item in queryset[start:end]:\n            items.append(item)\n\n        # Build Link header\n        base_url = request.build_absolute_uri(request.path)\n        links = []\n\n        if page &gt; 1:\n            links.append(f'&lt;{base_url}?page={page-1}&amp;page_size={page_size}&gt;; rel=\"prev\"')\n        if page &lt; total_pages:\n            links.append(f'&lt;{base_url}?page={page+1}&amp;page_size={page_size}&gt;; rel=\"next\"')\n\n        links.append(f'&lt;{base_url}?page=1&amp;page_size={page_size}&gt;; rel=\"first\"')\n        links.append(f'&lt;{base_url}?page={total_pages}&amp;page_size={page_size}&gt;; rel=\"last\"')\n\n        return {\n            \"results\": items,\n            \"_links\": \", \".join(links)\n        }\n</code></pre> <p>Response Headers:</p> Text Only<pre><code>Link: &lt;http://api.example.com/article/?page=1&amp;page_size=10&gt;; rel=\"first\",\n      &lt;http://api.example.com/article/?page=2&amp;page_size=10&gt;; rel=\"prev\",\n      &lt;http://api.example.com/article/?page=4&amp;page_size=10&gt;; rel=\"next\",\n      &lt;http://api.example.com/article/?page=10&amp;page_size=10&gt;; rel=\"last\"\n</code></pre>"},{"location":"api/pagination/#disable-pagination","title":"Disable Pagination","text":""},{"location":"api/pagination/#for-specific-viewset","title":"For Specific ViewSet","text":"Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    pagination_class = None  # Disable pagination\n</code></pre> <p>Now the list endpoint returns all items without pagination:</p> Bash<pre><code>GET /article/\n</code></pre> JSON<pre><code>[\n  {\"id\": 1, \"title\": \"Article 1\"},\n  {\"id\": 2, \"title\": \"Article 2\"},\n  ...\n]\n</code></pre>"},{"location":"api/pagination/#conditional-pagination","title":"Conditional Pagination","text":"Python<pre><code>class ConditionalPagination(PageNumberPagination):\n    async def apaginate_queryset(self, queryset, pagination, request=None, **params):\n        # Disable pagination if 'all' parameter is present\n        if params.get('all'):\n            items = []\n            async for item in queryset:\n                items.append(item)\n            return {\"results\": items}\n\n        # Otherwise use default pagination\n        return await super().apaginate_queryset(queryset, pagination, request, **params)\n</code></pre> <p>Usage:</p> Bash<pre><code># Paginated\nGET /article/?page=1&amp;page_size=10\n\n# All items\nGET /article/?all=true\n</code></pre>"},{"location":"api/pagination/#integration-with-filtering","title":"Integration with Filtering","text":"<p>Pagination works seamlessly with query parameter filtering:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    query_params = {\n        \"is_published\": (bool, None),\n        \"category\": (int, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        if filters.get(\"is_published\") is not None:\n            queryset = queryset.filter(is_published=filters[\"is_published\"])\n        if filters.get(\"category\"):\n            queryset = queryset.filter(category_id=filters[\"category\"])\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># Filter + pagination\nGET /article/?is_published=true&amp;category=5&amp;page=2&amp;page_size=20\n</code></pre> <p>The filtering is applied first, then pagination is applied to the filtered queryset.</p>"},{"location":"api/pagination/#performance-optimization","title":"Performance Optimization","text":""},{"location":"api/pagination/#count-optimization","title":"Count Optimization","text":"<p>For large datasets, counting can be expensive. Cache the count:</p> Python<pre><code>from django.core.cache import cache\n\n\nclass OptimizedPagination(PageNumberPagination):\n    async def apaginate_queryset(self, queryset, pagination, request=None, **params):\n        page = params.get('page', 1)\n        page_size = min(params.get('page_size', self.page_size), self.max_page_size)\n\n        # Try to get cached count\n        cache_key = f\"count_{queryset.model.__name__}\"\n        total_count = cache.get(cache_key)\n\n        if total_count is None:\n            total_count = await queryset.acount()\n            cache.set(cache_key, total_count, 300)  # Cache for 5 minutes\n\n        # Rest of pagination logic\n        start = (page - 1) * page_size\n        end = start + page_size\n\n        items = []\n        async for item in queryset[start:end]:\n            items.append(item)\n\n        return {\n            \"count\": total_count,\n            \"page\": page,\n            \"page_size\": page_size,\n            \"results\": items\n        }\n</code></pre>"},{"location":"api/pagination/#select-related-prefetch-related","title":"Select Related / Prefetch Related","text":"<p>Optimize queries when paginating related data:</p> Python<pre><code>class Article(ModelSerializer):\n    author = models.ForeignKey(User, on_delete=models.CASCADE)\n    category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True)\n    tags = models.ManyToManyField(Tag, related_name=\"articles\")\n\n    @classmethod\n    async def queryset_request(cls, request):\n        # Optimize queries before pagination\n        return cls.objects.select_related(\n            'author',\n            'category'\n        ).prefetch_related(\n            'tags'\n        )\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n</code></pre> <p>Now pagination queries are optimized:</p> SQL<pre><code>-- Single query with joins instead of N+1\nSELECT article.*, user.*, category.*\nFROM article\nLEFT JOIN user ON article.author_id = user.id\nLEFT JOIN category ON article.category_id = category.id\nLIMIT 10 OFFSET 0;\n</code></pre>"},{"location":"api/pagination/#approximate-counts","title":"Approximate Counts","text":"<p>For very large tables, use approximate counts:</p> Python<pre><code>class ApproximatePagination(PageNumberPagination):\n    async def apaginate_queryset(self, queryset, pagination, request=None, **params):\n        from django.db import connection\n\n        # Get approximate count from PostgreSQL statistics\n        with connection.cursor() as cursor:\n            cursor.execute(\n                \"SELECT reltuples::bigint FROM pg_class WHERE relname = %s\",\n                [queryset.model._meta.db_table]\n            )\n            approximate_count = cursor.fetchone()[0]\n\n        # Rest of pagination logic using approximate_count\n        # ...\n</code></pre>"},{"location":"api/pagination/#error-handling","title":"Error Handling","text":""},{"location":"api/pagination/#invalid-page-number","title":"Invalid Page Number","text":"Python<pre><code># Request\nGET /article/?page=999&amp;page_size=10\n\n# Response (404)\n{\n  \"detail\": \"Invalid page.\"\n}\n</code></pre>"},{"location":"api/pagination/#invalid-page-size","title":"Invalid Page Size","text":"Python<pre><code># Request\nGET /article/?page=1&amp;page_size=1000\n\n# Automatically clamped to max_page_size (100)\n# Response\n{\n  \"count\": 45,\n  \"page\": 1,\n  \"page_size\": 100,\n  \"results\": [...]\n}\n</code></pre>"},{"location":"api/pagination/#custom-error-handling","title":"Custom Error Handling","text":"Python<pre><code>class StrictPagination(PageNumberPagination):\n    async def apaginate_queryset(self, queryset, pagination, request=None, **params):\n        page_size = params.get('page_size', self.page_size)\n\n        if page_size &gt; self.max_page_size:\n            raise ValueError(\n                f\"page_size cannot exceed {self.max_page_size}\"\n            )\n\n        # Continue with pagination\n        # ...\n</code></pre>"},{"location":"api/pagination/#testing-pagination","title":"Testing Pagination","text":"Python<pre><code>import pytest\nfrom ninja.testing import TestAsyncClient\nfrom myapp.views import api\n\n\n@pytest.mark.asyncio\nasync def test_pagination():\n    client = TestAsyncClient(api)\n\n    # Create test data\n    for i in range(25):\n        await Article.objects.acreate(title=f\"Article {i}\")\n\n    # Test first page\n    response = await client.get(\"/article/?page=1&amp;page_size=10\")\n    assert response.status_code == 200\n    data = response.json()\n    assert data[\"count\"] == 25\n    assert len(data[\"results\"]) == 10\n    assert data[\"next\"] == 2\n    assert data[\"previous\"] is None\n\n    # Test middle page\n    response = await client.get(\"/article/?page=2&amp;page_size=10\")\n    data = response.json()\n    assert len(data[\"results\"]) == 10\n    assert data[\"next\"] == 3\n    assert data[\"previous\"] == 1\n\n    # Test last page\n    response = await client.get(\"/article/?page=3&amp;page_size=10\")\n    data = response.json()\n    assert len(data[\"results\"]) == 5\n    assert data[\"next\"] is None\n    assert data[\"previous\"] == 2\n\n\n@pytest.mark.asyncio\nasync def test_invalid_page():\n    client = TestAsyncClient(api)\n\n    response = await client.get(\"/article/?page=999\")\n    assert response.status_code == 404\n\n\n@pytest.mark.asyncio\nasync def test_page_size_limit():\n    client = TestAsyncClient(api)\n\n    # Request exceeds max_page_size\n    response = await client.get(\"/article/?page=1&amp;page_size=1000\")\n    data = response.json()\n    assert len(data[\"results\"]) &lt;= 100  # Clamped to max_page_size\n</code></pre>"},{"location":"api/pagination/#best-practices","title":"Best Practices","text":"<ol> <li>Choose appropriate page size:</li> </ol> Python<pre><code># Mobile API\npage_size = 10\n\n# Desktop/Web API\npage_size = 25\n\n# Admin/Internal API\npage_size = 100\n</code></pre> <ol> <li>Set reasonable max_page_size:</li> </ol> Python<pre><code># Prevent excessive data transfer\nmax_page_size = 100\n</code></pre> <ol> <li>Cache expensive counts:</li> </ol> Python<pre><code># For large, slowly-changing datasets\ncache.set(f\"count_{model}\", count, timeout=300)\n</code></pre> <ol> <li>Optimize queries:</li> </ol> Python<pre><code>queryset = queryset.select_related(...).prefetch_related(...)\n</code></pre> <ol> <li>Use cursor pagination for infinite scroll:</li> </ol> Python<pre><code># Better for real-time feeds\nclass FeedPagination(CursorPagination):\n    page_size = 20\n</code></pre> <ol> <li>Consider approximate counts for huge tables: Python<pre><code># Faster than exact count for millions of rows\nuse_approximate = queryset.count() &gt; 1_000_000\n</code></pre></li> </ol>"},{"location":"api/pagination/#see-also","title":"See Also","text":"<ul> <li>API ViewSet - Using pagination with ViewSets</li> <li>Model Util - Query optimization</li> <li>Authentication - Securing paginated endpoints</li> </ul> <p>Next: Learn about Authentication to secure your API endpoints.</p>"},{"location":"api/models/model_serializer/","title":"Model Serializer","text":"<p><code>ModelSerializer</code> is a powerful abstract mixin for Django models that centralizes schema generation and serialization configuration directly on the model class.</p>"},{"location":"api/models/model_serializer/#overview","title":"Overview","text":"<p>Goals:</p> <ul> <li>Eliminate duplication between Model and separate serializer classes</li> <li>Provide clear extension points (sync + async hooks, custom synthetic fields)</li> <li>Auto-generate Ninja schemas from model metadata</li> <li>Support nested serialization for relationships</li> </ul> <p>Key Features:</p> <ul> <li>Declarative schema configuration via inner classes</li> <li>Automatic CRUD schema generation</li> <li>Nested relationship handling</li> <li>Sync and async lifecycle hooks</li> <li>Custom field support (computed/synthetic fields)</li> </ul>"},{"location":"api/models/model_serializer/#quick-start","title":"Quick Start","text":"Python<pre><code>from django.db import models\nfrom ninja_aio.models import ModelSerializer\n\nclass User(ModelSerializer):\n    username = models.CharField(max_length=150, unique=True)\n    email = models.EmailField(unique=True)\n\n    class CreateSerializer:\n        fields = [\"username\", \"email\"]\n\n    class ReadSerializer:\n        fields = [\"id\", \"username\", \"email\"]\n\n    def __str__(self):\n        return self.username\n</code></pre>"},{"location":"api/models/model_serializer/#inner-configuration-classes","title":"Inner Configuration Classes","text":""},{"location":"api/models/model_serializer/#createserializer","title":"CreateSerializer","text":"<p>Describes how to build a create (input) schema for a model.</p> <p>Attributes:</p> Attribute Type Description <code>fields</code> <code>list[str]</code> REQUIRED model field names for creation <code>optionals</code> <code>list[tuple[str, type]]</code> Optional model fields: <code>(field_name, python_type)</code> <code>customs</code> <code>list[tuple]</code> Synthetic inputs. Tuple forms: <code>(name, type)</code> = required (no default); <code>(name, type, default)</code> = optional (literal or callable) <code>excludes</code> <code>list[str]</code> Field names rejected on create <p>Example:</p> Python<pre><code>class User(ModelSerializer):\n    username = models.CharField(max_length=150)\n    email = models.EmailField()\n    password = models.CharField(max_length=128)\n    bio = models.TextField(blank=True)\n\n    class CreateSerializer:\n        fields = [\"username\", \"email\", \"password\"]\n        optionals = [\n            (\"bio\", str),\n        ]\n        customs = [\n            (\"password_confirm\", str),          # required (no default) equivalent of (\"password_confirm\", str, ...)\n            (\"send_welcome_email\", bool, True), # optional with default\n        ]\n        excludes = [\"id\", \"created_at\"]\n</code></pre> <p>Resolution Order for <code>customs</code>:</p> <ol> <li>Payload value (if provided)</li> <li>If default present and callable \u2192 invoked</li> <li>Literal default (if provided)</li> <li>If tuple was only (name, type) and no value supplied \u2192 validation error (required)</li> </ol> <p>Conceptual Equivalent (django-ninja):</p> Python<pre><code># Without ModelSerializer\nfrom ninja import ModelSchema\n\nclass UserIn(ModelSchema):\n    class Meta:\n        model = User\n        fields = [\"username\", \"email\"]\n</code></pre>"},{"location":"api/models/model_serializer/#readserializer","title":"ReadSerializer","text":"<p>Describes how to build a read (output) schema for a model.</p> <p>Attributes</p> Attribute Type Description <code>fields</code> <code>list[str]</code> REQUIRED. Model fields / related names explicitly included in the read (output) schema. <code>excludes</code> <code>list[str]</code> Fields / related names to always omit (takes precedence over <code>fields</code> and <code>optionals</code>). Use for sensitive or noisy data (e.g., passwords, internal flags). <code>customs</code> <code>list[tuple]</code> Computed / synthetic output values. Tuple formats:\u2022 <code>(name, type)</code> = required resolvable attribute (object attribute or property). Serialization error if not resolvable.\u2022 <code>(name, type, default)</code> = optional; default may be a callable (<code>lambda obj: ...</code>) or a literal value. <p>Example:</p> Python<pre><code>class User(ModelSerializer):\n    first_name = models.CharField(max_length=150)\n    last_name = models.CharField(max_length=150)\n    email = models.EmailField()\n    password = models.CharField(max_length=128)\n\n    class ReadSerializer:\n        fields = [\"id\", \"first_name\", \"last_name\", \"email\", \"created_at\"]\n        excludes = [\"password\"]\n        customs = [\n            (\"full_name\", str, lambda obj: f\"{obj.first_name} {obj.last_name}\".strip()),\n            (\"is_premium\", bool, lambda obj: obj.subscription.is_active if hasattr(obj, 'subscription') else False),\n        ]\n</code></pre> <p>Resolution Order for <code>customs</code>:</p> <ol> <li>Attribute / property on instance</li> <li>Callable default (if provided)</li> <li>Literal default</li> <li>If required (2\u2011tuple) and still unresolved \u2192 error</li> </ol> <p>Generated Output:</p> JSON<pre><code>{\n  \"id\": 1,\n  \"first_name\": \"John\",\n  \"last_name\": \"Doe\",\n  \"email\": \"john@example.com\",\n  \"created_at\": \"2024-01-15T10:30:00Z\",\n  \"full_name\": \"John Doe\",\n  \"is_premium\": true\n}\n</code></pre>"},{"location":"api/models/model_serializer/#detailserializer","title":"DetailSerializer","text":"<p>Describes how to build a detail (single object) output schema. Use this when you want the retrieve endpoint to return more fields than the list endpoint.</p> <p>Fallback Behavior: If <code>DetailSerializer</code> is not defined, <code>generate_detail_s()</code> automatically falls back to the read schema (same as <code>generate_read_s()</code>). This means you only need to define <code>DetailSerializer</code> when you want different fields for single-object retrieval vs list views.</p> <p>Attributes:</p> Attribute Type Description <code>fields</code> <code>list[str]</code> Model fields to include in detail view (falls back to ReadSerializer fields if not defined) <code>excludes</code> <code>list[str]</code> Fields to exclude from detail view <code>customs</code> <code>list[tuple]</code> Computed fields: <code>(name, type)</code> required; <code>(name, type, default)</code> optional <code>optionals</code> <code>list[tuple[str, type]]</code> Optional output fields <p>Example:</p> Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    summary = models.TextField()\n    content = models.TextField()\n    author = models.ForeignKey(User, on_delete=models.CASCADE)\n    tags = models.ManyToManyField(Tag)\n    view_count = models.IntegerField(default=0)\n\n    class ReadSerializer:\n        # List view: minimal fields for performance\n        fields = [\"id\", \"title\", \"summary\", \"author\"]\n\n    class DetailSerializer:\n        # Detail view: all fields including expensive relations\n        fields = [\"id\", \"title\", \"summary\", \"content\", \"author\", \"tags\", \"view_count\"]\n        customs = [\n            (\"reading_time\", int, lambda obj: len(obj.content.split()) // 200),\n        ]\n</code></pre> <p>Generated Output (List):</p> JSON<pre><code>[\n  {\"id\": 1, \"title\": \"Getting Started\", \"summary\": \"...\", \"author\": {...}},\n  {\"id\": 2, \"title\": \"Advanced Topics\", \"summary\": \"...\", \"author\": {...}}\n]\n</code></pre> <p>Generated Output (Detail):</p> JSON<pre><code>{\n  \"id\": 1,\n  \"title\": \"Getting Started\",\n  \"summary\": \"...\",\n  \"content\": \"Full article content here...\",\n  \"author\": {...},\n  \"tags\": [{\"id\": 1, \"name\": \"python\"}, {\"id\": 2, \"name\": \"django\"}],\n  \"view_count\": 1234,\n  \"reading_time\": 5\n}\n</code></pre>"},{"location":"api/models/model_serializer/#updateserializer","title":"UpdateSerializer","text":"<p>Describes how to build an update (partial/full) input schema.</p> <p>Attributes:</p> Attribute Type Description <code>fields</code> <code>list[str]</code> REQUIRED fields for update (rarely used) <code>optionals</code> <code>list[tuple[str, type]]</code> Updatable optional fields (typical for PATCH) <code>customs</code> <code>list[tuple]</code> Instruction fields: <code>(name, type)</code> required; <code>(name, type, default)</code> optional <code>excludes</code> <code>list[str]</code> Immutable fields that cannot be updated <p>Example:</p> Python<pre><code>class User(ModelSerializer):\n    username = models.CharField(max_length=150, unique=True)\n    email = models.EmailField()\n    bio = models.TextField(blank=True)\n    is_active = models.BooleanField(default=True)\n\n    class UpdateSerializer:\n        optionals = [\n            (\"email\", str),\n            (\"bio\", str),\n            (\"is_active\", bool),\n        ]\n        customs = [\n            (\"reset_password\", bool, False),  # optional flag\n            (\"rotate_token\", bool),          # required instruction\n        ]\n        excludes = [\"username\", \"created_at\", \"id\"]\n</code></pre> <p>Usage (PATCH request):</p> JSON<pre><code>{\n  \"email\": \"newemail@example.com\",\n  \"bio\": \"Updated bio\",\n  \"reset_password\": true\n}\n</code></pre>"},{"location":"api/models/model_serializer/#schema-generation","title":"Schema Generation","text":""},{"location":"api/models/model_serializer/#auto-generated-schemas","title":"Auto-Generated Schemas","text":"<p>ModelSerializer automatically generates five schema types:</p> Method Schema Type Purpose <code>generate_create_s()</code> Input (\"In\") POST endpoint payload <code>generate_update_s()</code> Input (\"Patch\") PATCH/PUT endpoint payload <code>generate_read_s(depth=1)</code> Output (\"Out\") List response with nested relations <code>generate_detail_s(depth=1)</code> Output (\"Detail\") Single object response (retrieve) <code>generate_related_s()</code> Output (\"Related\") Compact nested representation <p>Example:</p> Python<pre><code>class User(ModelSerializer):\n    username = models.CharField(max_length=150)\n    email = models.EmailField()\n\n    class CreateSerializer:\n        fields = [\"username\", \"email\"]\n\n    class ReadSerializer:\n        fields = [\"id\", \"username\", \"email\"]\n\n# Auto-generate schemas\nUserCreateSchema = User.generate_create_s()\nUserReadSchema = User.generate_read_s()\nUserDetailSchema = User.generate_detail_s()  # Falls back to read schema if DetailSerializer not defined\nUserUpdateSchema = User.generate_update_s()\nUserRelatedSchema = User.generate_related_s()\n</code></pre>"},{"location":"api/models/model_serializer/#nested-relationship-handling","title":"Nested Relationship Handling","text":"<p>ModelSerializer automatically serializes relationships if the related model is also a ModelSerializer.</p>"},{"location":"api/models/model_serializer/#foreignkey-forward","title":"ForeignKey (Forward)","text":"Python<pre><code>class Profile(ModelSerializer):\n    bio = models.TextField()\n\n    class ReadSerializer:\n        fields = [\"id\", \"bio\"]\n\nclass User(ModelSerializer):\n    username = models.CharField(max_length=150)\n    profile = models.ForeignKey(Profile, on_delete=models.CASCADE)\n\n    class ReadSerializer:\n        fields = [\"id\", \"username\", \"profile\"]\n</code></pre> <p>Output:</p> JSON<pre><code>{\n  \"id\": 1,\n  \"username\": \"john_doe\",\n  \"profile\": {\n    \"id\": 10,\n    \"bio\": \"Software developer\"\n  }\n}\n</code></pre>"},{"location":"api/models/model_serializer/#manytomany","title":"ManyToMany","text":"Python<pre><code>class Tag(ModelSerializer):\n    name = models.CharField(max_length=50)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\"]\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    tags = models.ManyToManyField(Tag, related_name=\"articles\")\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"tags\"]\n</code></pre> <p>Output:</p> JSON<pre><code>{\n  \"id\": 1,\n  \"title\": \"Getting Started\",\n  \"tags\": [\n    { \"id\": 1, \"name\": \"python\" },\n    { \"id\": 2, \"name\": \"django\" }\n  ]\n}\n</code></pre>"},{"location":"api/models/model_serializer/#reverse-relationships","title":"Reverse Relationships","text":"Python<pre><code>class Author(ModelSerializer):\n    name = models.CharField(max_length=200)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"books\"]  # Reverse FK\n\nclass Book(ModelSerializer):\n    title = models.CharField(max_length=200)\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"books\")\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\"]\n</code></pre> <p>Output:</p> JSON<pre><code>{\n  \"id\": 1,\n  \"name\": \"J.K. Rowling\",\n  \"books\": [\n    { \"id\": 1, \"title\": \"Harry Potter\" },\n    { \"id\": 2, \"title\": \"Fantastic Beasts\" }\n  ]\n}\n</code></pre>"},{"location":"api/models/model_serializer/#async-extension-points","title":"Async Extension Points","text":""},{"location":"api/models/model_serializer/#queryset_requestrequest","title":"<code>queryset_request(request)</code>","text":"<p>Filter queryset based on request context (user, permissions, tenant, etc.).</p> Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    author = models.ForeignKey(User, on_delete=models.CASCADE)\n    is_published = models.BooleanField(default=False)\n\n    @classmethod\n    async def queryset_request(cls, request):\n        qs = cls.objects.select_related('author').all()\n\n        # Non-authenticated users see only published\n        if not request.auth:\n            return qs.filter(is_published=True)\n\n        # Authors see their own + published\n        return qs.filter(\n            models.Q(author=request.auth) | models.Q(is_published=True)\n        )\n</code></pre>"},{"location":"api/models/model_serializer/#post_create","title":"<code>post_create()</code>","text":"<p>Execute async logic after object creation.</p> Python<pre><code>class User(ModelSerializer):\n    email = models.EmailField()\n\n    async def post_create(self):\n        # Send welcome email\n        from myapp.tasks import send_welcome_email\n        await send_welcome_email(self.email)\n\n        # Create related objects\n        await Profile.objects.acreate(user=self)\n\n        # Log creation\n        await AuditLog.objects.acreate(\n            action=\"user_created\",\n            user_id=self.id\n        )\n</code></pre>"},{"location":"api/models/model_serializer/#custom_actionspayload","title":"<code>custom_actions(payload)</code>","text":"<p>React to synthetic/custom fields from the payload.</p> Python<pre><code>class User(ModelSerializer):\n    password = models.CharField(max_length=128)\n\n    class CreateSerializer:\n        fields = [\"username\", \"email\", \"password\"]\n        customs = [\n            (\"password_confirm\", str, None),\n            (\"send_welcome_email\", bool, True),\n        ]\n\n    async def custom_actions(self, payload: dict):\n        # Validate password confirmation\n        if \"password_confirm\" in payload:\n            if payload[\"password_confirm\"] != self.password:\n                raise ValueError(\"Passwords do not match\")\n\n        # Send welcome email if requested\n        if payload.get(\"send_welcome_email\", True):\n            await send_email(self.email, \"Welcome!\")\n</code></pre>"},{"location":"api/models/model_serializer/#sync-lifecycle-hooks","title":"Sync Lifecycle Hooks","text":""},{"location":"api/models/model_serializer/#save-hooks","title":"Save Hooks","text":"Python<pre><code>class User(ModelSerializer):\n    username = models.CharField(max_length=150)\n    slug = models.SlugField(unique=True, blank=True)\n\n    def before_save(self):\n        \"\"\"Executed before every save (create + update)\"\"\"\n        if not self.slug:\n            self.slug = slugify(self.username)\n\n    def on_create_before_save(self):\n        \"\"\"Executed only on creation, before save\"\"\"\n        self.set_password(self.password)  # Hash password\n\n    def after_save(self):\n        \"\"\"Executed after every save\"\"\"\n        cache.delete(f\"user:{self.id}\")\n\n    def on_create_after_save(self):\n        \"\"\"Executed only after creation\"\"\"\n        send_welcome_email_sync(self.email)\n</code></pre> <p>Execution Order:</p> Text Only<pre><code>CREATE:\n1. on_create_before_save()\n2. before_save()\n3. super().save()\n4. on_create_after_save()\n5. after_save()\n\nUPDATE:\n1. before_save()\n2. super().save()\n3. after_save()\n</code></pre>"},{"location":"api/models/model_serializer/#delete-hook","title":"Delete Hook","text":"Python<pre><code>class User(ModelSerializer):\n\n    def on_delete(self):\n        \"\"\"Executed after object deletion\"\"\"\n        # Clean up related data\n        logger.info(f\"User {self.username} deleted\")\n\n        # Remove from cache\n        cache.delete(f\"user:{self.id}\")\n\n        # Archive data\n        ArchivedUser.objects.create(\n            username=self.username,\n            deleted_at=timezone.now()\n        )\n</code></pre>"},{"location":"api/models/model_serializer/#utility-methods","title":"Utility Methods","text":""},{"location":"api/models/model_serializer/#has_changedfield","title":"<code>has_changed(field)</code>","text":"<p>Check if a field value has changed compared to database.</p> Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    status = models.CharField(max_length=20)\n\n    def before_save(self):\n        if self.has_changed('status'):\n            if self.status == 'published':\n                self.published_at = timezone.now()\n                notify_subscribers(self)\n</code></pre>"},{"location":"api/models/model_serializer/#verbose_name_path_resolver","title":"<code>verbose_name_path_resolver()</code>","text":"<p>Get slugified plural verbose name for URL routing.</p> Python<pre><code>class BlogPost(ModelSerializer):\n    class Meta:\n        verbose_name_plural = \"blog posts\"\n\n# Returns: \"blog-posts\"\npath = BlogPost.verbose_name_path_resolver()\n</code></pre>"},{"location":"api/models/model_serializer/#modelutil","title":"ModelUtil","text":"<p>Helper class for async CRUD operations with ModelSerializer.</p>"},{"location":"api/models/model_serializer/#overview_1","title":"Overview","text":"Python<pre><code>from ninja_aio.models import ModelUtil\n\nutil = ModelUtil(User)\n</code></pre> <p>Key Responsibilities:</p> <ul> <li>Introspect model metadata</li> <li>Normalize inbound/outbound payloads</li> <li>Handle FK resolution and base64 decoding</li> <li>Prefetch reverse relations</li> <li>Invoke serializer hooks</li> </ul>"},{"location":"api/models/model_serializer/#key-methods","title":"Key Methods","text":""},{"location":"api/models/model_serializer/#get_objectrequest-pknone-filtersnone-gettersnone","title":"<code>get_object(request, pk=None, filters=None, getters=None)</code>","text":"<p>Fetch single object or queryset with optimized queries.</p> Python<pre><code># Get single object\nuser = await util.get_object(request, pk=1)\n\n# Get with filters\nactive_users = await util.get_object(\n    request,\n    filters={\"is_active\": True}\n)\n\n# Get with custom lookup\nuser = await util.get_object(\n    request,\n    getters={\"email\": \"john@example.com\"}\n)\n</code></pre> <p>Features:</p> <ul> <li>Automatic <code>select_related()</code> and <code>prefetch_related()</code></li> <li>Respects <code>queryset_request()</code> filtering</li> <li>Raises <code>SerializeError</code> (404) if not found</li> </ul>"},{"location":"api/models/model_serializer/#parse_input_datarequest-data","title":"<code>parse_input_data(request, data)</code>","text":"<p>Convert incoming schema to model-ready dict.</p> <p>Transformations:</p> <ol> <li>Strips custom fields (stored separately)</li> <li>Removes optional fields with <code>None</code> value</li> <li>Decodes BinaryField (base64 \u2192 bytes)</li> <li>Resolves FK IDs to model instances</li> </ol> Python<pre><code>from ninja import Schema\n\nclass UserCreateSchema(Schema):\n    username: str\n    email: str\n    profile_id: int\n    avatar: str  # base64 for BinaryField\n    send_welcome: bool  # custom field\n\ndata = UserCreateSchema(\n    username=\"john\",\n    email=\"john@example.com\",\n    profile_id=5,\n    avatar=\"iVBORw0KG...\",  # base64\n    send_welcome=True\n)\n\npayload, customs = await util.parse_input_data(request, data)\n\n# payload = {\n#     \"username\": \"john\",\n#     \"email\": \"john@example.com\",\n#     \"profile\": &lt;Profile instance&gt;,\n#     \"avatar\": b'\\x89PNG\\r\\n...'\n# }\n# customs = {\"send_welcome\": True}\n</code></pre>"},{"location":"api/models/model_serializer/#parse_output_datarequest-data","title":"<code>parse_output_data(request, data)</code>","text":"<p>Post-process serialized output for consistency.</p> <p>Transformations:</p> <ol> <li>Replaces nested FK dicts with actual instances</li> <li>Rewrites nested FK keys to <code>&lt;field&gt;_id</code> format</li> </ol> Python<pre><code># Before\n{\n    \"id\": 1,\n    \"author\": {\"id\": 10, \"profile\": {\"id\": 5}}\n}\n\n# After parse_output_data\n{\n    \"id\": 1,\n    \"author\": &lt;Author instance&gt;,\n    \"author_id\": 10,\n    \"profile_id\": 5\n}\n</code></pre>"},{"location":"api/models/model_serializer/#crud-operations","title":"CRUD Operations","text":""},{"location":"api/models/model_serializer/#create_srequest-data-obj_schema","title":"<code>create_s(request, data, obj_schema)</code>","text":"Python<pre><code>user_data = UserCreateSchema(username=\"john\", email=\"john@example.com\")\nresult = await util.create_s(request, user_data, UserReadSchema)\n\n# Executes:\n# 1. parse_input_data (normalize)\n# 2. Model.objects.acreate()\n# 3. custom_actions(customs)\n# 4. post_create()\n# 5. read_s (serialize response)\n</code></pre>"},{"location":"api/models/model_serializer/#read_srequest-obj-obj_schema","title":"<code>read_s(request, obj, obj_schema)</code>","text":"Python<pre><code>user = await User.objects.aget(id=1)\nresult = await util.read_s(request, user, UserReadSchema)\n# Returns parsed dict ready for API response\n</code></pre>"},{"location":"api/models/model_serializer/#update_srequest-data-pk-obj_schema","title":"<code>update_s(request, data, pk, obj_schema)</code>","text":"Python<pre><code>update_data = UserUpdateSchema(email=\"newemail@example.com\")\nresult = await util.update_s(request, update_data, 1, UserReadSchema)\n\n# Executes:\n# 1. get_object(pk)\n# 2. parse_input_data\n# 3. Update changed fields\n# 4. custom_actions(customs)\n# 5. obj.asave()\n# 6. read_s (serialize updated object)\n</code></pre>"},{"location":"api/models/model_serializer/#delete_srequest-pk","title":"<code>delete_s(request, pk)</code>","text":"Python<pre><code>await util.delete_s(request, 1)\n# Returns None\n</code></pre>"},{"location":"api/models/model_serializer/#error-handling","title":"Error Handling","text":"Python<pre><code>from ninja_aio.exceptions import SerializeError\n\ntry:\n    user = await util.get_object(request, pk=999)\nexcept SerializeError as e:\n    # e.details = {\"user\": \"not found\"}\n    # e.status_code = 404\n    pass\n\ntry:\n    await util.create_s(request, bad_data, UserReadSchema)\nexcept SerializeError as e:\n    # e.details = {\"avatar\": \"Invalid base64\"}\n    # e.status_code = 400\n    pass\n</code></pre>"},{"location":"api/models/model_serializer/#complete-example","title":"Complete Example","text":"Python<pre><code>from django.db import models\nfrom ninja_aio.models import ModelSerializer\nfrom django.utils.text import slugify\n\nclass Category(ModelSerializer):\n    name = models.CharField(max_length=100)\n    slug = models.SlugField(unique=True, blank=True)\n\n    class CreateSerializer:\n        fields = [\"name\"]\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"slug\"]\n\n    class UpdateSerializer:\n        optionals = [(\"name\", str)]\n\n    def before_save(self):\n        if not self.slug:\n            self.slug = slugify(self.name)\n\nclass Author(ModelSerializer):\n    name = models.CharField(max_length=200)\n    email = models.EmailField(unique=True)\n    bio = models.TextField(blank=True)\n\n    class CreateSerializer:\n        fields = [\"name\", \"email\"]\n        optionals = [(\"bio\", str)]\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"email\", \"bio\"]\n        customs = [\n            (\"post_count\", int, lambda obj: obj.articles.count()),\n        ]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"name\", str),\n            (\"email\", str),\n            (\"bio\", str),\n        ]\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    slug = models.SlugField(unique=True)\n    content = models.TextField()\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"articles\")\n    category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True)\n    tags = models.ManyToManyField('Tag', related_name=\"articles\")\n    is_published = models.BooleanField(default=False)\n    views = models.IntegerField(default=0)\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    class CreateSerializer:\n        fields = [\"title\", \"slug\", \"content\", \"author\", \"category\"]\n        customs = [\n            (\"notify_subscribers\", bool, True),\n        ]\n\n    class ReadSerializer:\n        fields = [\n            \"id\", \"title\", \"slug\", \"content\",\n            \"author\", \"category\", \"tags\",\n            \"is_published\", \"views\", \"created_at\"\n        ]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"title\", str),\n            (\"content\", str),\n            (\"category\", int),\n            (\"is_published\", bool),\n        ]\n        excludes = [\"slug\", \"author\", \"created_at\"]\n\n    @classmethod\n    async def queryset_request(cls, request):\n        qs = cls.objects.select_related('author', 'category').prefetch_related('tags')\n\n        if not request.auth:\n            return qs.filter(is_published=True)\n\n        return qs.filter(\n            models.Q(author=request.auth) | models.Q(is_published=True)\n        )\n\n    async def post_create(self):\n        await AuditLog.objects.acreate(\n            action=\"article_created\",\n            article_id=self.id,\n            author_id=self.author_id\n        )\n\n    async def custom_actions(self, payload: dict):\n        if payload.get(\"notify_subscribers\"):\n            await notify_new_article(self)\n\n    def before_save(self):\n        if self.has_changed('is_published') and self.is_published:\n            self.published_at = timezone.now()\n\nclass Tag(ModelSerializer):\n    name = models.CharField(max_length=50, unique=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\"]\n</code></pre>"},{"location":"api/models/model_serializer/#custom-fields-normalization","title":"Custom Fields Normalization","text":"<p>Custom tuples are normalized by <code>ModelSerializer.get_custom_fields()</code> to <code>(name, python_type, default)</code>.</p> <p>Accepted forms:</p> <ul> <li><code>(name, type)</code> -&gt; stored with <code>default = Ellipsis</code> (treated as required)</li> <li><code>(name, type, default)</code> -&gt; default kept (callable or literal)</li> </ul> <p>Invalid lengths raise <code>ValueError</code>.</p> <p>Example mix:</p> Python<pre><code>class CreateSerializer:\n    customs = [\n        (\"password_confirm\", str),           # required\n        (\"send_welcome\", bool, True),        # optional\n        (\"initial_quota\", int, lambda: 100)  # optional callable\n    ]\n</code></pre> <p>At runtime:</p> Python<pre><code># Normalized\n[\n  (\"password_confirm\", str, Ellipsis),\n  (\"send_welcome\", bool, True),\n  (\"initial_quota\", int, &lt;function ...&gt;)\n]\n</code></pre> <p>Required customs (Ellipsis) must be provided in input (create/update) or resolvable (read) or an error is raised.</p>"},{"location":"api/models/model_serializer/#error-cases","title":"Error Cases","text":"Situation Result 1\u2011item or 4\u2011item tuple ValueError Missing required custom (2\u2011tuple) in payload Validation error Unresolvable required read custom Serialization error"},{"location":"api/models/model_serializer/#best-practices","title":"Best Practices","text":"<ol> <li>Always exclude sensitive fields:</li> </ol> Python<pre><code>class ReadSerializer:\n    excludes = [\"password\", \"secret_key\", \"internal_id\"]\n</code></pre> <ol> <li>Use optionals for PATCH operations:</li> </ol> Python<pre><code>class UpdateSerializer:\n    optionals = [(\"email\", str), (\"bio\", str)]  # Partial updates\n</code></pre> <ol> <li>Leverage customs for computed data:</li> </ol> Python<pre><code>customs = [\n    (\"full_name\", str, lambda obj: f\"{obj.first_name} {obj.last_name}\"),\n]\n</code></pre> <ol> <li>Optimize queries in queryset_request:</li> </ol> Python<pre><code>@classmethod\nasync def queryset_request(cls, request):\n    return cls.objects.select_related('author').prefetch_related('tags')\n</code></pre> <ol> <li>Keep hooks focused: Python<pre><code>async def post_create(self):\n    # Do ONE thing well\n    await send_welcome_email(self.email)\n</code></pre></li> </ol>"},{"location":"api/models/model_serializer/#see-also","title":"See Also","text":"<ul> <li>Model Util - Deep dive into ModelUtil</li> <li>API ViewSet - Using ModelSerializer with ViewSets</li> <li>Authentication - Securing endpoints</li> </ul>"},{"location":"api/models/model_util/","title":"Model Util","text":"<p><code>ModelUtil</code> is an async utility class that provides high-level CRUD operations and serialization management for Django models and ModelSerializer instances.</p>"},{"location":"api/models/model_util/#overview","title":"Overview","text":"<p>ModelUtil acts as a bridge between Django Ninja schemas and Django ORM, handling:</p> <ul> <li>Data normalization (input/output)</li> <li>Relationship resolution (FK/M2M)</li> <li>Binary field handling (base64 encoding/decoding)</li> <li>Query optimization (select_related/prefetch_related)</li> <li>Lifecycle hook invocation (custom_actions, post_create, queryset_request)</li> </ul>"},{"location":"api/models/model_util/#class-definition","title":"Class Definition","text":"Python<pre><code>from ninja_aio.models import ModelUtil\n\nutil = ModelUtil(model, serializer_class=None)\n</code></pre> <p>Parameters:</p> <ul> <li><code>model</code> (<code>type[ModelSerializer] | models.Model</code>): Django model or ModelSerializer subclass</li> <li><code>serializer_class</code> (<code>Serializer | None</code>): Optional Serializer class for plain Django models</li> </ul>"},{"location":"api/models/model_util/#properties","title":"Properties","text":""},{"location":"api/models/model_util/#with_serializer","title":"<code>with_serializer</code>","text":"<p>Indicates if a serializer_class is associated.</p> Python<pre><code>util = ModelUtil(User, serializer_class=UserSerializer)\nprint(util.with_serializer)  # True\n</code></pre>"},{"location":"api/models/model_util/#pk_field_type","title":"<code>pk_field_type</code>","text":"<p>Returns the Python type corresponding to the model's primary key field.</p> Python<pre><code>util = ModelUtil(User)\nprint(util.pk_field_type)  # &lt;class 'int'&gt;\n</code></pre> <p>Uses the Django field's internal type and <code>ninja.orm.fields.TYPES</code> mapping. Raises <code>ConfigError</code> if the internal type is not registered.</p>"},{"location":"api/models/model_util/#model_pk_name","title":"<code>model_pk_name</code>","text":"<p>Returns the primary key field name.</p> Python<pre><code>util = ModelUtil(User)\nprint(util.model_pk_name)  # \"id\"\n</code></pre>"},{"location":"api/models/model_util/#model_fields","title":"<code>model_fields</code>","text":"<p>Returns a list of all model field names.</p> Python<pre><code>util = ModelUtil(User)\nprint(util.model_fields)\n# [\"id\", \"username\", \"email\", \"created_at\", \"is_active\"]\n</code></pre>"},{"location":"api/models/model_util/#serializable_fields","title":"<code>serializable_fields</code>","text":"<p>Returns serializable fields for read operations (ReadSerializer fields or all model fields).</p> Python<pre><code>class User(ModelSerializer):\n    username = models.CharField(max_length=150)\n    password = models.CharField(max_length=128)\n    email = models.EmailField()\n\n    class ReadSerializer:\n        fields = [\"id\", \"username\", \"email\"]\n\nutil = ModelUtil(User)\nprint(util.serializable_fields)\n# [\"id\", \"username\", \"email\"]  (password excluded)\n</code></pre>"},{"location":"api/models/model_util/#serializable_detail_fields","title":"<code>serializable_detail_fields</code>","text":"<p>Returns serializable fields for detail operations (DetailSerializer fields, or falls back to ReadSerializer fields).</p> Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    summary = models.TextField()\n    content = models.TextField()\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"summary\"]\n\n    class DetailSerializer:\n        fields = [\"id\", \"title\", \"summary\", \"content\"]\n\nutil = ModelUtil(Article)\nprint(util.serializable_fields)        # [\"id\", \"title\", \"summary\"]\nprint(util.serializable_detail_fields) # [\"id\", \"title\", \"summary\", \"content\"]\n</code></pre>"},{"location":"api/models/model_util/#model_name","title":"<code>model_name</code>","text":"<p>Returns the Django internal model name.</p> Python<pre><code>util = ModelUtil(User)\nprint(util.model_name)  # \"user\"\n</code></pre>"},{"location":"api/models/model_util/#serializer_meta","title":"<code>serializer_meta</code>","text":"<p>Returns the ModelSerializerMeta instance if model uses ModelSerializer.</p> Python<pre><code>if util.serializer_meta:\n    fields = util.serializer_meta.get_fields(\"create\")\n</code></pre>"},{"location":"api/models/model_util/#queryset-configuration-on-modelserializer","title":"QuerySet configuration on ModelSerializer","text":"<p>You can declare query optimizations directly on your ModelSerializer via a nested QuerySet:</p> Python<pre><code>from ninja_aio.models import ModelSerializer\nfrom ninja_aio.schemas.helpers import ModelQuerySetSchema, ModelQuerySetExtraSchema\n\nclass Book(ModelSerializer):\n    # ...existing fields...\n\n    class QuerySet:\n        read = ModelQuerySetSchema(\n            select_related=[\"author\", \"category\"],\n            prefetch_related=[\"tags\"],\n        )\n        detail = ModelQuerySetSchema(\n            select_related=[\"author\", \"category\", \"publisher\"],\n            prefetch_related=[\"tags\", \"reviews\"],\n        )\n        queryset_request = ModelQuerySetSchema(\n            select_related=[],\n            prefetch_related=[\"related_items\"],\n        )\n        extras = [\n            ModelQuerySetExtraSchema(\n                scope=\"detail_cards\",\n                select_related=[\"author\"],\n                prefetch_related=[\"tags\"],\n            )\n        ]\n</code></pre> <ul> <li>read: applied to list operations (<code>is_for=\"read\"</code>).</li> <li>detail: applied to retrieve operations (<code>is_for=\"detail\"</code>). Falls back to <code>read</code> if not defined.</li> <li>queryset_request: applied inside queryset_request hook.</li> <li>extras: named configurations available via QueryUtil.SCOPES.</li> </ul>"},{"location":"api/models/model_util/#queryutil","title":"QueryUtil","text":"<p>Each ModelSerializer now exposes a query_util helper:</p> Python<pre><code>util = MyModel.query_util\nqs = util.apply_queryset_optimizations(MyModel.objects.all(), util.SCOPES.READ)\n</code></pre> <ul> <li>SCOPES: includes READ, QUERYSET_REQUEST, plus any extras you've defined.</li> <li>apply_queryset_optimizations: applies select_related/prefetch_related for a scope.</li> </ul>"},{"location":"api/models/model_util/#query-schemas","title":"Query schemas","text":"<p>New helper schemas standardize filters and getters:</p> Python<pre><code>from ninja_aio.schemas.helpers import (\n    QuerySchema,           # generic: filters or getters\n    ObjectQuerySchema,     # getters + select/prefetch\n    ObjectsQuerySchema,    # filters + select/prefetch\n    ModelQuerySetSchema,   # select/prefetch only\n)\n</code></pre>"},{"location":"api/models/model_util/#core-methods","title":"Core Methods","text":""},{"location":"api/models/model_util/#get_objects","title":"<code>get_objects</code>","text":"<p>Fetch an optimized queryset with optional filters and select/prefetch hints:</p> Python<pre><code>from ninja_aio.models import ModelUtil\nfrom ninja_aio.schemas.helpers import ObjectsQuerySchema\n\nqs = await ModelUtil(Book).get_objects(\n    request,\n    query_data=ObjectsQuerySchema(\n        filters={\"is_published\": True},\n        select_related=[\"author\"],\n        prefetch_related=[\"tags\"],\n    ),\n    with_qs_request=True,  # Apply queryset_request hook\n    is_for=\"read\",  # union with auto-discovered relations for read\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>request</code> (<code>HttpRequest</code>): Current HTTP request</li> <li><code>query_data</code> (<code>ObjectsQuerySchema | None</code>): Query configuration (filters, select_related, prefetch_related)</li> <li><code>with_qs_request</code> (<code>bool</code>): Apply queryset_request hook if available (default: True)</li> <li><code>is_for</code> (<code>Literal[\"read\", \"detail\"] | None</code>): Purpose of the query, determines which serializable fields to use for optimization. Use <code>\"read\"</code> for list operations, <code>\"detail\"</code> for retrieve operations. If <code>None</code>, only query_data optimizations are applied. (default: None)</li> </ul> <p>Returns: Optimized <code>QuerySet</code></p>"},{"location":"api/models/model_util/#get_object","title":"<code>get_object</code>","text":"<p>Fetch a single object by pk or getters with optimizations:</p> Python<pre><code>from ninja_aio.schemas.helpers import ObjectQuerySchema, QuerySchema\n\n# by pk + select/prefetch for detail view\nobj = await ModelUtil(Book).get_object(\n    request,\n    pk=42,\n    query_data=ObjectQuerySchema(select_related=[\"author\"]),\n    with_qs_request=True,\n    is_for=\"detail\",\n)\n\n# by getters (required if pk omitted)\nobj = await ModelUtil(Book).get_object(\n    request,\n    query_data=QuerySchema(getters={\"slug\": \"my-book-slug\"}),\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>request</code> (<code>HttpRequest</code>): Current HTTP request</li> <li><code>pk</code> (<code>int | str | None</code>): Primary key value (optional if getters provided)</li> <li><code>query_data</code> (<code>ObjectQuerySchema | QuerySchema | None</code>): Query configuration</li> <li><code>with_qs_request</code> (<code>bool</code>): Apply queryset_request hook if available (default: True)</li> <li><code>is_for</code> (<code>Literal[\"read\", \"detail\"] | None</code>): Purpose of the query. Use <code>\"detail\"</code> for single object retrieval, <code>\"read\"</code> for list operations. (default: None)</li> </ul> <p>Returns: Model instance</p> <p>Errors:</p> <ul> <li><code>ValueError</code> if neither pk nor getters provided</li> <li><code>NotFoundError</code> if no match found</li> </ul>"},{"location":"api/models/model_util/#read_s-and-list_read_s","title":"<code>read_s</code> and <code>list_read_s</code>","text":"<p>Uniform serialization methods that accept either instances or query data:</p> Python<pre><code>schema = Book.generate_read_s()\ndetail_schema = Book.generate_detail_s()\n\n# single instance\ndata = await ModelUtil(Book).read_s(schema, request, instance=obj)\n\n# single via getters (detail view)\ndata = await ModelUtil(Book).read_s(\n    detail_schema,\n    request,\n    query_data=ObjectQuerySchema(getters={\"pk\": 42}),\n    is_for=\"detail\",\n)\n\n# list from queryset\nitems = await ModelUtil(Book).list_read_s(schema, request, instances=qs)\n\n# list via filters\nitems = await ModelUtil(Book).list_read_s(\n    schema,\n    request,\n    query_data=ObjectsQuerySchema(filters={\"is_published\": True}),\n    is_for=\"read\",\n)\n</code></pre> <p>Parameters (read_s):</p> <ul> <li><code>schema</code> (<code>Schema</code>): Output schema for serialization</li> <li><code>request</code> (<code>HttpRequest</code>): Current HTTP request</li> <li><code>instance</code> (<code>Model | None</code>): Model instance to serialize (optional)</li> <li><code>query_data</code> (<code>ObjectQuerySchema | QuerySchema | None</code>): Query configuration for fetching (optional)</li> <li><code>is_for</code> (<code>Literal[\"read\", \"detail\"] | None</code>): Purpose of the query. Use <code>\"detail\"</code> for single object views, <code>\"read\"</code> for list views. (default: None)</li> </ul> <p>Parameters (list_read_s):</p> <ul> <li><code>schema</code> (<code>Schema</code>): Output schema for serialization</li> <li><code>request</code> (<code>HttpRequest</code>): Current HTTP request</li> <li><code>instances</code> (<code>QuerySet | list[Model] | None</code>): Instances to serialize (optional)</li> <li><code>query_data</code> (<code>ObjectsQuerySchema | None</code>): Query configuration for fetching (optional)</li> <li><code>is_for</code> (<code>Literal[\"read\", \"detail\"] | None</code>): Purpose of the query. Typically <code>\"read\"</code> for list views. (default: None)</li> </ul> <p>Behavior:</p> <ul> <li>When <code>is_for</code> is specified, select_related and prefetch_related are merged with model-discovered relations based on the operation type</li> <li>When <code>is_for=\"detail\"</code> but no <code>QuerySet.detail</code> is configured, falls back to <code>QuerySet.read</code> optimizations</li> <li>Passing <code>instance</code>/<code>instances</code> skips fetching; passing <code>query_data</code> fetches automatically</li> <li>Either <code>instance</code>/<code>instances</code> OR <code>query_data</code> must be provided, not both</li> </ul>"},{"location":"api/models/model_util/#get_reverse_relations","title":"<code>get_reverse_relations()</code>","text":"<p>Discovers reverse relationship field names for prefetch optimization.</p>"},{"location":"api/models/model_util/#signature","title":"Signature","text":"Python<pre><code>def get_reverse_relations() -&gt; list[str]\n</code></pre>"},{"location":"api/models/model_util/#return-value","title":"Return Value","text":"<p>List of reverse relation accessor names.</p>"},{"location":"api/models/model_util/#example","title":"Example","text":"Python<pre><code>class Author(ModelSerializer):\n    name = models.CharField(max_length=200)\n\nclass Book(ModelSerializer):\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"books\")\n\nutil = ModelUtil(Author)\nreverse_rels = util.get_reverse_relations()\nprint(reverse_rels)  # [\"books\"]\n</code></pre>"},{"location":"api/models/model_util/#detected-relation-types","title":"Detected Relation Types","text":"Django Descriptor Example Detected <code>ReverseManyToOneDescriptor</code> <code>author.books</code> \u2713 <code>ReverseOneToOneDescriptor</code> <code>user.profile</code> \u2713 <code>ManyToManyDescriptor</code> <code>article.tags</code> \u2713 <code>ForwardManyToOneDescriptor</code> <code>book.author</code> \u2717 <code>ForwardOneToOneDescriptor</code> <code>profile.user</code> \u2717"},{"location":"api/models/model_util/#use-case","title":"Use Case","text":"Python<pre><code># Avoid N+1 queries when serializing reverse relations\nrelations = util.get_reverse_relations()\nqueryset = Author.objects.prefetch_related(*relations)\n\n# Now iterating over authors won't trigger additional queries for books\nasync for author in queryset:\n    books = await sync_to_async(list)(author.books.all())  # No query!\n</code></pre>"},{"location":"api/models/model_util/#parse_input_data","title":"<code>parse_input_data()</code>","text":"<p>Normalize incoming schema data into model-ready dictionary.</p>"},{"location":"api/models/model_util/#signature_1","title":"Signature","text":"Python<pre><code>async def parse_input_data(\n    request: HttpRequest,\n    data: Schema\n) -&gt; tuple[dict, dict]\n</code></pre>"},{"location":"api/models/model_util/#parameters","title":"Parameters","text":"Parameter Type Description <code>request</code> <code>HttpRequest</code> Current HTTP request <code>data</code> <code>Schema</code> Ninja schema instance"},{"location":"api/models/model_util/#return-value_1","title":"Return Value","text":"<p><code>(payload, customs)</code> where:</p> <ul> <li><code>payload</code> (<code>dict</code>): Model-ready data with resolved relationships</li> <li><code>customs</code> (<code>dict</code>): Custom/synthetic fields stripped from payload</li> </ul>"},{"location":"api/models/model_util/#transformations","title":"Transformations","text":"<ol> <li>Strip custom fields \u2192 Move to <code>customs</code> dict</li> <li>Remove optional None values \u2192 Don't update if not provided</li> <li>Decode BinaryField \u2192 Convert base64 string to bytes</li> <li>Resolve FK IDs \u2192 Fetch related instances</li> </ol>"},{"location":"api/models/model_util/#examples","title":"Examples","text":"<p>Basic transformation:</p> Python<pre><code>from ninja import Schema\n\nclass UserCreateSchema(Schema):\n    username: str\n    email: str\n    bio: str | None = None\n\ndata = UserCreateSchema(\n    username=\"john_doe\",\n    email=\"john@example.com\",\n    bio=None  # Optional, not provided\n)\n\npayload, customs = await util.parse_input_data(request, data)\n\nprint(payload)\n# {\"username\": \"john_doe\", \"email\": \"john@example.com\"}\n# bio is omitted (None stripped)\n\nprint(customs)\n# {}\n</code></pre> <p>With custom fields:</p> Python<pre><code>class User(ModelSerializer):\n    username = models.CharField(max_length=150)\n    email = models.EmailField()\n\n    class CreateSerializer:\n        fields = [\"username\", \"email\"]\n        customs = [\n            (\"password_confirm\", str, None),\n            (\"send_welcome_email\", bool, True),\n        ]\n\n# Schema includes custom fields\ndata = UserCreateSchema(\n    username=\"john\",\n    email=\"john@example.com\",\n    password_confirm=\"secret123\",\n    send_welcome_email=False\n)\n\npayload, customs = await util.parse_input_data(request, data)\n\nprint(payload)\n# {\"username\": \"john\", \"email\": \"john@example.com\"}\n\nprint(customs)\n# {\"password_confirm\": \"secret123\", \"send_welcome_email\": False}\n</code></pre> <p>With ForeignKey resolution:</p> Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    author = models.ForeignKey(User, on_delete=models.CASCADE)\n    category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True)\n\n# Input schema expects IDs\ndata = ArticleCreateSchema(\n    title=\"Getting Started\",\n    author=5,      # User ID\n    category=10    # Category ID\n)\n\npayload, customs = await util.parse_input_data(request, data)\n\nprint(payload)\n# {\n#     \"title\": \"Getting Started\",\n#     \"author\": &lt;User instance with id=5&gt;,\n#     \"category\": &lt;Category instance with id=10&gt;\n# }\n</code></pre> <p>With BinaryField (base64):</p> Python<pre><code>class Document(ModelSerializer):\n    name = models.CharField(max_length=200)\n    file_data = models.BinaryField()\n\ndata = DocumentCreateSchema(\n    name=\"report.pdf\",\n    file_data=\"iVBORw0KGgoAAAANSUhEUgA...\"  # base64 string\n)\n\npayload, customs = await util.parse_input_data(request, data)\n\nprint(payload)\n# {\n#     \"name\": \"report.pdf\",\n#     \"file_data\": b'\\x89PNG\\r\\n\\x1a\\n...'  # decoded bytes\n# }\n</code></pre> <p>Error handling:</p> Python<pre><code>try:\n    payload, customs = await util.parse_input_data(request, bad_data)\nexcept SerializeError as e:\n    print(e.status_code)  # 400\n    print(e.details)\n    # {\"file_data\": \"Invalid base64 encoding\"}\n    # or {\"author\": \"User with id 999 not found\"}\n</code></pre>"},{"location":"api/models/model_util/#parse_output_data","title":"<code>parse_output_data()</code>","text":"<p>Post-process serialized output for consistency.</p>"},{"location":"api/models/model_util/#signature_2","title":"Signature","text":"Python<pre><code>async def parse_output_data(\n    request: HttpRequest,\n    data: Schema\n) -&gt; dict\n</code></pre>"},{"location":"api/models/model_util/#parameters_1","title":"Parameters","text":"Parameter Type Description <code>request</code> <code>HttpRequest</code> Current HTTP request <code>data</code> <code>Schema</code> Serialized schema instance"},{"location":"api/models/model_util/#return-value_2","title":"Return Value","text":"<p>Post-processed dictionary ready for API response.</p>"},{"location":"api/models/model_util/#transformations_1","title":"Transformations","text":"<ol> <li>Replace nested FK dicts \u2192 Actual model instances</li> <li>Add <code>&lt;field&gt;_id</code> keys \u2192 For nested FK references</li> <li>Flatten nested structures \u2192 Consistent response format</li> </ol>"},{"location":"api/models/model_util/#examples_1","title":"Examples","text":"<p>Basic FK transformation:</p> Python<pre><code># Before parse_output_data\n{\n    \"id\": 1,\n    \"title\": \"Article Title\",\n    \"author\": {\"id\": 10, \"username\": \"john_doe\"}\n}\n\n# After parse_output_data\n{\n    \"id\": 1,\n    \"title\": \"Article Title\",\n    \"author\": &lt;User instance&gt;,\n    \"author_id\": 10\n}\n</code></pre> <p>Nested relationships:</p> Python<pre><code># Before\n{\n    \"id\": 1,\n    \"author\": {\n        \"id\": 10,\n        \"profile\": {\n            \"id\": 5,\n            \"bio\": \"Developer\"\n        }\n    }\n}\n\n# After\n{\n    \"id\": 1,\n    \"author\": &lt;User instance&gt;,\n    \"author_id\": 10,\n    \"profile_id\": 5\n}\n</code></pre> <p>Why is this useful?</p> <p>Allows accessing relationships directly in subsequent operations:</p> Python<pre><code>result = await util.read_s(request, article, ArticleReadSchema)\n\n# Direct access to instances (no additional queries)\nauthor_name = result[\"author\"].username\nhas_premium = result[\"author\"].is_premium\n\n# Also provides IDs for convenience\nauthor_id = result[\"author_id\"]\n</code></pre>"},{"location":"api/models/model_util/#verbose_name_path_resolver","title":"<code>verbose_name_path_resolver()</code>","text":"<p>Get URL-friendly path segment from model's verbose name plural.</p>"},{"location":"api/models/model_util/#signature_3","title":"Signature","text":"Python<pre><code>def verbose_name_path_resolver() -&gt; str\n</code></pre>"},{"location":"api/models/model_util/#return-value_3","title":"Return Value","text":"<p>Slugified plural verbose name.</p>"},{"location":"api/models/model_util/#example_1","title":"Example","text":"Python<pre><code>class BlogPost(ModelSerializer):\n    class Meta:\n        verbose_name = \"blog post\"\n        verbose_name_plural = \"blog posts\"\n\nutil = ModelUtil(BlogPost)\npath = util.verbose_name_path_resolver()\nprint(path)  # \"blog-posts\"\n\n# Used in URL routing:\n# /api/blog-posts/\n# /api/blog-posts/{id}/\n</code></pre>"},{"location":"api/models/model_util/#verbose_name_view_resolver","title":"<code>verbose_name_view_resolver()</code>","text":"<p>Get display name from model's singular verbose name.</p>"},{"location":"api/models/model_util/#signature_4","title":"Signature","text":"Python<pre><code>def verbose_name_view_resolver() -&gt; str\n</code></pre>"},{"location":"api/models/model_util/#return-value_4","title":"Return Value","text":"<p>Capitalized singular verbose name.</p>"},{"location":"api/models/model_util/#example_2","title":"Example","text":"Python<pre><code>class BlogPost(ModelSerializer):\n    class Meta:\n        verbose_name = \"blog post\"\n\nutil = ModelUtil(BlogPost)\nname = util.verbose_name_view_resolver()\nprint(name)  # \"Blog post\"\n\n# Used in OpenAPI documentation:\n# \"Create Blog post\"\n# \"Update Blog post\"\n</code></pre>"},{"location":"api/models/model_util/#crud-operations","title":"CRUD Operations","text":""},{"location":"api/models/model_util/#create_s","title":"<code>create_s()</code>","text":"<p>Create new model instance with full lifecycle support.</p>"},{"location":"api/models/model_util/#signature_5","title":"Signature","text":"Python<pre><code>async def create_s(\n    request: HttpRequest,\n    data: Schema,\n    obj_schema: Schema\n) -&gt; dict\n</code></pre>"},{"location":"api/models/model_util/#parameters_2","title":"Parameters","text":"Parameter Type Description <code>request</code> <code>HttpRequest</code> Current HTTP request <code>data</code> <code>Schema</code> Input schema with creation data <code>obj_schema</code> <code>Schema</code> Output schema for response"},{"location":"api/models/model_util/#return-value_5","title":"Return Value","text":"<p>Serialized created object as dictionary.</p>"},{"location":"api/models/model_util/#execution-flow","title":"Execution Flow","text":"Text Only<pre><code>1. parse_input_data(data) \u2192 (payload, customs)\n2. Model.objects.acreate(**payload)\n3. custom_actions(customs)    [if ModelSerializer]\n4. post_create()              [if ModelSerializer]\n5. read_s(obj, obj_schema)\n6. return serialized_dict\n</code></pre>"},{"location":"api/models/model_util/#example_3","title":"Example","text":"Python<pre><code>from ninja import Schema\n\nclass UserCreateSchema(Schema):\n    username: str\n    email: str\n    send_welcome: bool = True\n\nclass UserReadSchema(Schema):\n    id: int\n    username: str\n    email: str\n    created_at: datetime\n\n# Create user\ndata = UserCreateSchema(\n    username=\"john_doe\",\n    email=\"john@example.com\",\n    send_welcome=True\n)\n\nresult = await util.create_s(request, data, UserReadSchema)\n\nprint(result)\n# {\n#     \"id\": 1,\n#     \"username\": \"john_doe\",\n#     \"email\": \"john@example.com\",\n#     \"created_at\": \"2024-01-15T10:30:00Z\"\n# }\n</code></pre>"},{"location":"api/models/model_util/#with-hooks","title":"With Hooks","text":"Python<pre><code>class User(ModelSerializer):\n    username = models.CharField(max_length=150)\n    email = models.EmailField()\n\n    class CreateSerializer:\n        fields = [\"username\", \"email\"]\n        customs = [(\"send_welcome\", bool, True)]\n\n    async def custom_actions(self, payload):\n        if payload.get(\"send_welcome\"):\n            await send_welcome_email(self.email)\n\n    async def post_create(self):\n        await AuditLog.objects.acreate(\n            action=\"user_created\",\n            user_id=self.id\n        )\n\n# Hooks are automatically invoked\nresult = await util.create_s(request, data, UserReadSchema)\n</code></pre>"},{"location":"api/models/model_util/#read_s","title":"<code>read_s()</code>","text":"<p>Serialize model instance to response dict.</p>"},{"location":"api/models/model_util/#signature_6","title":"Signature","text":"Python<pre><code>async def read_s(\n    request: HttpRequest,\n    obj: ModelSerializer | models.Model,\n    obj_schema: Schema\n) -&gt; dict\n</code></pre>"},{"location":"api/models/model_util/#parameters_3","title":"Parameters","text":"Parameter Type Description <code>request</code> <code>HttpRequest</code> Current HTTP request <code>obj</code> <code>ModelSerializer \\| models.Model</code> Model instance to serialize <code>obj_schema</code> <code>Schema</code> Output schema"},{"location":"api/models/model_util/#return-value_6","title":"Return Value","text":"<p>Serialized object as dictionary.</p>"},{"location":"api/models/model_util/#execution-flow_1","title":"Execution Flow","text":"Text Only<pre><code>1. obj_schema.from_orm(obj)\n2. schema.model_dump(mode=\"json\")\n3. parse_output_data(dumped_data)\n4. return processed_dict\n</code></pre>"},{"location":"api/models/model_util/#example_4","title":"Example","text":"Python<pre><code>user = await User.objects.aget(id=1)\nresult = await util.read_s(request, user, UserReadSchema)\n\nprint(result)\n# {\n#     \"id\": 1,\n#     \"username\": \"john_doe\",\n#     \"email\": \"john@example.com\",\n#     \"created_at\": \"2024-01-15T10:30:00Z\"\n# }\n</code></pre>"},{"location":"api/models/model_util/#with-nested-relations","title":"With Nested Relations","text":"Python<pre><code>class ArticleReadSchema(Schema):\n    id: int\n    title: str\n    author: UserReadSchema  # Nested\n\narticle = await Article.objects.select_related('author').aget(id=1)\nresult = await util.read_s(request, article, ArticleReadSchema)\n\nprint(result)\n# {\n#     \"id\": 1,\n#     \"title\": \"Getting Started\",\n#     \"author\": &lt;User instance&gt;,\n#     \"author_id\": 10\n# }\n</code></pre>"},{"location":"api/models/model_util/#update_s","title":"<code>update_s()</code>","text":"<p>Update existing model instance.</p>"},{"location":"api/models/model_util/#signature_7","title":"Signature","text":"Python<pre><code>async def update_s(\n    request: HttpRequest,\n    data: Schema,\n    pk: int | str,\n    obj_schema: Schema\n) -&gt; dict\n</code></pre>"},{"location":"api/models/model_util/#parameters_4","title":"Parameters","text":"Parameter Type Description <code>request</code> <code>HttpRequest</code> Current HTTP request <code>data</code> <code>Schema</code> Input schema with update data <code>pk</code> <code>int \\| str</code> Primary key of object to update <code>obj_schema</code> <code>Schema</code> Output schema for response"},{"location":"api/models/model_util/#return-value_7","title":"Return Value","text":"<p>Serialized updated object as dictionary.</p>"},{"location":"api/models/model_util/#execution-flow_2","title":"Execution Flow","text":"Text Only<pre><code>1. get_object(pk=pk)\n2. parse_input_data(data) \u2192 (payload, customs)\n3. Update obj fields from payload\n4. custom_actions(customs)    [if ModelSerializer]\n5. obj.asave()\n6. read_s(obj, obj_schema)\n7. return serialized_dict\n</code></pre>"},{"location":"api/models/model_util/#example_5","title":"Example","text":"Python<pre><code>class UserUpdateSchema(Schema):\n    email: str | None = None\n    bio: str | None = None\n\ndata = UserUpdateSchema(email=\"newemail@example.com\")\nresult = await util.update_s(request, data, pk=1, obj_schema=UserReadSchema)\n\nprint(result)\n# {\n#     \"id\": 1,\n#     \"username\": \"john_doe\",  # unchanged\n#     \"email\": \"newemail@example.com\",  # updated\n#     \"bio\": \"...\",  # unchanged\n# }\n</code></pre>"},{"location":"api/models/model_util/#partial-updates","title":"Partial Updates","text":"<p>Only provided fields are updated:</p> Python<pre><code># Update only email\ndata = UserUpdateSchema(email=\"new@example.com\")\nawait util.update_s(request, data, pk=1, UserReadSchema)\n\n# Update only bio\ndata = UserUpdateSchema(bio=\"New bio\")\nawait util.update_s(request, data, pk=1, UserReadSchema)\n\n# Update both\ndata = UserUpdateSchema(email=\"new@example.com\", bio=\"New bio\")\nawait util.update_s(request, data, pk=1, UserReadSchema)\n</code></pre>"},{"location":"api/models/model_util/#with-custom-actions","title":"With Custom Actions","text":"Python<pre><code>class User(ModelSerializer):\n    class UpdateSerializer:\n        optionals = [(\"email\", str)]\n        customs = [(\"reset_password\", bool, False)]\n\n    async def custom_actions(self, payload):\n        if payload.get(\"reset_password\"):\n            await self.send_password_reset_email()\n\ndata = UserUpdateSchema(email=\"new@example.com\", reset_password=True)\nawait util.update_s(request, data, pk=1, UserReadSchema)\n# Email updated AND password reset email sent\n</code></pre>"},{"location":"api/models/model_util/#delete_s","title":"<code>delete_s()</code>","text":"<p>Delete model instance.</p>"},{"location":"api/models/model_util/#signature_8","title":"Signature","text":"Python<pre><code>async def delete_s(\n    request: HttpRequest,\n    pk: int | str\n) -&gt; None\n</code></pre>"},{"location":"api/models/model_util/#parameters_5","title":"Parameters","text":"Parameter Type Description <code>request</code> <code>HttpRequest</code> Current HTTP request <code>pk</code> <code>int \\| str</code> Primary key of object to delete"},{"location":"api/models/model_util/#return-value_8","title":"Return Value","text":"<p><code>None</code></p>"},{"location":"api/models/model_util/#execution-flow_3","title":"Execution Flow","text":"Text Only<pre><code>1. get_object(pk=pk)\n2. obj.adelete()\n3. obj.on_delete()    [if ModelSerializer]\n</code></pre>"},{"location":"api/models/model_util/#example_6","title":"Example","text":"Python<pre><code>await util.delete_s(request, pk=1)\n# User with id=1 is deleted\n</code></pre>"},{"location":"api/models/model_util/#with-delete-hook","title":"With Delete Hook","text":"Python<pre><code>class User(ModelSerializer):\n    def on_delete(self):\n        logger.info(f\"User {self.username} deleted\")\n        cache.delete(f\"user:{self.id}\")\n\nawait util.delete_s(request, pk=1)\n# Logs deletion and clears cache\n</code></pre>"},{"location":"api/models/model_util/#error-handling","title":"Error Handling","text":"<p>ModelUtil raises <code>SerializeError</code> for various failure scenarios:</p>"},{"location":"api/models/model_util/#404-not-found","title":"404 Not Found","text":"Python<pre><code>from ninja_aio.exceptions import SerializeError\n\ntry:\n    user = await util.get_object(request, pk=999)\nexcept SerializeError as e:\n    print(e.status_code)  # 404\n    print(e.details)\n    # {\"user\": \"not found\"}\n</code></pre>"},{"location":"api/models/model_util/#400-bad-request","title":"400 Bad Request","text":"<p>Invalid base64:</p> Python<pre><code>try:\n    data = DocumentCreateSchema(\n        name=\"doc.pdf\",\n        file_data=\"not-valid-base64!!!\"\n    )\n    await util.create_s(request, data, DocumentReadSchema)\nexcept SerializeError as e:\n    print(e.status_code)  # 400\n    print(e.details)\n    # {\"file_data\": \"Invalid base64 encoding\"}\n</code></pre> <p>Missing related object:</p> Python<pre><code>try:\n    data = ArticleCreateSchema(\n        title=\"Test\",\n        author=999  # Non-existent user ID\n    )\n    await util.create_s(request, data, ArticleReadSchema)\nexcept SerializeError as e:\n    print(e.status_code)  # 400\n    print(e.details)\n    # {\"author\": \"User with id 999 not found\"}\n</code></pre>"},{"location":"api/models/model_util/#performance-optimization","title":"Performance Optimization","text":""},{"location":"api/models/model_util/#automatic-query-optimization","title":"Automatic Query Optimization","text":"Python<pre><code>class Article(ModelSerializer):\n    author = models.ForeignKey(User, on_delete=models.CASCADE)\n    category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True)\n    tags = models.ManyToManyField(Tag, related_name=\"articles\")\n\nutil = ModelUtil(Article)\n\n# Single query optimization\narticle = await util.get_object(request, pk=1)\n# Automatically executes:\n# SELECT * FROM article\n#   LEFT JOIN user ON article.author_id = user.id\n#   LEFT JOIN category ON article.category_id = category.id\n# WITH prefetch for tags\n\n# Queryset optimization\narticles = await util.get_object(request)\n# Automatically adds select_related and prefetch_related\n</code></pre>"},{"location":"api/models/model_util/#manual-optimization","title":"Manual Optimization","text":"<p>For complex scenarios, override in ModelSerializer:</p> Python<pre><code>class Article(ModelSerializer):\n    @classmethod\n    async def queryset_request(cls, request):\n        return cls.objects.select_related(\n            'author',\n            'author__profile',  # Deep relation\n            'category'\n        ).prefetch_related(\n            'tags',\n            'comments__author'  # Nested prefetch\n        ).only(\n            'id', 'title', 'content',  # Limit fields\n            'author__username',\n            'category__name'\n        )\n</code></pre>"},{"location":"api/models/model_util/#integration-with-apiviewset","title":"Integration with APIViewSet","text":"<p>ModelUtil is automatically used by APIViewSet:</p> Python<pre><code>from ninja_aio.views import APIViewSet\n\nclass UserViewSet(APIViewSet):\n    model = User\n    api = api\n\n    # Internally creates ModelUtil(User)\n    # All CRUD operations use ModelUtil methods\n</code></pre>"},{"location":"api/models/model_util/#complete-example","title":"Complete Example","text":"Python<pre><code>from django.db import models\nfrom ninja_aio.models import ModelSerializer, ModelUtil\nfrom ninja import Schema\nfrom django.http import HttpRequest\n\n# Models\nclass Author(ModelSerializer):\n    name = models.CharField(max_length=200)\n    email = models.EmailField(unique=True)\n\n    class CreateSerializer:\n        fields = [\"name\", \"email\"]\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"email\"]\n\nclass Book(ModelSerializer):\n    title = models.CharField(max_length=200)\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"books\")\n    isbn = models.CharField(max_length=13, unique=True)\n    cover_image = models.BinaryField(null=True)\n    is_published = models.BooleanField(default=False)\n\n    class CreateSerializer:\n        fields = [\"title\", \"author\", \"isbn\"]\n        optionals = [(\"cover_image\", str)]  # base64\n        customs = [(\"notify_author\", bool, True)]\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"author\", \"isbn\", \"is_published\"]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"title\", str),\n            (\"is_published\", bool),\n        ]\n\n    async def custom_actions(self, payload):\n        if payload.get(\"notify_author\"):\n            await send_email(\n                self.author.email,\n                f\"New book created: {self.title}\"\n            )\n\n    async def post_create(self):\n        await AuditLog.objects.acreate(\n            action=\"book_created\",\n            book_id=self.id\n        )\n\n# Usage\nasync def example(request: HttpRequest):\n    util = ModelUtil(Book)\n\n    # Create\n    book_data = BookCreateSchema(\n        title=\"Django Unleashed\",\n        author=5,\n        isbn=\"9781234567890\",\n        cover_image=\"iVBORw0KGgo...\",  # base64\n        notify_author=True\n    )\n    created = await util.create_s(request, book_data, BookReadSchema)\n\n    # Read\n    book = await util.get_object(request, pk=created[\"id\"])\n    serialized = await util.read_s(request, book, BookReadSchema)\n\n    # Update\n    update_data = BookUpdateSchema(is_published=True)\n    updated = await util.update_s(request, update_data, created[\"id\"], BookReadSchema)\n\n    # Delete\n    await util.delete_s(request, created[\"id\"])\n</code></pre>"},{"location":"api/models/model_util/#best-practices","title":"Best Practices","text":"<ol> <li>Always use with async views:</li> </ol> Python<pre><code>async def my_view(request):\n    util = ModelUtil(User)\n    users = await util.get_object(request)\n</code></pre> <ol> <li>Reuse util instances when possible:</li> </ol> Python<pre><code># Good: One util per view\nutil = ModelUtil(User)\nuser = await util.create_s(...)\nupdated = await util.update_s(...)\n</code></pre> <ol> <li>Let ModelUtil handle query optimization:</li> </ol> Python<pre><code># Don't manually optimize unless necessary\nuser = await util.get_object(request, pk=1)\n# ModelUtil already applied select_related/prefetch_related\n</code></pre> <ol> <li>Handle SerializeError appropriately:</li> </ol> Python<pre><code>from ninja_aio.exceptions import SerializeError\n\ntry:\n    result = await util.create_s(request, data, schema)\nexcept SerializeError as e:\n    return e.status_code, e.details\n</code></pre> <ol> <li>Use parse_input_data for custom processing: Python<pre><code>payload, customs = await util.parse_input_data(request, data)\n# Process customs before creation\nif customs.get(\"validate_uniqueness\"):\n    # Custom validation logic\n    pass\n</code></pre></li> </ol>"},{"location":"api/models/model_util/#see-also","title":"See Also","text":"<ul> <li>Model Serializer - Define schemas on models</li> <li>API ViewSet - High-level CRUD views using ModelUtil</li> </ul>"},{"location":"api/models/serializers/","title":"Serializer (Meta-driven)","text":"<p>The <code>Serializer</code> class provides dynamic schema generation and relation handling for existing Django models without requiring you to adopt the ModelSerializer base class. Use it when:</p> <ul> <li>You already have vanilla Django models in a project and want dynamic Ninja schemas.</li> <li>You prefer to keep models unchanged and define serialization externally.</li> <li>You need to keep your models lean and define API concerns separately.</li> </ul> <p>It mirrors the behavior of ModelSerializer but reads configuration from a nested Meta class.</p>"},{"location":"api/models/serializers/#key-differences-from-modelserializer","title":"Key Differences from ModelSerializer","text":"<p>While both <code>ModelSerializer</code> and <code>Serializer</code> provide schema generation and CRUD operations, there are important differences:</p> Feature ModelSerializer Serializer Model class Custom base class Plain Django model Configuration Nested classes (CreateSerializer) Meta class (schema_in/out/update) Lifecycle hooks Instance methods (uses <code>self</code>) Receives <code>instance</code> parameter Schema generation On-demand via generate_*() methods On-demand via generate_*() methods Usage Inherit from ModelSerializer Separate serializer class Query optimization QuerySet nested class QuerySet nested class (inherited) Relation serializers Auto-resolved Explicit via relations_serializers (supports string refs &amp; Union)"},{"location":"api/models/serializers/#key-points","title":"Key points","text":"<ul> <li>Works with any Django model (no inheritance required).</li> <li>Generates read/create/update/related schemas on demand via ninja.orm.create_schema.</li> <li>Supports explicit relation serializers for forward and reverse relations.</li> <li>Supports string references in <code>relations_serializers</code> for forward/circular dependencies.</li> <li>Supports Union types for polymorphic relations (e.g., generic foreign keys, content types).</li> <li>Plays nicely with APIViewSet to auto-wire schemas and queryset handling.</li> </ul>"},{"location":"api/models/serializers/#configuration","title":"Configuration","text":"<p>Define a Serializer subclass with a nested Meta:</p> <ul> <li>model: Django model class</li> <li>schema_in: SchemaModelConfig for create inputs</li> <li>schema_out: SchemaModelConfig for read outputs (list endpoint)</li> <li>schema_detail: SchemaModelConfig for detail outputs (retrieve endpoint)</li> <li>schema_update: SchemaModelConfig for patch/update inputs</li> <li>relations_serializers: Mapping of relation field name -&gt; Serializer class, string reference, or Union of serializers (supports forward/circular dependencies and polymorphic relations)</li> </ul> <p>SchemaModelConfig fields:</p> <ul> <li>fields: <code>list[str]</code> - Model field names to include</li> <li>optionals: <code>list[tuple[str, type]]</code> - Optional fields with their types</li> <li>exclude: <code>list[str]</code> - Fields to exclude from schema</li> <li>customs: <code>list[tuple[str, type, Any]]</code> - Custom/computed fields</li> </ul>"},{"location":"api/models/serializers/#schema-generation","title":"Schema Generation","text":"<p>Generate schemas explicitly using these methods:</p> Python<pre><code># Explicitly generate schemas when needed\nArticleSerializer.generate_create_s()  # Returns create (In) schema\nArticleSerializer.generate_read_s()    # Returns read (Out) schema for list endpoint\nArticleSerializer.generate_detail_s()  # Returns detail (Out) schema for retrieve endpoint\nArticleSerializer.generate_update_s()  # Returns update (Patch) schema\nArticleSerializer.generate_related_s() # Returns related (nested) schema\n</code></pre> <p>Schemas support forward references and circular dependencies via string references in <code>relations_serializers</code>.</p>"},{"location":"api/models/serializers/#detail-schema-for-retrieve-endpoint","title":"Detail Schema for Retrieve Endpoint","text":"<p>Use <code>schema_detail</code> when you want the retrieve endpoint to return more fields than the list endpoint:</p> Python<pre><code>class ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Article\n        schema_out = serializers.SchemaModelConfig(\n            # List view: minimal fields for performance\n            fields=[\"id\", \"title\", \"summary\"]\n        )\n        schema_detail = serializers.SchemaModelConfig(\n            # Detail view: all fields including expensive relations\n            fields=[\"id\", \"title\", \"summary\", \"content\", \"author\", \"tags\"],\n            customs=[(\"reading_time\", int, lambda obj: len(obj.content.split()) // 200)]\n        )\n</code></pre> <p>When used with <code>APIViewSet</code>: - List endpoint (<code>GET /articles/</code>) uses <code>schema_out</code> - Retrieve endpoint (<code>GET /articles/{pk}</code>) uses <code>schema_detail</code> (falls back to <code>schema_out</code> if not defined)</p>"},{"location":"api/models/serializers/#example-simple-fk","title":"Example: simple FK","text":"Python<pre><code>from ninja_aio.models import serializers\nfrom . import models\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Article\n        schema_in = serializers.SchemaModelConfig(\n            fields=[\"title\", \"content\", \"author\"]\n        )\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"content\", \"author\"]\n        )\n        schema_update = serializers.SchemaModelConfig(\n            optionals=[(\"title\", str), (\"content\", str)]\n        )\n</code></pre>"},{"location":"api/models/serializers/#lifecycle-hooks","title":"Lifecycle Hooks","text":"<p>Serializer supports lifecycle hooks similar to ModelSerializer, but with a key difference: all hooks receive an <code>instance</code> parameter instead of using <code>self</code>:</p> Python<pre><code>class ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Article\n        schema_in = serializers.SchemaModelConfig(\n            fields=[\"title\", \"content\", \"author\"],\n            customs=[(\"notify_author\", bool, True)]\n        )\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"content\", \"author\"]\n        )\n\n    @classmethod\n    async def queryset_request(cls, request):\n        \"\"\"Filter and optimize queryset per request.\"\"\"\n        return cls._meta.model.objects.select_related(\"author\")\n\n    async def custom_actions(self, payload, instance):\n        \"\"\"Execute custom actions with access to the instance.\"\"\"\n        if payload.get(\"notify_author\"):\n            await send_email(instance.author.email, f\"Article created: {instance.title}\")\n\n    async def post_create(self, instance):\n        \"\"\"Hook after instance creation.\"\"\"\n        await AuditLog.objects.acreate(\n            action=\"article_created\",\n            article_id=instance.id\n        )\n\n    def before_save(self, instance):\n        \"\"\"Sync hook before save (receives instance).\"\"\"\n        instance.slug = slugify(instance.title)\n\n    def after_save(self, instance):\n        \"\"\"Sync hook after save (receives instance).\"\"\"\n        cache.delete(f\"article:{instance.id}\")\n\n    def on_delete(self, instance):\n        \"\"\"Sync hook after deletion (receives instance).\"\"\"\n        logger.info(f\"Article {instance.id} deleted\")\n</code></pre>"},{"location":"api/models/serializers/#available-hooks","title":"Available Hooks","text":"Hook Type When Called Parameters <code>queryset_request(request)</code> async Before queryset building <code>request</code> <code>custom_actions(payload, i)</code> async After field assignment <code>payload</code>, <code>instance</code> <code>post_create(instance)</code> async After first save <code>instance</code> <code>before_save(instance)</code> sync Before any save <code>instance</code> <code>after_save(instance)</code> sync After any save <code>instance</code> <code>on_create_before_save(i)</code> sync Before creation save only <code>instance</code> <code>on_create_after_save(i)</code> sync After creation save only <code>instance</code> <code>on_delete(instance)</code> sync After deletion <code>instance</code>"},{"location":"api/models/serializers/#example-reverse-relation-with-nested-serialization","title":"Example: reverse relation with nested serialization","text":"Python<pre><code>class AuthorSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Author\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"name\", \"articles\"]  # reverse related name\n        )\n        relations_serializers = {\n            \"articles\": ArticleSerializer,  # include nested article schema\n        }\n</code></pre>"},{"location":"api/models/serializers/#string-references-for-forwardcircular-dependencies","title":"String References for Forward/Circular Dependencies","text":"<p>You can use string references in <code>relations_serializers</code> to handle forward references and circular dependencies:</p> Python<pre><code>class AuthorSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Author\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"name\", \"articles\"]\n        )\n        relations_serializers = {\n            \"articles\": \"ArticleSerializer\",  # String reference - resolved lazily\n        }\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Article\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"author\"]\n        )\n        relations_serializers = {\n            \"author\": \"AuthorSerializer\",  # Circular reference works!\n        }\n</code></pre> <p>String Reference Formats:</p> <ol> <li> <p>Class name in the same module: Python<pre><code>relations_serializers = {\n    \"articles\": \"ArticleSerializer\",  # Resolved in current module\n}\n</code></pre></p> </li> <li> <p>Absolute import path: Python<pre><code>relations_serializers = {\n    \"articles\": \"myapp.serializers.ArticleSerializer\",  # Full import path\n}\n</code></pre></p> </li> </ol> <p>String Reference Requirements: - String can be the class name of a serializer in the same module, or an absolute import path - Absolute paths use dot notation: <code>\"package.module.ClassName\"</code> - References are resolved lazily when schemas are generated - Both forward and circular references are supported</p> <p>Example: Cross-Module References with Absolute Paths</p> Python<pre><code># myapp/serializers.py\nfrom ninja_aio.models import serializers\nfrom . import models\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Article\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"author\"]\n        )\n        relations_serializers = {\n            # Reference a serializer from another module\n            \"author\": \"users.serializers.UserSerializer\",\n        }\n\n# users/serializers.py\nfrom ninja_aio.models import serializers\nfrom . import models\n\nclass UserSerializer(serializers.Serializer):\n    class Meta:\n        model = models.User\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"username\", \"email\", \"articles\"]\n        )\n        relations_serializers = {\n            # Reference back to the article serializer\n            \"articles\": \"myapp.serializers.ArticleSerializer\",\n        }\n</code></pre>"},{"location":"api/models/serializers/#union-types-for-polymorphic-relations","title":"Union Types for Polymorphic Relations","text":"<p>You can use <code>Union</code> types in <code>relations_serializers</code> to handle polymorphic relationships where a field can reference multiple possible serializer types. This is particularly useful for generic foreign keys, content types, or any scenario where a relation can point to different model types.</p> Python<pre><code>from typing import Union\nfrom ninja_aio.models import serializers\nfrom . import models\n\nclass VideoSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Video\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"duration\", \"url\"]\n        )\n\nclass ImageSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Image\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"width\", \"height\", \"url\"]\n        )\n\nclass CommentSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Comment\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"text\", \"content_object\"]\n        )\n        relations_serializers = {\n            # content_object can be a Video or Image\n            \"content_object\": Union[VideoSerializer, ImageSerializer],\n        }\n</code></pre> <p>Union Type Formats:</p> <ol> <li> <p>Direct class references: Python<pre><code>relations_serializers = {\n    \"field\": Union[SerializerA, SerializerB],\n}\n</code></pre></p> </li> <li> <p>String references: Python<pre><code>relations_serializers = {\n    \"field\": Union[\"SerializerA\", \"SerializerB\"],\n}\n</code></pre></p> </li> <li> <p>Mixed class and string references: Python<pre><code>relations_serializers = {\n    \"field\": Union[SerializerA, \"SerializerB\"],\n}\n</code></pre></p> </li> <li> <p>Absolute import paths: Python<pre><code>relations_serializers = {\n    \"field\": Union[\"myapp.serializers.SerializerA\", SerializerB],\n}\n</code></pre></p> </li> </ol> <p>Use Cases for Union Types:</p> <ul> <li>Polymorphic relations: Generic foreign keys or Django ContentType relations</li> <li>Flexible APIs: Different response formats for the same field based on runtime type</li> <li>Gradual migrations: Transitioning between different serializer implementations</li> <li>Multi-tenant systems: Different serialization requirements per tenant</li> </ul> <p>Complete Polymorphic Example:</p> Python<pre><code>from typing import Union\nfrom django.contrib.contenttypes.fields import GenericForeignKey\nfrom ninja_aio.models import serializers\n\n# Models\nclass Comment(models.Model):\n    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)\n    object_id = models.PositiveIntegerField()\n    content_object = GenericForeignKey('content_type', 'object_id')\n    text = models.TextField()\n\n# Serializers for different content types\nclass BlogPostSerializer(serializers.Serializer):\n    class Meta:\n        model = models.BlogPost\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"body\", \"published_at\"]\n        )\n\nclass ProductSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Product\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"name\", \"price\", \"stock\"]\n        )\n\nclass EventSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Event\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"name\", \"date\", \"location\"]\n        )\n\n# Comment serializer with Union support\nclass CommentSerializer(serializers.Serializer):\n    class Meta:\n        model = Comment\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"text\", \"created_at\", \"content_object\"]\n        )\n        relations_serializers = {\n            # Comments can be on blog posts, products, or events\n            \"content_object\": Union[BlogPostSerializer, ProductSerializer, EventSerializer],\n        }\n</code></pre> <p>Notes:</p> <ul> <li>Forward relations are included as plain fields unless a related ModelSerializer/Serializer is declared.</li> <li>Reverse relations require an entry in relations_serializers when using vanilla Django models.</li> <li>When the related model is a ModelSerializer, related schemas can be auto-resolved.</li> <li>Absolute import paths are useful for cross-module references and avoiding circular import issues at module load time.</li> <li>Union types are resolved lazily, so forward and circular references work seamlessly.</li> <li>The schema generator will create a union of all possible schemas from the serializers in the Union.</li> </ul>"},{"location":"api/models/serializers/#using-with-apiviewset","title":"Using with APIViewSet","text":"<p>You can attach a Serializer to an APIViewSet to auto-generate schemas and leverage queryset_request when present:</p> Python<pre><code>from ninja_aio.views import APIViewSet\nfrom ninja_aio import NinjaAIO\nfrom . import models\n\napi = NinjaAIO()\n\n@api.viewset(model=models.Article)\nclass ArticleViewSet(APIViewSet):\n    serializer_class = ArticleSerializer\n    # Optionally define query_params or custom handlers\n</code></pre> <p>Behavior:</p> <ul> <li>If <code>model</code> is a ModelSerializer, APIViewSet uses the model to generate schemas directly</li> <li>If <code>model</code> is a vanilla Django model and <code>serializer_class</code> is provided, APIViewSet uses the Serializer to generate missing schemas</li> <li>ModelUtil creates a serializer instance and uses its <code>queryset_request()</code> hook if defined to build optimized querysets</li> <li>Lifecycle hooks from the serializer are invoked during CRUD operations</li> </ul>"},{"location":"api/models/serializers/#crud-operations-with-serializer","title":"CRUD Operations with Serializer","text":"<p>When using a Serializer with APIViewSet, CRUD operations automatically invoke the appropriate lifecycle hooks:</p> Python<pre><code># Create operation flow:\n# 1. parse_input_data() - normalize payload\n# 2. create() - create instance\n# 3. custom_actions() - execute custom logic\n# 4. save() - persists with before/after hooks\n# 5. post_create() - post-creation hook\n# 6. read_s() - serialize response\n\n# Update operation flow:\n# 1. get_object() - fetch instance\n# 2. parse_input_data() - normalize payload\n# 3. update() - update instance fields\n# 4. custom_actions() - execute custom logic\n# 5. save() - persists with before/after hooks\n# 6. read_s() - serialize response\n\n# Delete operation flow:\n# 1. get_object() - fetch instance\n# 2. adelete() - delete instance\n# 3. on_delete() - deletion hook\n</code></pre>"},{"location":"api/models/serializers/#advanced-customs-and-optionals","title":"Advanced: customs and optionals","text":"<p>Customs and optionals behave like ModelSerializer:</p> <ul> <li>customs: synthetic fields included in schemas (with default or required when default is Ellipsis).</li> <li>optionals: patch-like optional fields. In read schema, they are included with default None.</li> </ul> Python<pre><code>class PublishSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Article\n        schema_update = serializers.SchemaModelConfig(\n            optionals=[(\"is_published\", bool)],\n            customs=[(\"notify_subscribers\", bool, True)],\n        )\n</code></pre> <p>generate_update_s merges optionals and customs for the Patch schema.</p>"},{"location":"api/models/serializers/#query-optimization-with-serializer","title":"Query Optimization with Serializer","text":"<p>Like ModelSerializer, Serializer supports query optimization via a nested QuerySet class:</p> Python<pre><code>from ninja_aio.schemas.helpers import ModelQuerySetSchema, ModelQuerySetExtraSchema\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Article\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"content\", \"author\", \"category\"]\n        )\n        schema_detail = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"content\", \"author\", \"category\", \"tags\", \"comments\"]\n        )\n\n    class QuerySet:\n        read = ModelQuerySetSchema(\n            select_related=[\"author\", \"category\"],\n            prefetch_related=[\"tags\"],\n        )\n        detail = ModelQuerySetSchema(\n            select_related=[\"author\", \"category\", \"author__profile\"],\n            prefetch_related=[\"tags\", \"comments\", \"comments__author\"],\n        )\n        queryset_request = ModelQuerySetSchema(\n            select_related=[],\n            prefetch_related=[\"comments\"],\n        )\n        extras = [\n            ModelQuerySetExtraSchema(\n                scope=\"detail_view\",\n                select_related=[\"author__profile\"],\n                prefetch_related=[\"tags\", \"comments__author\"],\n            )\n        ]\n</code></pre> <p>The QuerySet configuration is used by ModelUtil to automatically optimize database queries:</p> <ul> <li>read: Applied to list operations (<code>is_for=\"read\"</code>)</li> <li>detail: Applied to retrieve/detail operations (<code>is_for=\"detail\"</code>). Falls back to <code>read</code> if not defined.</li> <li>queryset_request: Applied inside the <code>queryset_request</code> hook</li> <li>extras: Named configurations available via <code>QueryUtil.SCOPES</code></li> </ul>"},{"location":"api/models/serializers/#complete-example","title":"Complete Example","text":"Python<pre><code>from ninja_aio.models import serializers\nfrom ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom django.db import models as django_models\n\n# Plain Django models\nclass Author(django_models.Model):\n    name = django_models.CharField(max_length=200)\n    email = django_models.EmailField()\n\nclass Article(django_models.Model):\n    title = django_models.CharField(max_length=200)\n    content = django_models.TextField()\n    author = django_models.ForeignKey(Author, on_delete=django_models.CASCADE)\n    is_published = django_models.BooleanField(default=False)\n\n# Serializers\nclass AuthorSerializer(serializers.Serializer):\n    class Meta:\n        model = Author\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"name\", \"email\"]\n        )\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = Article\n        schema_in = serializers.SchemaModelConfig(\n            fields=[\"title\", \"content\", \"author\"]\n        )\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"content\", \"author\", \"is_published\"]\n        )\n        schema_update = serializers.SchemaModelConfig(\n            optionals=[(\"title\", str), (\"content\", str)],\n            customs=[(\"publish_now\", bool, False)]\n        )\n        relations_serializers = {\n            \"author\": AuthorSerializer\n        }\n\n    class QuerySet:\n        read = serializers.ModelQuerySetSchema(\n            select_related=[\"author\"]\n        )\n\n    async def custom_actions(self, payload, instance):\n        if payload.get(\"publish_now\"):\n            instance.is_published = True\n            await sync_to_async(instance.save)()\n\n# ViewSets\napi = NinjaAIO()\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    serializer_class = ArticleSerializer\n</code></pre>"},{"location":"api/models/serializers/#when-to-choose-serializer-vs-modelserializer","title":"When to choose Serializer vs ModelSerializer","text":"<p>Choose Serializer when:</p> <ul> <li>You have existing Django models that you can't or don't want to modify</li> <li>You want to keep models and API concerns separated</li> <li>You're incrementally adding API functionality to an existing project</li> <li>You prefer declarative configuration via Meta classes</li> <li>Multiple teams work on models vs API layers</li> </ul> <p>Choose ModelSerializer when:</p> <ul> <li>You're building a new project from scratch</li> <li>You want to centralize all model and API concerns in one place</li> <li>You prefer configuration via nested classes on the model</li> <li>You want auto-binding and less boilerplate</li> <li>Your models are specifically designed for API usage</li> </ul> <p>Both approaches support:</p> <ul> <li>Nested relations and dynamic schema generation</li> <li>Query optimization via QuerySet configuration</li> <li>Lifecycle hooks for custom business logic</li> <li>Integration with APIViewSet for auto-generated CRUD endpoints</li> </ul> <p>Choose the pattern that best fits your project architecture and team structure.</p>"},{"location":"api/renderers/orjson_renderer/","title":"ORJSON renderer option","text":"<p>This package uses an internal ORJSON-based renderer. Configure serialization options via Django settings:</p> Python<pre><code># settings.py\nimport orjson\n\n# Single option\nNINJA_AIO_ORJSON_RENDERER_OPTION = orjson.OPT_INDENT_2\n\n# Multiple options (bitwise OR)\nNINJA_AIO_ORJSON_RENDERER_OPTION = (\n    orjson.OPT_INDENT_2 | orjson.OPT_NON_STR_KEYS\n)\n</code></pre> <p>Notes: - The value is an orjson option bitmask (e.g., <code>orjson.OPT_INDENT_2</code>, <code>orjson.OPT_NON_STR_KEYS</code>), and you can combine multiple options using <code>|</code>. - If not set, the default <code>orjson.dumps</code> options are used.</p>"},{"location":"api/views/api_view/","title":"API View","text":"<p>The <code>APIView</code> class provides a base for creating simple API endpoints with custom views.</p>"},{"location":"api/views/api_view/#overview","title":"Overview","text":"<p><code>APIView</code> is a lightweight wrapper around Django Ninja's <code>Router</code> that provides:</p> <ul> <li>Organized routing with tags</li> <li>Custom authentication configuration</li> <li>Error handling with standard HTTP status codes</li> </ul>"},{"location":"api/views/api_view/#class-definition","title":"Class Definition","text":"Python<pre><code>class APIView:\n    api: NinjaAPI\n    router_tag: str\n    api_route_path: str\n    auth: list | None = NOT_SET\n</code></pre>"},{"location":"api/views/api_view/#attributes","title":"Attributes","text":"Attribute Type Description <code>api</code> <code>NinjaAPI</code> The NinjaAPI instance to register routes <code>router_tag</code> <code>str</code> Tag name for grouping endpoints in OpenAPI docs <code>api_route_path</code> <code>str</code> Base path for all routes in this view <code>auth</code> <code>list \\| None</code> Authentication classes (optional)"},{"location":"api/views/api_view/#methods","title":"Methods","text":""},{"location":"api/views/api_view/#recommended-decorator-based-endpoints","title":"Recommended: decorator-based endpoints","text":"<p>Prefer class method decorators to define non-CRUD endpoints. Decorators lazily bind instance methods to the router and automatically remove <code>self</code> from the OpenAPI signature while preserving type hints.</p> <p>Available decorators (from <code>ninja_aio.decorators</code>):</p> <ul> <li><code>@api_get(path, ...)</code></li> <li><code>@api_post(path, ...)</code></li> <li><code>@api_put(path, ...)</code></li> <li><code>@api_patch(path, ...)</code></li> <li><code>@api_delete(path, ...)</code></li> <li><code>@api_options(path, ...)</code></li> <li><code>@api_head(path, ...)</code></li> </ul> <p>Example:</p> Python<pre><code>from ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIView\nfrom ninja_aio.decorators import api_get, api_post\nfrom ninja import Schema\n\napi = NinjaAIO(title=\"My API\")\n\nclass StatsSchema(Schema):\n    total: int\n    active: int\n\n@api.view(prefix=\"/analytics\", tags=[\"Analytics\"])\nclass AnalyticsView(APIView):\n    @api_get(\"/dashboard\", response=StatsSchema)\n    async def dashboard(self, request):\n        return {\"total\": 1000, \"active\": 750}\n\n    @api_post(\"/track\")\n    async def track_event(self, request, event: str):\n        return {\"tracked\": event}\n</code></pre> <p>Notes:</p> <ul> <li>Decorators support per-endpoint <code>auth</code>, <code>response</code>, <code>tags</code>, <code>summary</code>, <code>description</code>, throttling, and OpenAPI extras.</li> <li>Sync methods run via <code>sync_to_async</code> automatically.</li> <li><code>self</code> is excluded from the exposed signature; parameter type hints are preserved.</li> </ul>"},{"location":"api/views/api_view/#legacy-views-still-supported","title":"Legacy: <code>views()</code> (still supported)","text":"<p>You can still override <code>views()</code> to define endpoints imperatively.</p> <p>Example - Basic Views:</p> Python<pre><code>class UserAPIView(APIView):\n    api = api_instance\n    router_tag = \"Users\"\n    api_route_path = \"/users\"\n\n    def views(self):\n        @self.router.get(\"/stats\")\n        async def get_stats(request):\n            return {\"total_users\": 100}\n\n        @self.router.post(\"/bulk-create\")\n        async def bulk_create(request, data: list[UserSchema]):\n            # bulk creation logic\n            return {\"created\": len(data)}\n</code></pre> <p>Example - With Authentication:</p> Python<pre><code>class ProtectedAPIView(APIView):\n    api = api_instance\n    router_tag = \"Protected\"\n    api_route_path = \"/protected\"\n    auth = [JWTAuth()]\n\n    def views(self):\n        # Authenticated endpoint\n        @self.router.get(\"/private\", auth=self.auth)\n        async def private_data(request):\n            return {\"user_id\": request.auth.user_id}\n\n        # Public endpoint\n        @self.router.get(\"/public\")\n        async def public_data(request):\n            return {\"message\": \"This is public\"}\n</code></pre>"},{"location":"api/views/api_view/#add_views_to_route","title":"<code>add_views_to_route()</code>","text":"<p>Registers all defined views to the API instance.</p> <p>Returns: The router instance</p> <p>Note: When using <code>@api.view(prefix=\"/path\", tags=[...])</code>, the router is mounted automatically and decorator-based endpoints are registered lazily on instantiation; manual registration via <code>add_views_to_route()</code> is not required.</p>"},{"location":"api/views/api_view/#complete-example","title":"Complete Example","text":"<p>Recommended:</p> Python<pre><code>from ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIView\nfrom ninja_aio.decorators import api_get, api_post\nfrom ninja import Schema\n\napi = NinjaAIO(title=\"My API\")\n\nclass StatsSchema(Schema):\n    total: int\n    active: int\n\n@api.view(prefix=\"/analytics\", tags=[\"Analytics\"])\nclass AnalyticsView(APIView):\n    @api_get(\"/dashboard\", response=StatsSchema)\n    async def dashboard(self, request):\n        return {\"total\": 1000, \"active\": 750}\n\n    @api_post(\"/track\")\n    async def track_event(self, request, event: str):\n        return {\"tracked\": event}\n</code></pre> <p>Alternative implementation:</p> Python<pre><code>api = NinjaAIO(title=\"My API\")\n\nclass AnalyticsView(APIView):\n    api = api\n    router_tag = \"Analytics\"\n    api_route_path = \"/analytics\"\n\n    def views(self):\n        @self.router.get(\"/dashboard\", response=StatsSchema)\n        async def dashboard(request):\n            return {\"total\": 1000, \"active\": 750}\n\n        @self.router.post(\"/track\")\n        async def track_event(request, event: str):\n            return {\"tracked\": event}\n\nAnalyticsView().add_views_to_route()\n</code></pre>"},{"location":"api/views/api_view/#notes","title":"Notes","text":"<ul> <li>Use <code>APIView</code> for simple, non-CRUD endpoints</li> <li>For CRUD operations, use <code>APIViewSet</code></li> <li>All views are async-compatible</li> <li>Standard error codes are available via <code>self.error_codes</code></li> <li>Decorator-based endpoints are preferred for clarity and better OpenAPI signatures.</li> </ul> <p>Note:</p> <ul> <li>Path schema PK type is inferred from the model\u2019s primary key for ViewSets.</li> <li>NinjaAIO remains API-compatible; global CSRF argument is no longer required in initialization.</li> </ul>"},{"location":"api/views/api_view/#see-also","title":"See Also","text":"<ul> <li>API View Set - Full CRUD operations</li> <li>Authentication - Authentication setup</li> </ul>"},{"location":"api/views/api_view_set/","title":"APIViewSet","text":"<p><code>APIViewSet</code> auto-generates async CRUD endpoints and optional Many-to-Many (M2M) endpoints for a Django <code>Model</code> or a <code>ModelSerializer</code>. It supports dynamic schema generation, per-verb authentication, pagination, list &amp; relation filtering with runtime-built Pydantic schemas, and custom view injection.</p>"},{"location":"api/views/api_view_set/#generated-crud-endpoints","title":"Generated CRUD Endpoints","text":"Method Path Summary Response POST <code>/{base}/</code> Create Model <code>201 schema_out</code> GET <code>/{base}/</code> List Models <code>200 List[schema_out]</code> (paginated) GET <code>/{base}/{pk}</code> Retrieve Model <code>200 schema_detail</code> (or <code>schema_out</code> if none) PATCH <code>/{base}/{pk}/</code> Update Model <code>200 schema_out</code> DELETE <code>/{base}/{pk}/</code> Delete Model <code>204 No Content</code> <p>Notes:</p> <ul> <li>Retrieve path typically includes a trailing slash by default (see settings below); update/delete include a trailing slash.</li> <li><code>{base}</code> auto-resolves from model verbose name plural (lowercase) unless <code>api_route_path</code> is provided.</li> <li>Error responses may use a unified generic schema for codes: 400, 401, 404.</li> </ul>"},{"location":"api/views/api_view_set/#settings-trailing-slash-behavior","title":"Settings: trailing slash behavior","text":"<ul> <li>NINJA_AIO_APPEND_SLASH (default: True)</li> <li>When True (default, for backward compatibility), retrieve and POST paths includes a trailing slash into CRUD: <code>/{base}/{pk}/</code>.</li> <li>When False, retrieve and post paths is generated without a trailing slash: <code>/{base}/{pk}</code>.</li> </ul>"},{"location":"api/views/api_view_set/#recommended-decorator-based-extra-endpoints","title":"Recommended: Decorator-based extra endpoints","text":"<p>Use class method decorators to add non-CRUD endpoints to your ViewSet. This is the preferred way to extend a ViewSet with custom routes. The decorators lazily bind instance methods to the router and ensure correct OpenAPI signatures (no <code>self</code> in parameters).</p> <p>Available decorators (from <code>ninja_aio.decorators</code>):</p> <ul> <li><code>@api_get(path, ...)</code></li> <li><code>@api_post(path, ...)</code></li> <li><code>@api_put(path, ...)</code></li> <li><code>@api_patch(path, ...)</code></li> <li><code>@api_delete(path, ...)</code></li> <li><code>@api_options(path, ...)</code></li> <li><code>@api_head(path, ...)</code></li> </ul> <p>Example:</p> Python<pre><code>from ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom ninja_aio.decorators import api_get, api_post\nfrom .models import Article\n\napi = NinjaAIO(title=\"Blog API\")\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    @api_get(\"/stats/\")\n    async def stats(self, request):\n        total = await self.model.objects.acount()\n        return {\"total\": total}\n\n    @api_post(\"/{pk}/publish/\")\n    async def publish(self, request, pk: int):\n        obj = await self.model.objects.aget(pk=pk)\n        obj.is_published = True\n        await obj.asave()\n        return {\"message\": \"published\"}\n</code></pre> <p>Notes:</p> <ul> <li>Decorators support per-endpoint <code>auth</code>, <code>response</code>, <code>tags</code>, <code>summary</code>, <code>description</code>, and more.</li> <li>Sync methods are executed via <code>sync_to_async</code> automatically.</li> <li>Signatures and type hints are preserved for OpenAPI (excluding <code>self</code>).</li> </ul>"},{"location":"api/views/api_view_set/#legacy-views-method-still-supported","title":"Legacy: views() method (still supported)","text":"<p>The previous pattern of injecting endpoints inside <code>views()</code> is still supported, but the decorator-based approach above is now recommended.</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    def views(self):\n        @self.router.get(\"/stats/\")\n        async def stats(request):\n            total = await self.model.objects.acount()\n            return {\"total\": total}\n\n        @self.router.post(\"/{pk}/publish/\")\n        async def publish(request, pk: int):\n            obj = await self.model.objects.aget(pk=pk)\n            obj.is_published = True\n            await obj.asave()\n            return {\"message\": \"published\"}\n</code></pre>"},{"location":"api/views/api_view_set/#core-attributes","title":"Core Attributes","text":"Attribute Type Default Description <code>model</code> <code>ModelSerializer \\| Model</code> \u2014 Target model (required) <code>api</code> <code>NinjaAPI</code> \u2014 API instance (required) <code>serializer_class</code> <code>Serializer \\| None</code> <code>None</code> Serializer class for plain models (alternative to ModelSerializer) <code>schema_in</code> <code>Schema \\| None</code> <code>None</code> (auto) Create input schema override <code>schema_out</code> <code>Schema \\| None</code> <code>None</code> (auto) List/output schema override <code>schema_detail</code> <code>Schema \\| None</code> <code>None</code> (auto) Retrieve/detail schema override (falls back to <code>schema_out</code>) <code>schema_update</code> <code>Schema \\| None</code> <code>None</code> (auto) Update input schema override <code>pagination_class</code> <code>type[AsyncPaginationBase]</code> <code>PageNumberPagination</code> Pagination strategy <code>query_params</code> <code>dict[str, tuple[type, ...]]</code> <code>{}</code> List endpoint filters definition <code>disable</code> <code>list[type[VIEW_TYPES]]</code> <code>[]</code> Disable CRUD views (<code>create</code>,<code>list</code>,<code>retrieve</code>,<code>update</code>,<code>delete</code>,<code>all</code>) <code>api_route_path</code> <code>str</code> <code>\"\"</code> Base route segment <code>list_docs</code> <code>str</code> <code>\"List all objects.\"</code> List endpoint description <code>create_docs</code> <code>str</code> <code>\"Create a new object.\"</code> Create endpoint description <code>retrieve_docs</code> <code>str</code> <code>\"Retrieve a specific object by its primary key.\"</code> Retrieve endpoint description <code>update_docs</code> <code>str</code> <code>\"Update an object by its primary key.\"</code> Update endpoint description <code>delete_docs</code> <code>str</code> <code>\"Delete an object by its primary key.\"</code> Delete endpoint description <code>m2m_relations</code> <code>list[M2MRelationSchema]</code> <code>[]</code> M2M relation configs <code>m2m_auth</code> <code>list \\| None</code> <code>NOT_SET</code> Default auth for all M2M endpoints (overridden per relation if set) <code>extra_decorators</code> <code>DecoratorsSchema</code> <code>DecoratorsSchema()</code> Custom decorators for CRUD operations <code>model_verbose_name</code> <code>str</code> <code>\"\"</code> Override model verbose name for display <code>model_verbose_name_plural</code> <code>str</code> <code>\"\"</code> Override model verbose name plural for display"},{"location":"api/views/api_view_set/#authentication-attributes","title":"Authentication Attributes","text":"Attribute Type Default Description <code>auth</code> <code>list \\| None</code> <code>NOT_SET</code> Global fallback auth <code>get_auth</code> <code>list \\| None</code> <code>NOT_SET</code> Auth for list + retrieve <code>post_auth</code> <code>list \\| None</code> <code>NOT_SET</code> Auth for create <code>patch_auth</code> <code>list \\| None</code> <code>NOT_SET</code> Auth for update <code>delete_auth</code> <code>list \\| None</code> <code>NOT_SET</code> Auth for delete <p>Resolution rules:</p> <ul> <li>Per-verb auth overrides <code>auth</code> when not <code>NOT_SET</code>.</li> <li><code>None</code> makes the endpoint public (no authentication).</li> <li>M2M endpoints use relation-level auth (<code>m2m_data.auth</code>) or fall back to <code>m2m_auth</code>.</li> </ul>"},{"location":"api/views/api_view_set/#transaction-management","title":"Transaction Management","text":"<p>Create, update, and delete operations are automatically wrapped in atomic transactions using the <code>@aatomic</code> decorator. This ensures that database operations are rolled back on exceptions:</p> Python<pre><code>@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    pass  # create/update/delete automatically transactional\n</code></pre> <p>The transaction behavior is applied by default. Custom decorators can be added via <code>extra_decorators</code> attribute.</p>"},{"location":"api/views/api_view_set/#automatic-schema-generation","title":"Automatic Schema Generation","text":"<p>If <code>model</code> is a subclass of <code>ModelSerializerMeta</code>:</p> <ul> <li><code>schema_out</code> is generated from <code>ReadSerializer</code></li> <li><code>schema_detail</code> is generated from <code>DetailSerializer</code> (optional, falls back to <code>schema_out</code>)</li> <li><code>schema_in</code> from <code>CreateSerializer</code></li> <li><code>schema_update</code> from <code>UpdateSerializer</code></li> </ul> <p>For plain Django models, you can provide a <code>serializer_class</code> (Serializer) instead:</p> Python<pre><code>from ninja_aio.models import serializers\n\nclass ArticleSerializer(serializers.Serializer):\n    class Meta:\n        model = models.Article\n        schema_in = serializers.SchemaModelConfig(\n            fields=[\"title\", \"content\", \"author\"]\n        )\n        schema_out = serializers.SchemaModelConfig(\n            fields=[\"id\", \"title\", \"content\", \"author\"]\n        )\n\n@api.viewset(model=models.Article)\nclass ArticleViewSet(APIViewSet):\n    serializer_class = ArticleSerializer\n</code></pre> <p>Otherwise provide schemas manually via <code>schema_in</code>, <code>schema_out</code>, <code>schema_detail</code>, and <code>schema_update</code> attributes.</p>"},{"location":"api/views/api_view_set/#detail-schema-for-retrieve-endpoint","title":"Detail Schema for Retrieve Endpoint","text":"<p>Use <code>schema_detail</code> (or <code>DetailSerializer</code> on ModelSerializer) when you want the retrieve endpoint to return more fields than the list endpoint. This is useful for:</p> <ul> <li>Performance optimization: List endpoints return minimal fields, retrieve endpoints include expensive relations</li> <li>API design: Clients get a summary in lists and full details on individual requests</li> </ul> Python<pre><code>from ninja_aio.models import ModelSerializer\nfrom django.db import models\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    summary = models.TextField()\n    content = models.TextField()\n    author = models.ForeignKey(User, on_delete=models.CASCADE)\n    tags = models.ManyToManyField(Tag)\n\n    class ReadSerializer:\n        # List view: minimal fields\n        fields = [\"id\", \"title\", \"summary\"]\n\n    class DetailSerializer:\n        # Detail view: all fields\n        fields = [\"id\", \"title\", \"summary\", \"content\", \"author\", \"tags\"]\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    pass  # Schemas auto-generated from model\n</code></pre> <p>Endpoints behavior: - <code>GET /articles/</code> returns <code>[{\"id\": 1, \"title\": \"...\", \"summary\": \"...\"}, ...]</code> - <code>GET /articles/1</code> returns <code>{\"id\": 1, \"title\": \"...\", \"summary\": \"...\", \"content\": \"...\", \"author\": {...}, \"tags\": [...]}</code></p>"},{"location":"api/views/api_view_set/#list-filtering","title":"List Filtering","text":"<p>Define filters for the list view with <code>query_params</code>:</p> Python<pre><code>query_params = {\n    \"is_active\": (bool, None),\n    \"role\": (str, None),\n    \"search\": (str, None),\n}\n</code></pre> <p>Override handler:</p> Python<pre><code>async def query_params_handler(self, queryset, filters: dict):\n    if filters.get(\"is_active\") is not None:\n        queryset = queryset.filter(is_active=filters[\"is_active\"])\n    if filters.get(\"role\"):\n        queryset = queryset.filter(role=filters[\"role\"])\n    if filters.get(\"search\"):\n        from django.db.models import Q\n        s = filters[\"search\"]\n        queryset = queryset.filter(Q(username__icontains=s) | Q(email__icontains=s))\n    return queryset\n</code></pre> <p>A dynamic Pydantic model (<code>FiltersSchema</code>) is built with <code>pydantic.create_model</code> from <code>query_params</code>.</p>"},{"location":"api/views/api_view_set/#list-and-retrieve-implementations","title":"List and Retrieve implementations","text":"<p>List now leverages ModelUtil.get_objects and list_read_s, automatically applying read optimizations and optional filters:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    def views(self):\n        @self.router.get(\"/\")\n        async def list(request, filters: self.filters_schema = None):\n            qs = await self.model_util.get_objects(\n                request,\n                query_data=self._get_query_data(),  # defaults from ModelSerializer.QuerySet.read\n                is_for_read=True,\n            )\n            if filters is not None:\n                qs = await self.query_params_handler(qs, filters.model_dump())\n            return await self.model_util.list_read_s(self.schema_out, request, qs)\n</code></pre> <p>Retrieve uses read_s with getters, deriving PK type from the model:</p> Python<pre><code>@self.router.get(\"/{pk}/\")\nasync def retrieve(request, pk: self.path_schema):\n    return await self.model_util.read_s(\n        self.schema_out,\n        request,\n        query_data=QuerySchema(getters={\"pk\": self._get_pk(pk)}),\n        is_for_read=True,\n    )\n</code></pre> <ul> <li>Path schema PK type is inferred from the model\u2019s primary key field.</li> </ul>"},{"location":"api/views/api_view_set/#many-to-many-relations","title":"Many-to-Many Relations","text":"<p>Relations are declared via <code>M2MRelationSchema</code> objects (not tuples). Each schema can include:</p> <ul> <li><code>model</code>: related Django model or ModelSerializer</li> <li><code>related_name</code>: attribute name on the main model (e.g. <code>\"tags\"</code>)</li> <li><code>path</code>: custom URL segment (optional)</li> <li><code>auth</code>: list of auth instances (optional)</li> <li><code>add</code>: enable additions (bool)</li> <li><code>remove</code>: enable removals (bool)</li> <li><code>get</code>: enable GET listing (bool)</li> <li><code>filters</code>: dict of <code>{param_name: (type, default)}</code> for relation-level filtering</li> <li><code>related_schema</code>: optional pre-built schema for the related model (auto-generated if the <code>model</code> is a <code>ModelSerializer</code>)</li> <li><code>serializer_class</code>: optional <code>Serializer</code> class for plain Django models. When provided, <code>related_schema</code> is auto-generated from the serializer. Cannot be used when <code>model</code> is a <code>ModelSerializer</code>.</li> <li><code>append_slash</code>: bool to control trailing slash for the GET relation endpoint path. Defaults to <code>False</code> (no trailing slash) for backward compatibility. When <code>True</code>, the GET path ends with a trailing slash.</li> </ul> <p>If <code>path</code> is empty it falls back to the related model verbose name (lowercase plural). If <code>filters</code> is provided, a per-relation filters schema is auto-generated and exposed on the GET relation endpoint: <code>GET /{base}/{pk}/{related_path}?param=value</code></p> <p>Custom filter hook naming convention: <code>&lt;related_name&gt;_query_params_handler(self, queryset, filters_dict)</code></p> <p>The M2M helper:</p> <ul> <li>Returns a paginated list of related items on GET.</li> <li>Supports both sync and async custom filter handlers.</li> <li>Uses <code>list_read_s</code> for related items serialization.</li> </ul> <p>Example filter handler (sync or async):</p> Python<pre><code>def tags_query_params_handler(self, queryset, filters_dict):\n    name = filters_dict.get(\"name\")\n    return queryset.filter(name=name) if name else queryset\n\n# or\n\nasync def tags_query_params_handler(self, queryset, filters_dict):\n    # perform async lookups if needed, then return queryset\n    return queryset\n</code></pre> <p>Warning: Model support</p> <ul> <li>You can supply a standard Django <code>Model</code> (not a <code>ModelSerializer</code>) in <code>M2MRelationSchema.model</code>. When doing so you must provide either <code>related_schema</code> manually or <code>serializer_class</code>:</li> </ul> With related_schemaWith serializer_class Python<pre><code>M2MRelationSchema(\n    model=Tag,                # plain django.db.models.Model\n    related_name=\"tags\",\n    related_schema=TagOut,    # a Pydantic/Ninja Schema you define\n    add=True,\n    remove=True,\n    get=True,\n)\n</code></pre> Python<pre><code>from ninja_aio.models import serializers\n\nclass TagSerializer(serializers.Serializer):\n    class Meta:\n        model = Tag\n        schema_out = serializers.SchemaModelConfig(fields=[\"id\", \"name\"])\n\nM2MRelationSchema(\n    model=Tag,                        # plain django.db.models.Model\n    related_name=\"tags\",\n    serializer_class=TagSerializer,   # auto-generates related_schema\n    add=True,\n    remove=True,\n    get=True,\n)\n</code></pre> <p>For <code>ModelSerializer</code> models, <code>related_schema</code> can be inferred automatically (via internal helpers).</p> <p>Note: You cannot use <code>serializer_class</code> when <code>model</code> is already a <code>ModelSerializer</code> - this will raise a <code>ValueError</code>.</p> <p>Example with filters:</p> Python<pre><code>class UserViewSet(APIViewSet):\n    model = User\n    api = api\n    m2m_relations = [\n        M2MRelationSchema(\n            model=Tag,\n            related_name=\"tags\",\n            filters={\"name\": (str, \"\")}\n        )\n    ]\n\n    async def tags_query_params_handler(self, queryset, filters):\n        name_filter = filters.get(\"name\")\n        if name_filter:\n            queryset = queryset.filter(name__icontains=name_filter)\n        return queryset\n</code></pre>"},{"location":"api/views/api_view_set/#relation-handlers-get-filters-vs-post-per-pk-resolution","title":"Relation Handlers: GET filters vs POST per-PK resolution","text":"<ul> <li> <p>GET filters handler (per relation):</p> </li> <li> <p>Name: <code>&lt;related_name&gt;_query_params_handler(self, queryset, filters_dict)</code></p> </li> <li>Purpose: apply filters to the related list queryset (GET endpoint).</li> <li> <p>Supports both synchronous and asynchronous functions.</p> </li> <li> <p>POST per-PK resolution handler (per relation):</p> </li> <li>Name: <code>&lt;related_name&gt;_query_handler(self, request, pk, instance)</code></li> <li>Purpose: resolve a single related object (for add/remove validation) before mutation.</li> <li>Must return a queryset; the object is resolved with <code>.afirst()</code>.</li> <li>Automatic fallback if missing: <code>ModelUtil(related_model).get_objects(request, ObjectsQuerySchema(filters={\"pk\": pk}))</code> + <code>.afirst()</code>.</li> </ul> <p>Example:</p> Python<pre><code>class MyViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    async def tags_query_params_handler(self, qs, filters: dict):\n        name = filters.get(\"name\")\n        return qs.filter(name__icontains=name) if name else qs\n\n    async def tags_query_handler(self, request, pk, instance):\n        # allow only tags belonging to the same project as the instance\n        return Tag.objects.filter(pk=pk, project_id=instance.project_id)\n</code></pre>"},{"location":"api/views/api_view_set/#endpoint-paths-and-operation-naming","title":"Endpoint paths and operation naming","text":"<ul> <li>GET relation: <code>/{base}/{pk}/{rel_path}</code> by default (no trailing slash). You can enable a trailing slash per relation with <code>append_slash=True</code>, resulting in <code>/{base}/{pk}/{rel_path}/</code>.</li> <li>POST relation: <code>/{base}/{pk}/{rel_path}/</code> (always with trailing slash).</li> </ul> <p>Path normalization rules:</p> <ul> <li>Relation <code>path</code> is normalized internally; providing <code>path</code> with or without a leading slash produces the same final URL.</li> <li>Example: <code>path=\"tags\"</code> or <code>path=\"/tags\"</code> both yield <code>GET /{base}/{pk}/tags</code> (or <code>GET /{base}/{pk}/tags/</code> when <code>append_slash=True</code>) and <code>POST /{base}/{pk}/tags/</code>.</li> <li>If <code>path</code> is empty, it falls back to the related model verbose name.</li> </ul>"},{"location":"api/views/api_view_set/#requestresponse-and-concurrency","title":"Request/Response and concurrency","text":"<p>Request bodies:</p> <ul> <li>Add &amp; Remove: <code>{ \"add\": number[], \"remove\": number[] }</code></li> <li>Add only: <code>{ \"add\": number[] }</code></li> <li>Remove only: <code>{ \"remove\": number[] }</code></li> </ul> <p>Standard response (M2MSchemaOut):</p> JSON<pre><code>{\n  \"results\": { \"count\": X, \"details\": [\"...\"] },\n  \"errors\": { \"count\": Y, \"details\": [\"...\"] }\n}\n</code></pre> <ul> <li>Concurrency: <code>aadd(...)</code> and <code>aremove(...)</code> run in parallel via <code>asyncio.gather</code> when both lists are non-empty.</li> <li>Per-PK errors include: object not found, state mismatch (removing non-related, adding already-related).</li> <li>Per-PK success messages indicate the executed action.</li> </ul>"},{"location":"api/views/api_view_set/#generated-m2m-endpoints-per-relation","title":"Generated M2M Endpoints (per relation)","text":"Method Path Feature GET <code>/{base}/{pk}/{rel_path}</code> List related objects (paginated, optional filters) POST <code>/{base}/{pk}/{rel_path}/</code> Add/remove related objects <p>Example:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    m2m_relations = [\n        M2MRelationSchema(model=Tag, related_name=\"tags\"),\n        M2MRelationSchema(model=Category, related_name=\"categories\", path=\"article-categories\"),\n        M2MRelationSchema(model=User, related_name=\"authors\", path=\"co-authors\", auth=[AdminAuth()])\n    ]\n    m2m_auth = [JWTAuth()]  # fallback for relations without custom auth\n</code></pre> <p>Example with trailing slash on GET relation:</p> Python<pre><code>M2MRelationSchema(\n    model=Tag,\n    related_name=\"tags\",\n    filters={\"name\": (str, \"\")},\n    append_slash=True,  # GET /{base}/{pk}/tags/\n)\n</code></pre>"},{"location":"api/views/api_view_set/#custom-views","title":"Custom Views","text":"<p>Preferred (decorators): see the section above.</p> <p>Legacy (still supported):</p> Python<pre><code>def views(self):\n    @self.router.get(\"/stats/\", response={200: GenericMessageSchema})\n    async def stats(request):\n        total = await self.model.objects.acount()\n        return {\"message\": f\"Total: {total}\"}\n</code></pre>"},{"location":"api/views/api_view_set/#dynamic-view-naming","title":"Dynamic View Naming","text":"<p>All generated handlers are decorated with <code>@unique_view(...)</code> to ensure stable unique function names (prevents collisions and ensures consistent OpenAPI schema generation). Relation endpoints use explicit names like <code>get_&lt;model&gt;_&lt;rel_path&gt;</code> and <code>manage_&lt;model&gt;_&lt;rel_path&gt;</code>.</p>"},{"location":"api/views/api_view_set/#extra-decorators","title":"Extra Decorators","text":"<p>Apply custom decorators to specific CRUD operations via the <code>extra_decorators</code> attribute:</p> Python<pre><code>from ninja_aio.schemas.helpers import DecoratorsSchema\nfrom functools import wraps\n\ndef log_operation(func):\n    @wraps(func)\n    async def wrapper(*args, **kwargs):\n        print(f\"Calling {func.__name__}\")\n        return await func(*args, **kwargs)\n    return wrapper\n\n@api.viewset(model=Article)\nclass ArticleViewSet(APIViewSet):\n    extra_decorators = DecoratorsSchema(\n        create=[log_operation],\n        update=[log_operation],\n        delete=[log_operation],\n    )\n</code></pre> <p>Available decorator fields: - <code>create</code>: Decorators for create endpoint - <code>list</code>: Decorators for list endpoint - <code>retrieve</code>: Decorators for retrieve endpoint - <code>update</code>: Decorators for update endpoint - <code>delete</code>: Decorators for delete endpoint</p>"},{"location":"api/views/api_view_set/#overridable-hooks","title":"Overridable Hooks","text":"Hook Purpose <code>views()</code> Register custom endpoints <code>query_params_handler(queryset, filters)</code> Apply list filters <code>&lt;related_name&gt;_query_params_handler(queryset, filters)</code> Apply relation-specific filters"},{"location":"api/views/api_view_set/#error-handling","title":"Error Handling","text":"<p>All CRUD and M2M endpoints may respond with <code>GenericMessageSchema</code> for error codes: 400 (validation), 401 (auth), 404 (not found).</p>"},{"location":"api/views/api_view_set/#performance-tips","title":"Performance Tips","text":"<ol> <li>Implement <code>@classmethod async def queryset_request(cls, request)</code> in your <code>ModelSerializer</code> to prefetch related objects.</li> <li>Use database indexes on filtered fields (<code>query_params</code> and relation <code>filters</code>).</li> <li>Keep pagination enabled for large datasets.</li> <li>Prefetch reverse relations via <code>model_util.get_reverse_relations()</code> (already applied in list view).</li> <li>Limit slice size for expensive searches if needed (<code>queryset = queryset[:1000]</code>).</li> </ol>"},{"location":"api/views/api_view_set/#minimal-usage","title":"Minimal Usage","text":"RecommendedAlternative implementation <p>````python from ninja_aio import NinjaAIO from ninja_aio.views import APIViewSet from .models import User from ninja_aio.decorators import api_get</p> <p>api = NinjaAIO(title=\"My API\")</p> <p>@api.viewset(model=User) class UserViewSet(APIViewSet):     @api_get(\"/stats/\")     async def stats(self, request):         total = await self.model.objects.acount()         return {\"total\": total} ```</p> Python<pre><code>from ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom .models import User\n\napi = NinjaAIO(title=\"My API\")\n\nclass UserViewSet(APIViewSet):\n    model = User\n    api = api\n\n    def views(self):\n        @self.router.get(\"/stats/\")\n        async def stats(request):\n            total = await self.model.objects.acount()\n            return {\"total\": total}\n\nUserViewSet().add_views_to_route()\n</code></pre> <p>Note: prefix and tags are optional. If omitted, the base path is inferred from the model verbose name plural and tags default to the model verbose name.</p>"},{"location":"api/views/api_view_set/#disable-selected-views","title":"Disable Selected Views","text":"Python<pre><code>@api.viewset(model=User)\nclass ReadOnlyUserViewSet(APIViewSet):\n    disable = [\"create\", \"update\", \"delete\"]\n</code></pre>"},{"location":"api/views/api_view_set/#authentication-example","title":"Authentication Example","text":"Python<pre><code>@api.viewset(model=User)\nclass UserViewSet(APIViewSet):\n    auth = [JWTAuth()]      # global fallback\n    get_auth = None         # list/retrieve public\n    delete_auth = [AdminAuth()]  # delete restricted\n</code></pre>"},{"location":"api/views/api_view_set/#complete-m2m-filters-example","title":"Complete M2M + Filters Example","text":"<p>Recommended:</p> Python<pre><code>from ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom ninja_aio.models import ModelSerializer\nfrom ninja_aio.decorators import api_get\nfrom django.db import models\n\napi = NinjaAIO(title=\"My API\")\n\nclass Tag(ModelSerializer):\n    name = models.CharField(max_length=100)\n    class ReadSerializer:\n        fields = [\"id\", \"name\"]\n\nclass User(ModelSerializer):\n    username = models.CharField(max_length=150)\n    tags = models.ManyToManyField(Tag, related_name=\"users\")\n    class ReadSerializer:\n        fields = [\"id\", \"username\", \"tags\"]\n\n@api.viewset(model=User)\nclass UserViewSet(APIViewSet):\n    query_params = {\"search\": (str, None)}\n    m2m_relations = [\n        M2MRelationSchema(\n            model=Tag,\n            related_name=\"tags\",\n            filters={\"name\": (str, \"\")},\n            add=True,\n            remove=True,\n            get=True,\n        )\n    ]\n\n    async def query_params_handler(self, queryset, filters):\n        if filters.get(\"search\"):\n            from django.db.models import Q\n            s = filters[\"search\"]\n            return queryset.filter(Q(username__icontains=s))\n        return queryset\n\n    async def tags_query_params_handler(self, queryset, filters):\n        name_filter = filters.get(\"name\")\n        if name_filter:\n            queryset = queryset.filter(name__icontains=name_filter)\n        return queryset\n</code></pre> <p>Alternative implementation:</p> Python<pre><code>class UserViewSet(APIViewSet):\n    model = User\n    api = api\n    query_params = {\"search\": (str, None)}\n    m2m_relations = [\n        M2MRelationSchema(\n            model=Tag,\n            related_name=\"tags\",\n            filters={\"name\": (str, \"\")},\n            add=True,\n            remove=True,\n            get=True,\n        )\n    ]\n\n    async def query_params_handler(self, queryset, filters):\n        if filters.get(\"search\"):\n            from django.db.models import Q\n            s = filters[\"search\"]\n            return queryset.filter(Q(username__icontains=s))\n        return queryset\n\n    async def tags_query_params_handler(self, queryset, filters):\n        name_filter = filters.get(\"name\")\n        if name_filter:\n            queryset = queryset.filter(name__icontains=name_filter)\n        return queryset\n\nUserViewSet().add_views_to_route()\n</code></pre>"},{"location":"api/views/api_view_set/#readonlyviewset","title":"ReadOnlyViewSet","text":"<p>ReadOnlyViewSet enables only list and retrieve endpoints.</p> Python<pre><code>@api.viewset(model=MyModel)\nclass MyModelReadOnlyViewSet(ReadOnlyViewSet):\n    pass\n</code></pre>"},{"location":"api/views/api_view_set/#writeonlyviewset","title":"WriteOnlyViewSet","text":"<p>WriteOnlyViewSet enables only create, update, and delete endpoints.</p> Python<pre><code>@api.viewset(model=MyModel)\nclass MyModelWriteOnlyViewSet(WriteOnlyViewSet):\n    pass\n</code></pre>"},{"location":"api/views/api_view_set/#see-also","title":"See Also","text":"<ul> <li>ModelSerializer</li> <li>Authentication</li> <li>Pagination</li> <li>APIView</li> </ul>"},{"location":"api/views/decorators/","title":"View decorators","text":"<p>This package provides:</p> <ul> <li>decorate_view: compose multiple decorators (sync/async views), preserving Python stacking order, and skipping None values.</li> <li>APIViewSet.extra_decorators: declarative per-operation decorators.</li> </ul>"},{"location":"api/views/decorators/#decorate_view","title":"decorate_view","text":"<p>Behavior:</p> <ul> <li>Order matches normal stacking: <code>@d1</code> over <code>@d2</code> \u2261 <code>d1(d2(view))</code>.</li> <li>Works with sync/async views.</li> <li>Ignores None values, useful for conditional decoration.</li> </ul> <p>Example:</p> Python<pre><code>from ninja_aio.decorators import decorate_view\nfrom ninja_aio.views import APIViewSet\n\nclass MyViewSet(APIViewSet):\n    api = api\n    model = MyModel\n\n    def views(self):\n        @self.router.get(\"health/\")\n        @decorate_view(authenticate, log_request)\n        async def health(request):\n            return {\"ok\": True}\n</code></pre> <p>Conditional decoration:</p> Python<pre><code>cache_dec = cache_page(60) if settings.ENABLE_CACHE else None\n\n@self.router.get(\"data/\")\n@decorate_view(cache_dec, authenticate)\nasync def data(request):\n    ...\n</code></pre> <p>Note: decorate_view does not add an extra wrapper; each decorator should preserve metadata itself (e.g., functools.wraps).</p>"},{"location":"api/views/decorators/#apiviewsetextra_decorators","title":"APIViewSet.extra_decorators","text":"<p>Attach decorators to CRUD operations without redefining views:</p> Python<pre><code>from ninja_aio.schemas.helpers import DecoratorsSchema\n\n@api.viewset(MyModel)\nclass MyViewSet(APIViewSet):\n    extra_decorators = DecoratorsSchema(\n        list=[require_auth, cache_page(30)],\n        retrieve=[require_auth],\n        create=[require_auth],\n        update=[require_auth],\n        delete=[require_auth],\n    )\n</code></pre> <p>These are applied in combination with built-ins (e.g., unique_view, paginate) using decorate_view in the implementation.</p>"},{"location":"api/views/decorators/#apimethodfactorydecorators","title":"ApiMethodFactory.decorators","text":"<p>Example: use api_get within a ViewSet with extra decorators:</p> Python<pre><code>from ninja.pagination import PageNumberPagination\nfrom ninja_aio.decorators.operations import api_get\nfrom ninja_aio.views import APIViewSet\nfrom ninja_aio.models import ModelSerializer\nfrom ninja_aio.decorators import unique_view\nfrom ninja.pagination import paginate\n\nfrom . import models\n\napi = NinjaAIO()\n\n@api.viewset(models.Book)\nclass BookAPI(APIViewSet):\n    query_params = {\n        \"title\": (str, None),\n    }\n\n    @api_get(\n        \"/custom-get\",\n        response={200: list[GenericMessageSchema]},\n        decorators=[paginate(PageNumberPagination), unique_view(\"test-unique-view\")],\n    )\n    async def get_test(self, request):\n        return [{\"message\": \"This is a custom GET method in BookAPI\"}]\n</code></pre> <p>Notes:</p> <ul> <li>Provide decorators as a list; they are applied in reverse order internally.</li> <li>paginate(PageNumberPagination) enables async pagination on the handler.</li> <li>unique_view(name) marks the route as unique to avoid duplicate registration.</li> <li>Works with @api.viewset(Model) classes extending APIViewSet.</li> </ul>"},{"location":"api/views/mixins/","title":"ViewSet Mixins","text":"<p>These mixins implement a query_params_handler to apply common filtering patterns to Django QuerySets. Import from <code>ninja_aio.views.mixins</code>. Values used for filtering come from validated query params in your viewset\u2019s <code>query_params</code>.</p> <p>Note: Each mixin overrides <code>query_params_handler</code>. When composing multiple mixins, define your own <code>query_params_handler</code> and call <code>super()</code> in the desired order.</p>"},{"location":"api/views/mixins/#icontainsfilterviewsetmixin","title":"IcontainsFilterViewSetMixin","text":"<p>Applies case-insensitive substring filters (<code>__icontains</code>) for string values.</p> <ul> <li>Behavior: For each <code>str</code> value in <code>filters</code>, applies <code>field__icontains=value</code>.</li> <li>Ignores non-string values.</li> </ul> <p>Example:</p> Python<pre><code>from ninja_aio.views.mixins import IcontainsFilterViewSetMixin\nfrom ninja_aio.views.api import APIViewSet\n\nclass UserViewSet(IcontainsFilterViewSetMixin, APIViewSet):\n    model = models.User\n    api = api\n    query_params = {\"name\": (str, \"\"), \"email\": (str, \"\")}\n</code></pre>"},{"location":"api/views/mixins/#booleanfilterviewsetmixin","title":"BooleanFilterViewSetMixin","text":"<p>Filters boolean fields using exact match.</p> <ul> <li>Behavior: Applies <code>{key: value}</code> only for <code>bool</code> values.</li> </ul> <p>Example:</p> Python<pre><code>from ninja_aio.views.mixins import BooleanFilterViewSetMixin\n\nclass FeatureViewSet(BooleanFilterViewSetMixin, APIViewSet):\n    model = models.FeatureFlag\n    api = api\n    query_params = {\"enabled\": (bool, False)}\n</code></pre>"},{"location":"api/views/mixins/#numericfilterviewsetmixin","title":"NumericFilterViewSetMixin","text":"<p>Applies exact filters for numeric values.</p> <ul> <li>Behavior: Filters only <code>int</code> and <code>float</code> values.</li> </ul> <p>Example:</p> Python<pre><code>from ninja_aio.views.mixins import NumericFilterViewSetMixin\n\nclass OrderViewSet(NumericFilterViewSetMixin, APIViewSet):\n    model = models.Order\n    api = api\n    query_params = {\"amount\": (float, 0.0), \"quantity\": (int, 0)}\n</code></pre>"},{"location":"api/views/mixins/#datefilterviewsetmixin","title":"DateFilterViewSetMixin","text":"<p>Base mixin for date/datetime filtering with custom comparisons.</p> <ul> <li>Attributes:</li> <li><code>_compare_attr</code>: comparison operator suffix (e.g., <code>__gt</code>, <code>__lt</code>, <code>__gte</code>, <code>__lte</code>).</li> <li>Behavior: Applies filters for values that implement <code>isoformat</code> (date/datetime-like). Prefer using Pydantic <code>date</code>/<code>datetime</code> types in <code>query_params</code>.</li> </ul> <p>Example:</p> Python<pre><code>from ninja_aio.views.mixins import DateFilterViewSetMixin\n\nclass EventViewSet(DateFilterViewSetMixin, APIViewSet):\n    model = models.Event\n    api = api\n    # Use date/datetime types so values have `isoformat`.\n    query_params = {\"created_at\": (datetime, None)}\n    _compare_attr = \"__gt\"\n</code></pre>"},{"location":"api/views/mixins/#greaterdatefilterviewsetmixin","title":"GreaterDateFilterViewSetMixin","text":"<p>Sets comparison to strict greater-than (<code>__gt</code>).</p> <p>Example:</p> Python<pre><code>from ninja_aio.views.mixins import GreaterDateFilterViewSetMixin\n\nclass EventViewSet(GreaterDateFilterViewSetMixin, APIViewSet):\n    model = models.Event\n    api = api\n    query_params = {\"created_at\": (datetime, None)}\n</code></pre>"},{"location":"api/views/mixins/#lessdatefilterviewsetmixin","title":"LessDateFilterViewSetMixin","text":"<p>Sets comparison to strict less-than (<code>__lt</code>).</p> <p>Example:</p> Python<pre><code>from ninja_aio.views.mixins import LessDateFilterViewSetMixin\n\nclass EventViewSet(LessDateFilterViewSetMixin, APIViewSet):\n    model = models.Event\n    api = api\n    query_params = {\"created_at\": (datetime, None)}\n</code></pre>"},{"location":"api/views/mixins/#greaterequaldatefilterviewsetmixin","title":"GreaterEqualDateFilterViewSetMixin","text":"<p>Sets comparison to greater-than-or-equal (<code>__gte</code>).</p> <p>Example:</p> Python<pre><code>from ninja_aio.views.mixins import GreaterEqualDateFilterViewSetMixin\n\nclass EventViewSet(GreaterEqualDateFilterViewSetMixin, APIViewSet):\n    model = models.Event\n    api = api\n    query_params = {\"created_at\": (datetime, None)}\n</code></pre>"},{"location":"api/views/mixins/#lessequaldatefilterviewsetmixin","title":"LessEqualDateFilterViewSetMixin","text":"<p>Sets comparison to less-than-or-equal (<code>__lte</code>).</p> <p>Example:</p> Python<pre><code>from ninja_aio.views.mixins import LessEqualDateFilterViewSetMixin\n\nclass EventViewSet(LessEqualDateFilterViewSetMixin, APIViewSet):\n    model = models.Event\n    api = api\n    query_params = {\"created_at\": (datetime, None)}\n</code></pre>"},{"location":"api/views/mixins/#relationfilterviewsetmixin","title":"RelationFilterViewSetMixin","text":"<p>Filters by related model fields using configurable <code>RelationFilterSchema</code> entries.</p> <ul> <li>Behavior: Maps query parameters to Django ORM lookups on related models.</li> <li>Configuration: Define <code>relations_filters</code> as a list of <code>RelationFilterSchema</code> objects.</li> <li>Query params are automatically registered from <code>relations_filters</code>.</li> </ul> <p>Each <code>RelationFilterSchema</code> requires:</p> <ul> <li><code>query_param</code>: The API query parameter name exposed to clients.</li> <li><code>query_filter</code>: The Django ORM lookup path (e.g., <code>author__id</code>, <code>category__name__icontains</code>).</li> <li><code>filter_type</code>: Tuple of <code>(type, default)</code> for schema generation (e.g., <code>(int, None)</code>).</li> </ul> <p>Example:</p> Python<pre><code>from ninja_aio.views.mixins import RelationFilterViewSetMixin\nfrom ninja_aio.views.api import APIViewSet\nfrom ninja_aio.schemas import RelationFilterSchema\n\nclass BookViewSet(RelationFilterViewSetMixin, APIViewSet):\n    model = models.Book\n    api = api\n    relations_filters = [\n        RelationFilterSchema(\n            query_param=\"author\",\n            query_filter=\"author__id\",\n            filter_type=(int, None),\n        ),\n        RelationFilterSchema(\n            query_param=\"category_name\",\n            query_filter=\"category__name__icontains\",\n            filter_type=(str, None),\n        ),\n    ]\n</code></pre> <p>This enables:</p> <ul> <li><code>GET /books?author=5</code> \u2192 <code>queryset.filter(author__id=5)</code></li> <li><code>GET /books?category_name=fiction</code> \u2192 <code>queryset.filter(category__name__icontains=\"fiction\")</code></li> </ul>"},{"location":"api/views/mixins/#matchcasefilterviewsetmixin","title":"MatchCaseFilterViewSetMixin","text":"<p>Applies conditional filtering based on boolean query parameters, where different filter conditions are applied for <code>True</code> and <code>False</code> values. This is useful when you need to map a simple boolean API parameter to complex underlying filter logic.</p> <ul> <li>Behavior: For each <code>MatchCaseFilterSchema</code> entry, applies different Django ORM filters based on the boolean value of the query parameter.</li> <li>Configuration: Define <code>filters_match_cases</code> as a list of <code>MatchCaseFilterSchema</code> objects.</li> <li>Query params are automatically registered from <code>filters_match_cases</code>.</li> <li>Supports both <code>filter()</code> (include) and <code>exclude()</code> operations via the <code>include</code> attribute.</li> </ul> <p>Each <code>MatchCaseFilterSchema</code> requires:</p> <ul> <li><code>query_param</code>: The API query parameter name exposed to clients.</li> <li><code>cases</code>: A <code>BooleanMatchFilterSchema</code> defining the filter conditions for <code>True</code> and <code>False</code> cases.</li> </ul> <p>Each <code>MatchConditionFilterSchema</code> (used within <code>BooleanMatchFilterSchema</code>) requires:</p> <ul> <li><code>query_filter</code>: A dictionary of Django ORM lookups to apply (e.g., <code>{\"status\": \"active\"}</code>).</li> <li><code>include</code>: Boolean indicating whether to use <code>filter()</code> (True) or <code>exclude()</code> (False). Defaults to <code>True</code>.</li> </ul> <p>Example - Simple status filtering:</p> Python<pre><code>from ninja_aio.views.mixins import MatchCaseFilterViewSetMixin\nfrom ninja_aio.views.api import APIViewSet\nfrom ninja_aio.schemas import (\n    MatchCaseFilterSchema,\n    MatchConditionFilterSchema,\n    BooleanMatchFilterSchema,\n)\n\nclass OrderViewSet(MatchCaseFilterViewSetMixin, APIViewSet):\n    model = models.Order\n    api = api\n    filters_match_cases = [\n        MatchCaseFilterSchema(\n            query_param=\"is_completed\",\n            cases=BooleanMatchFilterSchema(\n                true=MatchConditionFilterSchema(\n                    query_filter={\"status\": \"completed\"},\n                    include=True,\n                ),\n                false=MatchConditionFilterSchema(\n                    query_filter={\"status\": \"completed\"},\n                    include=False,  # excludes completed orders\n                ),\n            ),\n        ),\n    ]\n</code></pre> <p>This enables:</p> <ul> <li><code>GET /orders?is_completed=true</code> \u2192 <code>queryset.filter(status=\"completed\")</code></li> <li><code>GET /orders?is_completed=false</code> \u2192 <code>queryset.exclude(status=\"completed\")</code></li> </ul> <p>Example - Complex filtering with multiple conditions:</p> Python<pre><code>class TaskViewSet(MatchCaseFilterViewSetMixin, APIViewSet):\n    model = models.Task\n    api = api\n    filters_match_cases = [\n        MatchCaseFilterSchema(\n            query_param=\"show_active\",\n            cases=BooleanMatchFilterSchema(\n                true=MatchConditionFilterSchema(\n                    query_filter={\"status__in\": [\"pending\", \"in_progress\"]},\n                    include=True,\n                ),\n                false=MatchConditionFilterSchema(\n                    query_filter={\"status__in\": [\"completed\", \"cancelled\"]},\n                    include=True,\n                ),\n            ),\n        ),\n    ]\n</code></pre> <p>This enables:</p> <ul> <li><code>GET /tasks?show_active=true</code> \u2192 <code>queryset.filter(status__in=[\"pending\", \"in_progress\"])</code></li> <li><code>GET /tasks?show_active=false</code> \u2192 <code>queryset.filter(status__in=[\"completed\", \"cancelled\"])</code></li> </ul>"},{"location":"api/views/mixins/#tips","title":"Tips","text":"<ul> <li>Align <code>query_params</code> types with expected filter values; prefer Pydantic <code>date</code>/<code>datetime</code> for date filters so values implement <code>isoformat</code>.</li> <li>Validate field names and lookups to avoid runtime errors.</li> <li>For multiple mixins, implement your own <code>async def query_params_handler(...)</code> and chain with <code>await super().query_params_handler(...)</code> to combine behaviors.</li> </ul>"},{"location":"getting_started/installation/","title":"Installation","text":""},{"location":"getting_started/installation/#installation","title":"\ud83d\udce6 Installation","text":"Bash<pre><code>pip install django-ninja-aio-crud\n</code></pre> <p>Requirements: - Python 3.8+ - Django 4.1+ (for async ORM support) - django-ninja</p>"},{"location":"getting_started/quick_start/","title":"Quick Start","text":""},{"location":"getting_started/quick_start/#quick-start","title":"\ud83d\ude80 Quick Start","text":""},{"location":"getting_started/quick_start/#1-create-your-model","title":"1. Create Your Model","text":"<p>Define your model using <code>ModelSerializer</code>:</p> Python<pre><code># models.py\nfrom django.db import models\nfrom ninja_aio.models import ModelSerializer\n\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    is_published = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"content\", \"is_published\", \"created_at\"]\n\n    class CreateSerializer:\n        fields = [\"title\", \"content\"]\n        optionals = [(\"is_published\", bool)]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"title\", str),\n            (\"content\", str),\n            (\"is_published\", bool),\n        ]\n</code></pre>"},{"location":"getting_started/quick_start/#2-create-your-viewset","title":"2. Create Your ViewSet","text":"<p>Define your API views using <code>APIViewSet</code>:</p> Python<pre><code># views.py\nfrom ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom .models import Article\n\napi = NinjaAIO(title=\"My Blog API\", version=\"1.0.0\")\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n\nArticleViewSet().add_views_to_route()\n</code></pre>"},{"location":"getting_started/quick_start/#3-configure-urls","title":"3. Configure URLs","text":"<p>Add the API to your URL configuration:</p> Python<pre><code># urls.py\nfrom django.urls import path\nfrom .views import api\n\nurlpatterns = [\n    path(\"api/\", api.urls),\n]\n</code></pre>"},{"location":"getting_started/quick_start/#4-run-your-server","title":"4. Run Your Server","text":"Bash<pre><code>python manage.py runserver\n</code></pre> <p>Visit http://localhost:8000/api/docs to see your auto-generated API documentation!</p>"},{"location":"getting_started/quick_start/#generated-api-documentation","title":"\ud83d\udcf8 Generated API Documentation","text":""},{"location":"getting_started/quick_start/#endpoints-overview","title":"Endpoints Overview","text":"<p>Your API automatically includes:</p> Method Endpoint Description <code>GET</code> <code>/article/</code> List all articles (paginated) <code>POST</code> <code>/article/</code> Create new article <code>GET</code> <code>/article/{id}</code> Retrieve single article <code>PATCH</code> <code>/article/{id}/</code> Update article <code>DELETE</code> <code>/article/{id}/</code> Delete article"},{"location":"getting_started/quick_start/#list-endpoint","title":"List Endpoint","text":"<p>Features: - Automatic pagination - Query parameter filtering - Sorting support</p>"},{"location":"getting_started/quick_start/#create-endpoint","title":"Create Endpoint","text":"<p>Features: - Input validation - Custom field support - Relationship handling</p>"},{"location":"getting_started/quick_start/#retrieve-endpoint","title":"Retrieve Endpoint","text":"<p>Features: - Nested relationship serialization - Optimized queries</p>"},{"location":"getting_started/quick_start/#update-endpoint","title":"Update Endpoint","text":"<p>Features: - Partial updates (PATCH) - Field-level validation - Custom actions</p>"},{"location":"getting_started/quick_start/#delete-endpoint","title":"Delete Endpoint","text":"<p>Features: - Soft delete support - Cascade handling - Custom hooks</p>"},{"location":"tutorial/authentication/","title":"Step 3: Add Authentication","text":"<p>In this step, you'll learn how to secure your API with JWT authentication and implement role-based access control.</p>"},{"location":"tutorial/authentication/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Setting up JWT authentication</li> <li>Protecting endpoints</li> <li>Implementing role-based access</li> <li>Creating login/register endpoints</li> <li>Testing authenticated requests</li> </ul>"},{"location":"tutorial/authentication/#prerequisites","title":"Prerequisites","text":"<p>Make sure you've completed: - Step 1: Define Your Model - Step 2: Create CRUD Views</p>"},{"location":"tutorial/authentication/#setting-up-jwt-keys","title":"Setting Up JWT Keys","text":""},{"location":"tutorial/authentication/#generate-rsa-keys-recommended-for-production","title":"Generate RSA Keys (Recommended for Production)","text":"Bash<pre><code># Generate private key\nopenssl genrsa -out private_key.pem 2048\n\n# Generate public key\nopenssl rsa -in private_key.pem -pubout -out public_key.pem\n</code></pre>"},{"location":"tutorial/authentication/#store-keys-securely","title":"Store Keys Securely","text":"Python<pre><code># settings.py\nimport os\nfrom pathlib import Path\n\nBASE_DIR = Path(__file__).resolve().parent.parent\n\n# JWT Settings\nJWT_PRIVATE_KEY_PATH = os.path.join(BASE_DIR, 'private_key.pem')\nJWT_PUBLIC_KEY_PATH = os.path.join(BASE_DIR, 'public_key.pem')\n\n# Read keys\nwith open(JWT_PUBLIC_KEY_PATH, 'r') as f:\n    JWT_PUBLIC_KEY = f.read()\n\nwith open(JWT_PRIVATE_KEY_PATH, 'r') as f:\n    JWT_PRIVATE_KEY = f.read()\n\n# Token expiration (in seconds)\nJWT_ACCESS_TOKEN_EXPIRE = 60 * 15  # 15 minutes\nJWT_REFRESH_TOKEN_EXPIRE = 60 * 60 * 24 * 7  # 7 days\n\n# JWT Claims\nJWT_ISSUER = \"https://your-api.com\"\nJWT_AUDIENCE = \"your-api\"\n</code></pre> <p>Security</p> <p>Never commit your private key to version control! Add <code>private_key.pem</code> to your <code>.gitignore</code>.</p>"},{"location":"tutorial/authentication/#create-user-model","title":"Create User Model","text":"<p>Update your User model to work with authentication:</p> Python<pre><code># models.py\nfrom django.contrib.auth.models import AbstractUser\nfrom django.db import models\nfrom ninja_aio.models import ModelSerializer\n\n\nclass User(AbstractUser, ModelSerializer):\n    email = models.EmailField(unique=True)\n    bio = models.TextField(blank=True)\n    avatar = models.URLField(blank=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"username\", \"email\", \"first_name\", \"last_name\", \"bio\", \"avatar\"]\n        excludes = [\"password\"]\n\n    class CreateSerializer:\n        fields = [\"username\", \"email\", \"password\", \"first_name\", \"last_name\"]\n        optionals = [(\"bio\", str), (\"avatar\", str)]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"first_name\", str),\n            (\"last_name\", str),\n            (\"bio\", str),\n            (\"avatar\", str),\n        ]\n        excludes = [\"username\", \"email\", \"password\"]\n\n    def __str__(self):\n        return self.username\n\n\n# Update Article model to use custom User\nclass Article(ModelSerializer):\n    # ... existing fields ...\n    author = models.ForeignKey(\n        \"User\",  # Use string reference\n        on_delete=models.CASCADE,\n        related_name=\"articles\"\n    )\n    # ... rest of model ...\n</code></pre>"},{"location":"tutorial/authentication/#configure-django-to-use-custom-user","title":"Configure Django to Use Custom User","text":"Python<pre><code># settings.py\nAUTH_USER_MODEL = 'myapp.User'  # Replace 'myapp' with your app name\n</code></pre>"},{"location":"tutorial/authentication/#run-migrations","title":"Run Migrations","text":"Bash<pre><code>python manage.py makemigrations\npython manage.py migrate\n</code></pre>"},{"location":"tutorial/authentication/#create-authentication-class","title":"Create Authentication Class","text":"Python<pre><code># auth.py\nfrom ninja_aio.auth import AsyncJwtBearer\nfrom joserfc import jwk\nfrom django.conf import settings\nfrom .models import User\n\n\nclass JWTAuth(AsyncJwtBearer):\n    # Import public key for verification\n    jwt_public = jwk.RSAKey.import_key(settings.JWT_PUBLIC_KEY)\n    jwt_alg = \"RS256\"\n\n    # Validate required claims\n    claims = {\n        \"iss\": {\"essential\": True, \"value\": settings.JWT_ISSUER},\n        \"aud\": {\"essential\": True, \"value\": settings.JWT_AUDIENCE},\n        \"sub\": {\"essential\": True},  # User ID\n    }\n\n    async def auth_handler(self, request):\n        \"\"\"\n        Called after token validation.\n        Returns the user object that will be attached to request.auth\n        \"\"\"\n        # Get user ID from token\n        user_id = self.dcd.claims.get(\"sub\")\n\n        try:\n            # Fetch user from database\n            user = await User.objects.aget(id=user_id, is_active=True)\n            return user\n        except User.DoesNotExist:\n            return False\n</code></pre>"},{"location":"tutorial/authentication/#create-token-generation-helper","title":"Create Token Generation Helper","text":"Python<pre><code># utils.py\nfrom datetime import datetime, timedelta\nimport jwt\nfrom django.conf import settings\n\n\ndef create_access_token(user_id: int, **extra_claims) -&gt; str:\n    \"\"\"Generate JWT access token\"\"\"\n    now = datetime.utcnow()\n\n    payload = {\n        \"sub\": str(user_id),\n        \"iss\": settings.JWT_ISSUER,\n        \"aud\": settings.JWT_AUDIENCE,\n        \"iat\": now,\n        \"exp\": now + timedelta(seconds=settings.JWT_ACCESS_TOKEN_EXPIRE),\n        **extra_claims\n    }\n\n    token = jwt.encode(\n        payload,\n        settings.JWT_PRIVATE_KEY,\n        algorithm=\"RS256\"\n    )\n\n    return token\n\n\ndef create_refresh_token(user_id: int) -&gt; str:\n    \"\"\"Generate JWT refresh token\"\"\"\n    now = datetime.utcnow()\n\n    payload = {\n        \"sub\": str(user_id),\n        \"iss\": settings.JWT_ISSUER,\n        \"aud\": settings.JWT_AUDIENCE,\n        \"iat\": now,\n        \"exp\": now + timedelta(seconds=settings.JWT_REFRESH_TOKEN_EXPIRE),\n        \"type\": \"refresh\"\n    }\n\n    token = jwt.encode(\n        payload,\n        settings.JWT_PRIVATE_KEY,\n        algorithm=\"RS256\"\n    )\n\n    return token\n</code></pre>"},{"location":"tutorial/authentication/#create-loginregister-endpoints","title":"Create Login/Register Endpoints","text":"Python<pre><code># views.py\nfrom ninja_aio import NinjaAIO\nfrom ninja import Schema\nfrom ninja_aio.exceptions import SerializeError\nfrom django.contrib.auth.hashers import make_password, check_password\nfrom .models import User\nfrom .utils import create_access_token, create_refresh_token\nfrom .auth import JWTAuth\n\napi = NinjaAIO(title=\"Blog API\", version=\"1.0.0\")\n\n\n# Schemas for authentication\nclass RegisterSchema(Schema):\n    username: str\n    email: str\n    password: str\n    first_name: str = \"\"\n    last_name: str = \"\"\n\n\nclass LoginSchema(Schema):\n    username: str\n    password: str\n\n\nclass TokenResponse(Schema):\n    access_token: str\n    refresh_token: str\n    token_type: str = \"bearer\"\n    expires_in: int\n\n\nclass UserResponse(Schema):\n    id: int\n    username: str\n    email: str\n    first_name: str\n    last_name: str\n\n\n# Register endpoint\n@api.post(\"/auth/register/\", response=TokenResponse)\nasync def register(request, data: RegisterSchema):\n    \"\"\"Register a new user\"\"\"\n    # Check if username exists\n    if await User.objects.filter(username=data.username).aexists():\n        raise SerializeError(\n            {\"username\": \"Username already taken\"},\n            status_code=400\n        )\n\n    # Check if email exists\n    if await User.objects.filter(email=data.email).aexists():\n        raise SerializeError(\n            {\"email\": \"Email already registered\"},\n            status_code=400\n        )\n\n    # Create user\n    user = await User.objects.acreate(\n        username=data.username,\n        email=data.email,\n        password=make_password(data.password),\n        first_name=data.first_name,\n        last_name=data.last_name,\n    )\n\n    # Generate tokens\n    access_token = create_access_token(user.id)\n    refresh_token = create_refresh_token(user.id)\n\n    from django.conf import settings\n    return {\n        \"access_token\": access_token,\n        \"refresh_token\": refresh_token,\n        \"expires_in\": settings.JWT_ACCESS_TOKEN_EXPIRE\n    }\n\n\n# Login endpoint\n@api.post(\"/auth/login/\", response=TokenResponse)\nasync def login(request, data: LoginSchema):\n    \"\"\"Login user\"\"\"\n    try:\n        user = await User.objects.aget(username=data.username)\n    except User.DoesNotExist:\n        raise SerializeError(\n            {\"detail\": \"Invalid credentials\"},\n            status_code=401\n        )\n\n    # Check password\n    if not check_password(data.password, user.password):\n        raise SerializeError(\n            {\"detail\": \"Invalid credentials\"},\n            status_code=401\n        )\n\n    # Check if user is active\n    if not user.is_active:\n        raise SerializeError(\n            {\"detail\": \"Account is disabled\"},\n            status_code=401\n        )\n\n    # Generate tokens\n    access_token = create_access_token(user.id)\n    refresh_token = create_refresh_token(user.id)\n\n    from django.conf import settings\n    return {\n        \"access_token\": access_token,\n        \"refresh_token\": refresh_token,\n        \"expires_in\": settings.JWT_ACCESS_TOKEN_EXPIRE\n    }\n\n\n# Get current user\n@api.get(\"/auth/me/\", response=UserResponse, auth=JWTAuth())\nasync def me(request):\n    \"\"\"Get current authenticated user\"\"\"\n    user = request.auth\n    return {\n        \"id\": user.id,\n        \"username\": user.username,\n        \"email\": user.email,\n        \"first_name\": user.first_name,\n        \"last_name\": user.last_name,\n    }\n\n\n# Refresh token\n@api.post(\"/auth/refresh/\", response=TokenResponse)\nasync def refresh(request, refresh_token: str):\n    \"\"\"Refresh access token\"\"\"\n    import jwt\n    from django.conf import settings\n\n    try:\n        # Decode refresh token\n        payload = jwt.decode(\n            refresh_token,\n            settings.JWT_PUBLIC_KEY,\n            algorithms=[\"RS256\"],\n            audience=settings.JWT_AUDIENCE,\n            issuer=settings.JWT_ISSUER\n        )\n\n        # Check token type\n        if payload.get(\"type\") != \"refresh\":\n            raise SerializeError(\n                {\"detail\": \"Invalid token type\"},\n                status_code=401\n            )\n\n        user_id = int(payload.get(\"sub\"))\n\n        # Generate new tokens\n        new_access_token = create_access_token(user_id)\n        new_refresh_token = create_refresh_token(user_id)\n\n        return {\n            \"access_token\": new_access_token,\n            \"refresh_token\": new_refresh_token,\n            \"expires_in\": settings.JWT_ACCESS_TOKEN_EXPIRE\n        }\n\n    except jwt.ExpiredSignatureError:\n        raise SerializeError(\n            {\"detail\": \"Refresh token expired\"},\n            status_code=401\n        )\n    except jwt.InvalidTokenError:\n        raise SerializeError(\n            {\"detail\": \"Invalid refresh token\"},\n            status_code=401\n        )\n</code></pre>"},{"location":"tutorial/authentication/#protect-your-viewsets","title":"Protect Your ViewSets","text":"<p>Now let's add authentication to your CRUD endpoints:</p> Python<pre><code># views.py\nfrom ninja_aio.views import APIViewSet\nfrom .models import Article\nfrom .auth import JWTAuth\n\napi = NinjaAIO(title=\"Blog API\", version=\"1.0.0\")\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    # Public read, authenticated write\n    get_auth = None  # List and retrieve are public\n    post_auth = [JWTAuth()]  # Create requires auth\n    patch_auth = [JWTAuth()]  # Update requires auth\n    delete_auth = [JWTAuth()]  # Delete requires auth\n\n\nArticleViewSet().add_views_to_route()\n</code></pre>"},{"location":"tutorial/authentication/#set-author-automatically","title":"Set Author Automatically","text":"<p>Modify the Article model to set the author from the authenticated user:</p> Python<pre><code># models.py\nclass Article(ModelSerializer):\n    # ... existing fields ...\n\n    @classmethod\n    async def queryset_request(cls, request):\n        \"\"\"Filter articles based on authentication\"\"\"\n        qs = cls.objects.select_related('author', 'category').prefetch_related('tags')\n\n        # Show all published articles\n        # Plus user's own drafts if authenticated\n        if request.auth:\n            from django.db.models import Q\n            return qs.filter(\n                Q(is_published=True) | Q(author=request.auth)\n            )\n\n        return qs.filter(is_published=True)\n\n    async def custom_actions(self, payload: dict):\n        \"\"\"Set author from request\"\"\"\n        # This is called during creation\n        if hasattr(self, '_request') and self._request.auth:\n            self.author = self._request.auth\n            await self.asave(update_fields=['author'])\n\n        # Call parent\n        await super().custom_actions(payload)\n</code></pre>"},{"location":"tutorial/authentication/#role-based-access-control","title":"Role-Based Access Control","text":"<p>Create different authentication classes for different roles:</p> Python<pre><code># auth.py\nfrom ninja_aio.auth import AsyncJwtBearer\nfrom joserfc import jwk\nfrom django.conf import settings\nfrom .models import User\n\n\nclass JWTAuth(AsyncJwtBearer):\n    \"\"\"Base JWT authentication\"\"\"\n    jwt_public = jwk.RSAKey.import_key(settings.JWT_PUBLIC_KEY)\n    jwt_alg = \"RS256\"\n    claims = {\n        \"iss\": {\"essential\": True, \"value\": settings.JWT_ISSUER},\n        \"aud\": {\"essential\": True, \"value\": settings.JWT_AUDIENCE},\n        \"sub\": {\"essential\": True},\n    }\n\n    async def auth_handler(self, request):\n        user_id = self.dcd.claims.get(\"sub\")\n        try:\n            user = await User.objects.aget(id=user_id, is_active=True)\n            return user\n        except User.DoesNotExist:\n            return False\n\n\nclass AdminAuth(JWTAuth):\n    \"\"\"Requires admin/staff privileges\"\"\"\n\n    async def auth_handler(self, request):\n        user = await super().auth_handler(request)\n\n        if not user.is_staff:\n            return False\n\n        return user\n\n\nclass SuperuserAuth(JWTAuth):\n    \"\"\"Requires superuser privileges\"\"\"\n\n    async def auth_handler(self, request):\n        user = await super().auth_handler(request)\n\n        if not user.is_superuser:\n            return False\n\n        return user\n</code></pre>"},{"location":"tutorial/authentication/#apply-role-based-auth","title":"Apply Role-Based Auth","text":"Python<pre><code># views.py\nfrom .auth import JWTAuth, AdminAuth\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    # Public read\n    get_auth = None\n\n    # Regular users can create\n    post_auth = [JWTAuth()]\n\n    # Regular users can update (own articles)\n    patch_auth = [JWTAuth()]\n\n    # Only admins can delete\n    delete_auth = [AdminAuth()]\n\n\nclass UserViewSet(APIViewSet):\n    model = User\n    api = api\n\n    # Only admins can manage users\n    auth = [AdminAuth()]\n\n\nArticleViewSet().add_views_to_route()\nUserViewSet().add_views_to_route()\n</code></pre>"},{"location":"tutorial/authentication/#ownership-validation","title":"Ownership Validation","text":"<p>Ensure users can only edit their own articles:</p> Python<pre><code># views.py\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    get_auth = None\n    post_auth = [JWTAuth()]\n    patch_auth = [JWTAuth()]\n    delete_auth = [JWTAuth()]\n\n    def views(self):\n        # Override update to check ownership\n        @self.router.patch(\"/{pk}/\")\n        async def update(request, pk: int, data: Article.generate_update_s()):\n            \"\"\"Update article (owner or admin only)\"\"\"\n            try:\n                article = await Article.objects.aget(pk=pk)\n            except Article.DoesNotExist:\n                raise SerializeError({\"article\": \"not found\"}, status_code=404)\n\n            # Check ownership (unless admin)\n            user = request.auth\n            if article.author_id != user.id and not user.is_staff:\n                raise SerializeError(\n                    {\"detail\": \"You can only edit your own articles\"},\n                    status_code=403\n                )\n\n            # Update article\n            from ninja_aio.models import ModelUtil\n            util = ModelUtil(Article)\n            schema = Article.generate_read_s()\n\n            return await util.update_s(request, article, data, schema)\n\n        # Override delete to check ownership\n        @self.router.delete(\"/{pk}/\")\n        async def delete(request, pk: int):\n            \"\"\"Delete article (owner or admin only)\"\"\"\n            try:\n                article = await Article.objects.aget(pk=pk)\n            except Article.DoesNotExist:\n                raise SerializeError({\"article\": \"not found\"}, status_code=404)\n\n            # Check ownership (unless admin)\n            user = request.auth\n            if article.author_id != user.id and not user.is_staff:\n                raise SerializeError(\n                    {\"detail\": \"You can only delete your own articles\"},\n                    status_code=403\n                )\n\n            await article.adelete()\n            return {\"message\": \"Article deleted successfully\"}\n\n\nArticleViewSet().add_views_to_route()\n</code></pre>"},{"location":"tutorial/authentication/#testing-authentication","title":"Testing Authentication","text":""},{"location":"tutorial/authentication/#register-a-user","title":"Register a User","text":"Bash<pre><code>curl -X POST http://localhost:8000/api/auth/register/ \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"username\": \"johndoe\",\n    \"email\": \"john@example.com\",\n    \"password\": \"secure_password_123\",\n    \"first_name\": \"John\",\n    \"last_name\": \"Doe\"\n  }'\n</code></pre> <p>Response:</p> JSON<pre><code>{\n  \"access_token\": \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...\",\n  \"refresh_token\": \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...\",\n  \"token_type\": \"bearer\",\n  \"expires_in\": 900\n}\n</code></pre>"},{"location":"tutorial/authentication/#login","title":"Login","text":"Bash<pre><code>curl -X POST http://localhost:8000/api/auth/login/ \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"username\": \"johndoe\",\n    \"password\": \"secure_password_123\"\n  }'\n</code></pre>"},{"location":"tutorial/authentication/#get-current-user","title":"Get Current User","text":"Bash<pre><code>curl http://localhost:8000/api/auth/me/ \\\n  -H \"Authorization: Bearer YOUR_ACCESS_TOKEN\"\n</code></pre>"},{"location":"tutorial/authentication/#create-article-authenticated","title":"Create Article (Authenticated)","text":"Bash<pre><code>curl -X POST http://localhost:8000/api/article/ \\\n  -H \"Authorization: Bearer YOUR_ACCESS_TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"title\": \"My Article\",\n    \"content\": \"Article content...\",\n    \"category\": 1\n  }'\n</code></pre>"},{"location":"tutorial/authentication/#refresh-token","title":"Refresh Token","text":"Bash<pre><code>curl -X POST http://localhost:8000/api/auth/refresh/ \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"refresh_token\": \"YOUR_REFRESH_TOKEN\"}'\n</code></pre>"},{"location":"tutorial/authentication/#error-responses","title":"Error Responses","text":""},{"location":"tutorial/authentication/#missing-token","title":"Missing Token","text":"Bash<pre><code>curl http://localhost:8000/api/article/ \\\n  -X POST \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"title\": \"Test\"}'\n</code></pre> <p>Response (401):</p> JSON<pre><code>{\n  \"detail\": \"Unauthorized\"\n}\n</code></pre>"},{"location":"tutorial/authentication/#invalid-token","title":"Invalid Token","text":"Bash<pre><code>curl http://localhost:8000/api/article/ \\\n  -H \"Authorization: Bearer invalid_token\" \\\n  -X POST\n</code></pre> <p>Response (401):</p> JSON<pre><code>{\n  \"detail\": \"Invalid token\"\n}\n</code></pre>"},{"location":"tutorial/authentication/#expired-token","title":"Expired Token","text":"<p>Response (401):</p> JSON<pre><code>{\n  \"detail\": \"Token has expired\"\n}\n</code></pre>"},{"location":"tutorial/authentication/#insufficient-permissions","title":"Insufficient Permissions","text":"Bash<pre><code># Regular user trying to delete\ncurl -X DELETE http://localhost:8000/api/article/1/ \\\n  -H \"Authorization: Bearer USER_TOKEN\"\n</code></pre> <p>Response (403):</p> JSON<pre><code>{\n  \"detail\": \"Admin privileges required\"\n}\n</code></pre>"},{"location":"tutorial/authentication/#using-swagger-ui-with-auth","title":"Using Swagger UI with Auth","text":"<p>The Swagger UI at <code>/api/docs</code> has built-in authentication support:</p> <ol> <li>Click the \"Authorize\" button at the top</li> <li>Enter your token: <code>Bearer YOUR_ACCESS_TOKEN</code></li> <li>Click \"Authorize\"</li> <li>Now all requests will include the token</li> </ol>"},{"location":"tutorial/authentication/#custom-claims","title":"Custom Claims","text":"<p>Add custom claims to your tokens:</p> Python<pre><code># utils.py\ndef create_access_token(user_id: int, **extra_claims) -&gt; str:\n    \"\"\"Generate JWT access token with custom claims\"\"\"\n    now = datetime.utcnow()\n\n    # Add custom claims\n    payload = {\n        \"sub\": str(user_id),\n        \"iss\": settings.JWT_ISSUER,\n        \"aud\": settings.JWT_AUDIENCE,\n        \"iat\": now,\n        \"exp\": now + timedelta(seconds=settings.JWT_ACCESS_TOKEN_EXPIRE),\n        **extra_claims\n    }\n\n    return jwt.encode(payload, settings.JWT_PRIVATE_KEY, algorithm=\"RS256\")\n\n\n# In login endpoint\nasync def login(request, data: LoginSchema):\n    # ... authentication logic ...\n\n    # Create token with custom claims\n    access_token = create_access_token(\n        user.id,\n        email=user.email,\n        username=user.username,\n        is_staff=user.is_staff,\n        permissions=[\"read:articles\", \"write:articles\"]\n    )\n\n    # ...\n</code></pre> <p>Access custom claims in your auth handler:</p> Python<pre><code>class JWTAuth(AsyncJwtBearer):\n    # ...\n\n    async def auth_handler(self, request):\n        user_id = self.dcd.claims.get(\"sub\")\n        user = await User.objects.aget(id=user_id, is_active=True)\n\n        # Attach custom claims to request\n        request.user_permissions = self.dcd.claims.get(\"permissions\", [])\n        request.user_email = self.dcd.claims.get(\"email\")\n\n        return user\n</code></pre>"},{"location":"tutorial/authentication/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Use RSA keys in production: Python<pre><code>jwt_public = jwk.RSAKey.import_key(settings.JWT_PUBLIC_KEY)\njwt_alg = \"RS256\"\n</code></pre></p> </li> <li> <p>Keep access tokens short-lived: Python<pre><code>JWT_ACCESS_TOKEN_EXPIRE = 60 * 15  # 15 minutes\n</code></pre></p> </li> <li> <p>Use refresh tokens: Python<pre><code>JWT_REFRESH_TOKEN_EXPIRE = 60 * 60 * 24 * 7  # 7 days\n</code></pre></p> </li> <li> <p>Validate claims: Python<pre><code>claims = {\n    \"iss\": {\"essential\": True, \"value\": \"your-issuer\"},\n    \"aud\": {\"essential\": True, \"value\": \"your-api\"},\n}\n</code></pre></p> </li> <li> <p>Hash passwords properly: Python<pre><code>from django.contrib.auth.hashers import make_password\npassword = make_password(raw_password)\n</code></pre></p> </li> <li> <p>Check user ownership: Python<pre><code>if article.author_id != user.id and not user.is_staff:\n    raise SerializeError({\"detail\": \"Forbidden\"}, status_code=403)\n</code></pre></p> </li> <li> <p>Use HTTPS in production - Never send tokens over HTTP</p> </li> <li> <p>Implement token blacklist for logout functionality</p> </li> </ol>"},{"location":"tutorial/authentication/#next-steps","title":"Next Steps","text":"<p>Now that you have authentication set up, let's customize schemas in Step 4: Filtering &amp; Pagination.</p> <p>What You've Learned</p> <ul> <li>\u2705 Setting up JWT authentication</li> <li>\u2705 Creating login/register endpoints</li> <li>\u2705 Protecting API endpoints</li> <li>\u2705 Implementing role-based access control</li> <li>\u2705 Validating ownership</li> <li>\u2705 Testing authenticated requests</li> </ul>"},{"location":"tutorial/authentication/#see-also","title":"See Also","text":"<ul> <li>Authentication API Reference - Complete authentication documentation</li> <li>APIViewSet Auth Options - ViewSet authentication options</li> </ul>"},{"location":"tutorial/crud/","title":"Step 2: Create CRUD Views","text":"<p>In this step, you'll learn how to create a complete REST API with CRUD operations using <code>APIViewSet</code>.</p>"},{"location":"tutorial/crud/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>How to create a basic ViewSet</li> <li>Understanding auto-generated endpoints</li> <li>Customizing query parameters</li> <li>Adding custom endpoints</li> <li>Working with request context</li> <li>Handling errors</li> </ul>"},{"location":"tutorial/crud/#prerequisites","title":"Prerequisites","text":"<p>Make sure you've completed:</p> <ul> <li>Step 1: Define Your Model</li> </ul> <p>You should have the <code>Article</code>, <code>Author</code>, <code>Category</code>, and <code>Tag</code> models defined.</p>"},{"location":"tutorial/crud/#basic-viewset","title":"Basic ViewSet","text":"<p>Let's create a simple API for the Article model:</p> Python<pre><code># views.py\nfrom ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom .models import Article\n\n# Create API instance\napi = NinjaAIO(\n    title=\"Blog API\",\n    version=\"1.0.0\",\n    description=\"A simple blog API built with Django Ninja Aio CRUD\"\n)\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n\n# Register the ViewSet\nArticleViewSet().add_views_to_route()\n</code></pre> <p>That's it! You now have a complete CRUD API with 5 endpoints.</p>"},{"location":"tutorial/crud/#configure-urls","title":"Configure URLs","text":"<p>Add the API to your Django URLs:</p> Python<pre><code># urls.py\nfrom django.contrib import admin\nfrom django.urls import path\nfrom myapp.views import api\n\nurlpatterns = [\n    path(\"admin/\", admin.site.urls),\n    path(\"api/\", api.urls),\n]\n</code></pre>"},{"location":"tutorial/crud/#auto-generated-endpoints","title":"Auto-Generated Endpoints","text":"<p>The ViewSet automatically generates these endpoints:</p> Method Endpoint Description Request Body Response <code>GET</code> <code>/api/article/</code> List all articles (paginated) None <code>{count, next, previous, results}</code> <code>POST</code> <code>/api/article/</code> Create new article Article data Created article <code>GET</code> <code>/api/article/{id}</code> Retrieve single article None Article data <code>PATCH</code> <code>/api/article/{id}/</code> Update article Partial article data Updated article <code>DELETE</code> <code>/api/article/{id}/</code> Delete article None None (204)"},{"location":"tutorial/crud/#test-your-api","title":"Test Your API","text":"<p>Start the development server:</p> Bash<pre><code>python manage.py runserver\n</code></pre> <p>Visit http://localhost:8000/api/docs to see the auto-generated Swagger UI documentation.</p>"},{"location":"tutorial/crud/#creating-multiple-viewsets","title":"Creating Multiple ViewSets","text":"<p>Let's add APIs for all our models:</p> Python<pre><code># views.py\nfrom ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom .models import Article, Author, Category, Tag\n\napi = NinjaAIO(title=\"Blog API\", version=\"1.0.0\")\n\n\nclass AuthorViewSet(APIViewSet):\n    model = Author\n    api = api\n\n\nclass CategoryViewSet(APIViewSet):\n    model = Category\n    api = api\n\n\nclass TagViewSet(APIViewSet):\n    model = Tag\n    api = api\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n\n# Register all ViewSets\nAuthorViewSet().add_views_to_route()\nCategoryViewSet().add_views_to_route()\nTagViewSet().add_views_to_route()\nArticleViewSet().add_views_to_route()\n</code></pre> <p>Now you have complete CRUD APIs for all models:</p> <ul> <li><code>/api/author/</code></li> <li><code>/api/category/</code></li> <li><code>/api/tag/</code></li> <li><code>/api/article/</code></li> </ul>"},{"location":"tutorial/crud/#adding-query-parameters","title":"Adding Query Parameters","text":"<p>Let's add filtering to the Article list endpoint:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    query_params = {\n        \"is_published\": (bool, None),\n        \"author\": (int, None),\n        \"category\": (int, None),\n        \"search\": (str, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        # Filter by published status\n        if filters.get(\"is_published\") is not None:\n            queryset = queryset.filter(is_published=filters[\"is_published\"])\n\n        # Filter by author\n        if filters.get(\"author\"):\n            queryset = queryset.filter(author_id=filters[\"author\"])\n\n        # Filter by category\n        if filters.get(\"category\"):\n            queryset = queryset.filter(category_id=filters[\"category\"])\n\n        # Search in title and content\n        if filters.get(\"search\"):\n            from django.db.models import Q\n            search_term = filters[\"search\"]\n            queryset = queryset.filter(\n                Q(title__icontains=search_term) |\n                Q(content__icontains=search_term)\n            )\n\n        return queryset\n\n\nArticleViewSet().add_views_to_route()\n</code></pre>"},{"location":"tutorial/crud/#using-query-parameters","title":"Using Query Parameters","text":"<p>Now you can filter articles:</p> Bash<pre><code># Get published articles\nGET /api/article/?is_published=true\n\n# Get articles by specific author\nGET /api/article/?author=5\n\n# Get articles in specific category\nGET /api/article/?category=3\n\n# Search articles\nGET /api/article/?search=django\n\n# Combine filters\nGET /api/article/?is_published=true&amp;author=5&amp;category=3\n\n# With pagination\nGET /api/article/?is_published=true&amp;page=2&amp;page_size=20\n</code></pre>"},{"location":"tutorial/crud/#custom-endpoints","title":"Custom Endpoints","text":"<p>Add custom endpoints beyond CRUD:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    def views(self):\n        \"\"\"Define custom endpoints\"\"\"\n\n        # Publish an article\n        @self.router.post(\"/{pk}/publish/\")\n        async def publish(request, pk: int):\n            article = await Article.objects.aget(pk=pk)\n            article.is_published = True\n            from django.utils import timezone\n            article.published_at = timezone.now()\n            await article.asave()\n\n            return {\n                \"message\": \"Article published successfully\",\n                \"published_at\": article.published_at\n            }\n\n        # Unpublish an article\n        @self.router.post(\"/{pk}/unpublish/\")\n        async def unpublish(request, pk: int):\n            article = await Article.objects.aget(pk=pk)\n            article.is_published = False\n            article.published_at = None\n            await article.asave()\n\n            return {\"message\": \"Article unpublished successfully\"}\n\n        # Increment view count\n        @self.router.post(\"/{pk}/view/\")\n        async def increment_views(request, pk: int):\n            article = await Article.objects.aget(pk=pk)\n            article.views += 1\n            await article.asave(update_fields=[\"views\"])\n\n            return {\"views\": article.views}\n\n        # Get article statistics\n        @self.router.get(\"/stats/\")\n        async def stats(request):\n            from django.db.models import Count, Avg, Sum\n\n            total = await Article.objects.acount()\n            published = await Article.objects.filter(is_published=True).acount()\n\n            # Use sync_to_async for aggregate\n            from asgiref.sync import sync_to_async\n\n            avg_views = await sync_to_async(\n                lambda: Article.objects.aggregate(avg=Avg(\"views\"))\n            )()\n\n            total_views = await sync_to_async(\n                lambda: Article.objects.aggregate(total=Sum(\"views\"))\n            )()\n\n            return {\n                \"total_articles\": total,\n                \"published_articles\": published,\n                \"draft_articles\": total - published,\n                \"average_views\": avg_views[\"avg\"] or 0,\n                \"total_views\": total_views[\"total\"] or 0,\n            }\n\n        # Get popular articles\n        @self.router.get(\"/popular/\")\n        async def popular(request, limit: int = 10):\n            articles = []\n            async for article in Article.objects.filter(\n                is_published=True\n            ).order_by(\"-views\")[:limit]:\n                articles.append(article)\n\n            # Serialize articles\n            from ninja_aio.models import ModelUtil\n            util = ModelUtil(Article)\n            schema = Article.generate_read_s()\n\n            results = []\n            for article in articles:\n                data = await util.read_s(request, article, schema)\n                results.append(data)\n\n            return results\n\n\nArticleViewSet().add_views_to_route()\n</code></pre>"},{"location":"tutorial/crud/#custom-endpoint-urls","title":"Custom Endpoint URLs","text":"<p>Your custom endpoints are now available:</p> Bash<pre><code># Publish article\nPOST /api/article/1/publish/\n\n# Unpublish article\nPOST /api/article/1/unpublish/\n\n# Increment views\nPOST /api/article/1/view/\n\n# Get statistics\nGET /api/article/stats/\n\n# Get popular articles (top 10)\nGET /api/article/popular/\n\n# Get top 20\nGET /api/article/popular/?limit=20\n</code></pre>"},{"location":"tutorial/crud/#request-context","title":"Request Context","text":"<p>Access request information in your ViewSet:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    def views(self):\n        @self.router.get(\"/my-articles/\")\n        async def my_articles(request):\n            \"\"\"Get articles by current user\"\"\"\n            # Access authenticated user\n            user = request.auth\n\n            # Get user's articles\n            articles = []\n            async for article in Article.objects.filter(author=user):\n                articles.append(article)\n\n            # Serialize\n            from ninja_aio.models import ModelUtil\n            util = ModelUtil(Article)\n            schema = Article.generate_read_s()\n\n            results = []\n            for article in articles:\n                data = await util.read_s(request, article, schema)\n                results.append(data)\n\n            return results\n\n        @self.router.post(\"/\")\n        async def create_article(request, data: Article.generate_create_s()):\n            \"\"\"Override create to set author from request\"\"\"\n            # Set author from authenticated user\n            data.author = request.auth.id\n\n            # Use default create logic\n            from ninja_aio.models import ModelUtil\n            util = ModelUtil(Article)\n            schema = Article.generate_read_s()\n\n            return await util.create_s(request, data, schema)\n\n\nArticleViewSet().add_views_to_route()\n</code></pre>"},{"location":"tutorial/crud/#filtering-by-user","title":"Filtering by User","text":"<p>Automatically filter queryset based on user:</p> Python<pre><code>class Article(ModelSerializer):\n    # ... fields ...\n\n    @classmethod\n    async def queryset_request(cls, request):\n        \"\"\"Filter articles based on user\"\"\"\n        qs = cls.objects.select_related('author', 'category').prefetch_related('tags')\n\n        # If user is not authenticated, show only published\n        if not request.auth:\n            return qs.filter(is_published=True)\n\n        # If user is admin, show all\n        user = request.auth\n        if user.is_staff:\n            return qs\n\n        # Regular users see published + their own drafts\n        from django.db.models import Q\n        return qs.filter(\n            Q(is_published=True) | Q(author=user)\n        )\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    # queryset_request is automatically called for all operations\n\n\nArticleViewSet().add_views_to_route()\n</code></pre>"},{"location":"tutorial/crud/#custom-pagination","title":"Custom Pagination","text":"<p>Override default pagination:</p> Python<pre><code>from ninja.pagination import PageNumberPagination\n\n\nclass LargePagePagination(PageNumberPagination):\n    page_size = 50  # Default 50 items per page\n    max_page_size = 200  # Allow up to 200 items\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    pagination_class = LargePagePagination\n\n\nArticleViewSet().add_views_to_route()\n</code></pre> <p>Now list endpoint uses custom pagination:</p> Bash<pre><code># Default 50 items\nGET /api/article/\n\n# Custom page size\nGET /api/article/?page_size=100\n\n# Page 2\nGET /api/article/?page=2&amp;page_size=50\n</code></pre>"},{"location":"tutorial/crud/#ordering","title":"Ordering","text":"<p>Add ordering to list endpoint:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    query_params = {\n        \"is_published\": (bool, None),\n        \"ordering\": (str, \"-created_at\"),  # Default: newest first\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        # Apply published filter\n        if filters.get(\"is_published\") is not None:\n            queryset = queryset.filter(is_published=filters[\"is_published\"])\n\n        # Apply ordering\n        ordering = filters.get(\"ordering\", \"-created_at\")\n\n        # Validate ordering field\n        valid_fields = [\n            \"created_at\", \"-created_at\",\n            \"title\", \"-title\",\n            \"views\", \"-views\",\n            \"published_at\", \"-published_at\"\n        ]\n\n        if ordering in valid_fields:\n            queryset = queryset.order_by(ordering)\n\n        return queryset\n\n\nArticleViewSet().add_views_to_route()\n</code></pre> <p>Usage:</p> Bash<pre><code># Newest first (default)\nGET /api/article/\n\n# Oldest first\nGET /api/article/?ordering=created_at\n\n# By title A-Z\nGET /api/article/?ordering=title\n\n# By title Z-A\nGET /api/article/?ordering=-title\n\n# Most viewed\nGET /api/article/?ordering=-views\n\n# Recently published\nGET /api/article/?ordering=-published_at\n</code></pre>"},{"location":"tutorial/crud/#error-handling","title":"Error Handling","text":"<p>Handle errors gracefully:</p> Python<pre><code>from ninja_aio.exceptions import SerializeError, NotFoundError\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    def views(self):\n        @self.router.post(\"/{pk}/publish/\")\n        async def publish(request, pk: int):\n            try:\n                article = await Article.objects.aget(pk=pk)\n            except Article.DoesNotExist:\n                raise NotFoundError(self.model)\n\n            # Check if already published\n            if article.is_published:\n                raise SerializeError(\n                    {\"article\": \"already published\"},\n                    status_code=400\n                )\n\n            # Publish\n            article.is_published = True\n            from django.utils import timezone\n            article.published_at = timezone.now()\n            await article.asave()\n\n            return {\n                \"message\": \"Article published successfully\",\n                \"published_at\": article.published_at\n            }\n\n\nArticleViewSet().add_views_to_route()\n</code></pre>"},{"location":"tutorial/crud/#disabling-endpoints","title":"Disabling Endpoints","text":"<p>Disable specific CRUD operations:</p> Python<pre><code>class CategoryViewSet(APIViewSet):\n    model = Category\n    api = api\n\n    # Disable delete (categories can't be deleted)\n    disable_delete = True\n\n    # Disable update (categories are immutable)\n    disable_update = True\n\n\nCategoryViewSet().add_views_to_route()\n</code></pre> <p>Now only these endpoints are available:</p> <ul> <li><code>GET /api/category/</code> - List</li> <li><code>POST /api/category/</code> - Create</li> <li><code>GET /api/category/{id}</code> - Retrieve</li> </ul>"},{"location":"tutorial/crud/#response-customization","title":"Response Customization","text":"<p>Customize response format:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    def views(self):\n        @self.router.get(\"/{pk}/\")\n        async def retrieve(request, pk: int):\n            \"\"\"Custom retrieve with additional data\"\"\"\n            article = await Article.objects.select_related(\n                'author', 'category'\n            ).prefetch_related('tags').aget(pk=pk)\n\n            # Serialize article\n            from ninja_aio.models import ModelUtil\n            util = ModelUtil(Article)\n            schema = Article.generate_read_s()\n            article_data = await util.read_s(request, article, schema)\n\n            # Get related articles\n            related = []\n            async for rel_article in Article.objects.filter(\n                category=article.category,\n                is_published=True\n            ).exclude(pk=pk)[:5]:\n                rel_data = await util.read_s(request, rel_article, schema)\n                related.append(rel_data)\n\n            # Get author's other articles\n            author_articles = []\n            async for auth_article in Article.objects.filter(\n                author=article.author,\n                is_published=True\n            ).exclude(pk=pk)[:5]:\n                auth_data = await util.read_s(request, auth_article, schema)\n                author_articles.append(auth_data)\n\n            return {\n                \"article\": article_data,\n                \"related_articles\": related,\n                \"author_articles\": author_articles,\n                \"meta\": {\n                    \"total_views\": article.views,\n                    \"author_article_count\": await Article.objects.filter(\n                        author=article.author\n                    ).acount()\n                }\n            }\n\n\nArticleViewSet().add_views_to_route()\n</code></pre>"},{"location":"tutorial/crud/#complete-example","title":"Complete Example","text":"<p>Here's a complete ViewSet with all features:</p> Python<pre><code># views.py\nfrom ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom ninja.pagination import PageNumberPagination\nfrom ninja_aio.exceptions import SerializeError, NotFoundError\nfrom .models import Article, Author, Category, Tag\nfrom django.db.models import Q\n\napi = NinjaAIO(\n    title=\"Blog API\",\n    version=\"1.0.0\",\n    description=\"A complete blog API\"\n)\n\n\nclass CustomPagination(PageNumberPagination):\n    page_size = 20\n    max_page_size = 100\n\n\nclass AuthorViewSet(APIViewSet):\n    model = Author\n    api = api\n\n\nclass CategoryViewSet(APIViewSet):\n    model = Category\n    api = api\n\n\nclass TagViewSet(APIViewSet):\n    model = Tag\n    api = api\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    pagination_class = CustomPagination\n\n    query_params = {\n        \"is_published\": (bool, None),\n        \"author\": (int, None),\n        \"category\": (int, None),\n        \"tag\": (int, None),\n        \"search\": (str, None),\n        \"ordering\": (str, \"-created_at\"),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        # Published filter\n        if filters.get(\"is_published\") is not None:\n            queryset = queryset.filter(is_published=filters[\"is_published\"])\n\n        # Author filter\n        if filters.get(\"author\"):\n            queryset = queryset.filter(author_id=filters[\"author\"])\n\n        # Category filter\n        if filters.get(\"category\"):\n            queryset = queryset.filter(category_id=filters[\"category\"])\n\n        # Tag filter\n        if filters.get(\"tag\"):\n            queryset = queryset.filter(tags__id=filters[\"tag\"])\n\n        # Search\n        if filters.get(\"search\"):\n            search = filters[\"search\"]\n            queryset = queryset.filter(\n                Q(title__icontains=search) |\n                Q(content__icontains=search) |\n                Q(excerpt__icontains=search)\n            )\n\n        # Ordering\n        ordering = filters.get(\"ordering\", \"-created_at\")\n        valid_orderings = [\n            \"created_at\", \"-created_at\",\n            \"title\", \"-title\",\n            \"views\", \"-views\",\n            \"published_at\", \"-published_at\"\n        ]\n        if ordering in valid_orderings:\n            queryset = queryset.order_by(ordering)\n\n        return queryset\n\n    def views(self):\n        # Publish article\n        @self.router.post(\"/{pk}/publish/\")\n        async def publish(request, pk: int):\n            try:\n                article = await Article.objects.aget(pk=pk)\n            except Article.DoesNotExist:\n                raise NotFoundError(self.model)\n\n            if article.is_published:\n                raise SerializeError(\n                    {\"article\": \"already published\"},\n                    status_code=400\n                )\n\n            article.is_published = True\n            from django.utils import timezone\n            article.published_at = timezone.now()\n            await article.asave()\n\n            return {\"message\": \"Article published\", \"published_at\": article.published_at}\n\n        # Unpublish article\n        @self.router.post(\"/{pk}/unpublish/\")\n        async def unpublish(request, pk: int):\n            try:\n                article = await Article.objects.aget(pk=pk)\n            except Article.DoesNotExist:\n                raise NotFoundError(self.model)\n\n            article.is_published = False\n            article.published_at = None\n            await article.asave()\n\n            return {\"message\": \"Article unpublished\"}\n\n        # Increment views\n        @self.router.post(\"/{pk}/view/\")\n        async def view(request, pk: int):\n            try:\n                article = await Article.objects.aget(pk=pk)\n            except Article.DoesNotExist:\n                raise NotFoundError(self.model)\n\n            article.views += 1\n            await article.asave(update_fields=[\"views\"])\n\n            return {\"views\": article.views}\n\n        # Statistics\n        @self.router.get(\"/stats/\")\n        async def stats(request):\n            from django.db.models import Count, Avg, Sum\n            from asgiref.sync import sync_to_async\n\n            total = await Article.objects.acount()\n            published = await Article.objects.filter(is_published=True).acount()\n\n            avg_views = await sync_to_async(\n                lambda: Article.objects.aggregate(avg=Avg(\"views\"))\n            )()\n\n            total_views = await sync_to_async(\n                lambda: Article.objects.aggregate(total=Sum(\"views\"))\n            )()\n\n            return {\n                \"total_articles\": total,\n                \"published\": published,\n                \"drafts\": total - published,\n                \"avg_views\": avg_views[\"avg\"] or 0,\n                \"total_views\": total_views[\"total\"] or 0,\n            }\n\n        # Popular articles\n        @self.router.get(\"/popular/\")\n        async def popular(request, limit: int = 10):\n            articles = []\n            async for article in Article.objects.filter(\n                is_published=True\n            ).order_by(\"-views\")[:limit]:\n                articles.append(article)\n\n            from ninja_aio.models import ModelUtil\n            util = ModelUtil(Article)\n            schema = Article.generate_read_s()\n\n            results = []\n            for article in articles:\n                data = await util.read_s(request, article, schema)\n                results.append(data)\n\n            return results\n\n\n# Register ViewSets\nAuthorViewSet().add_views_to_route()\nCategoryViewSet().add_views_to_route()\nTagViewSet().add_views_to_route()\nArticleViewSet().add_views_to_route()\n</code></pre>"},{"location":"tutorial/crud/#testing-your-api","title":"Testing Your API","text":"<p>Test your endpoints using curl, httpie, or the Swagger UI:</p> Bash<pre><code># List articles\ncurl http://localhost:8000/api/article/\n\n# Create article\ncurl -X POST http://localhost:8000/api/article/ \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"title\": \"My Article\",\n    \"content\": \"Content here...\",\n    \"author\": 1,\n    \"category\": 2\n  }'\n\n# Get article\ncurl http://localhost:8000/api/article/1\n\n# Update article\ncurl -X PATCH http://localhost:8000/api/article/1/ \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"title\": \"Updated Title\"}'\n\n# Delete article\ncurl -X DELETE http://localhost:8000/api/article/1/\n\n# Custom endpoints\ncurl -X POST http://localhost:8000/api/article/1/publish/\ncurl http://localhost:8000/api/article/stats/\ncurl http://localhost:8000/api/article/popular/?limit=5\n</code></pre>"},{"location":"tutorial/crud/#next-steps","title":"Next Steps","text":"<p>Now that you have CRUD operations set up, let's add authentication in Step 3: Add Authentication.</p> <p>!!! success \"What You've Learned\" - \u2705 Creating ViewSets for CRUD operations - \u2705 Understanding auto-generated endpoints - \u2705 Adding query parameters and filtering - \u2705 Creating custom endpoints - \u2705 Working with pagination - \u2705 Handling errors properly - \u2705 Customizing responses</p>"},{"location":"tutorial/crud/#see-also","title":"See Also","text":"<ul> <li>APIViewSet API Reference - Complete API documentation</li> <li>Pagination - Advanced pagination options</li> <li>ModelUtil - Working with models</li> </ul>"},{"location":"tutorial/filtering/","title":"Step 4: Add Filtering &amp; Pagination","text":"<p>In this final step, you'll learn how to implement advanced filtering, searching, and pagination for your API endpoints.</p>"},{"location":"tutorial/filtering/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Query parameter filtering</li> <li>Full-text search</li> <li>Ordering and sorting</li> <li>Custom pagination</li> <li>Filter combinations</li> <li>Performance optimization</li> </ul>"},{"location":"tutorial/filtering/#prerequisites","title":"Prerequisites","text":"<p>Make sure you've completed:</p> <ul> <li>Step 1: Define Your Model</li> <li>Step 2: Create CRUD Views</li> <li>Step 3: Add Authentication</li> </ul>"},{"location":"tutorial/filtering/#basic-filtering","title":"Basic Filtering","text":""},{"location":"tutorial/filtering/#simple-field-filters","title":"Simple Field Filters","text":"Python<pre><code># views.py\nfrom ninja_aio.views import APIViewSet\nfrom .models import Article\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"is_published\": (bool, None),\n        \"author\": (int, None),\n        \"category\": (int, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        # Filter by published status\n        if filters.get(\"is_published\") is not None:\n            queryset = queryset.filter(is_published=filters[\"is_published\"])\n\n        # Filter by author ID\n        if filters.get(\"author\"):\n            queryset = queryset.filter(author_id=filters[\"author\"])\n\n        # Filter by category ID\n        if filters.get(\"category\"):\n            queryset = queryset.filter(category_id=filters[\"category\"])\n\n        return queryset\n\n\nArticleViewSet().add_views_to_route()\n</code></pre> <p>Usage:</p> Bash<pre><code># Get published articles\nGET /api/article/?is_published=true\n\n# Get articles by author\nGET /api/article/?author=5\n\n# Get articles in category\nGET /api/article/?category=3\n\n# Combine filters\nGET /api/article/?is_published=true&amp;author=5&amp;category=3\n</code></pre>"},{"location":"tutorial/filtering/#date-range-filters","title":"Date Range Filters","text":"Python<pre><code>from datetime import datetime\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"created_after\": (str, None),   # ISO date string\n        \"created_before\": (str, None),\n        \"published_after\": (str, None),\n        \"published_before\": (str, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        # Filter by creation date\n        if filters.get(\"created_after\"):\n            date = datetime.fromisoformat(filters[\"created_after\"])\n            queryset = queryset.filter(created_at__gte=date)\n\n        if filters.get(\"created_before\"):\n            date = datetime.fromisoformat(filters[\"created_before\"])\n            queryset = queryset.filter(created_at__lte=date)\n\n        # Filter by publication date\n        if filters.get(\"published_after\"):\n            date = datetime.fromisoformat(filters[\"published_after\"])\n            queryset = queryset.filter(published_at__gte=date)\n\n        if filters.get(\"published_before\"):\n            date = datetime.fromisoformat(filters[\"published_before\"])\n            queryset = queryset.filter(published_at__lte=date)\n\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># Articles created after a date\nGET /api/article/?created_after=2024-01-01\n\n# Articles published in a date range\nGET /api/article/?published_after=2024-01-01&amp;published_before=2024-01-31\n\n# Articles from last 7 days\nGET /api/article/?created_after=2024-01-15\n</code></pre>"},{"location":"tutorial/filtering/#numeric-range-filters","title":"Numeric Range Filters","text":"Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"min_views\": (int, None),\n        \"max_views\": (int, None),\n        \"min_rating\": (float, None),\n        \"max_rating\": (float, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        # Filter by views\n        if filters.get(\"min_views\"):\n            queryset = queryset.filter(views__gte=filters[\"min_views\"])\n\n        if filters.get(\"max_views\"):\n            queryset = queryset.filter(views__lte=filters[\"max_views\"])\n\n        # Filter by rating\n        if filters.get(\"min_rating\"):\n            queryset = queryset.filter(rating__gte=filters[\"min_rating\"])\n\n        if filters.get(\"max_rating\"):\n            queryset = queryset.filter(rating__lte=filters[\"max_rating\"])\n\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># Popular articles (1000+ views)\nGET /api/article/?min_views=1000\n\n# Highly rated articles (4.5+)\nGET /api/article/?min_rating=4.5\n\n# Articles with 100-1000 views\nGET /api/article/?min_views=100&amp;max_views=1000\n</code></pre>"},{"location":"tutorial/filtering/#search-functionality","title":"Search Functionality","text":""},{"location":"tutorial/filtering/#simple-text-search","title":"Simple Text Search","text":"Python<pre><code>from django.db.models import Q\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"search\": (str, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        if filters.get(\"search\"):\n            search_term = filters[\"search\"]\n            queryset = queryset.filter(\n                Q(title__icontains=search_term) |\n                Q(content__icontains=search_term) |\n                Q(excerpt__icontains=search_term)\n            )\n\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># Search in title and content\nGET /api/article/?search=django\n\n# Search with other filters\nGET /api/article/?search=tutorial&amp;is_published=true\n</code></pre>"},{"location":"tutorial/filtering/#full-text-search-postgresql","title":"Full-Text Search (PostgreSQL)","text":"<p>For better performance with large datasets:</p> Python<pre><code>from django.contrib.postgres.search import SearchVector, SearchQuery, SearchRank\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"search\": (str, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        if filters.get(\"search\"):\n            search_term = filters[\"search\"]\n\n            # Create search vector\n            vector = SearchVector('title', weight='A') + \\\n                     SearchVector('content', weight='B')\n\n            query = SearchQuery(search_term)\n\n            # Filter and rank by relevance\n            queryset = queryset.annotate(\n                rank=SearchRank(vector, query)\n            ).filter(\n                rank__gte=0.1\n            ).order_by('-rank')\n\n        return queryset\n</code></pre>"},{"location":"tutorial/filtering/#search-with-highlights","title":"Search with Highlights","text":"Python<pre><code>from django.contrib.postgres.search import SearchVector, SearchQuery, SearchHeadline\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"search\": (str, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        if filters.get(\"search\"):\n            search_term = filters[\"search\"]\n            query = SearchQuery(search_term)\n\n            # Add highlighted excerpts\n            queryset = queryset.annotate(\n                headline=SearchHeadline(\n                    'content',\n                    query,\n                    start_sel='&lt;mark&gt;',\n                    stop_sel='&lt;/mark&gt;',\n                    max_words=50,\n                )\n            )\n\n        return queryset\n</code></pre>"},{"location":"tutorial/filtering/#ordering","title":"Ordering","text":""},{"location":"tutorial/filtering/#basic-ordering","title":"Basic Ordering","text":"Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"ordering\": (str, \"-created_at\"),  # Default: newest first\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        ordering = filters.get(\"ordering\", \"-created_at\")\n\n        # Whitelist allowed ordering fields\n        valid_orderings = [\n            \"created_at\", \"-created_at\",\n            \"updated_at\", \"-updated_at\",\n            \"title\", \"-title\",\n            \"views\", \"-views\",\n            \"rating\", \"-rating\",\n            \"published_at\", \"-published_at\",\n        ]\n\n        if ordering in valid_orderings:\n            queryset = queryset.order_by(ordering)\n\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># Newest first (default)\nGET /api/article/?ordering=-created_at\n\n# Oldest first\nGET /api/article/?ordering=created_at\n\n# By title A-Z\nGET /api/article/?ordering=title\n\n# Most viewed\nGET /api/article/?ordering=-views\n\n# Highest rated\nGET /api/article/?ordering=-rating\n</code></pre>"},{"location":"tutorial/filtering/#multiple-field-ordering","title":"Multiple Field Ordering","text":"Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"ordering\": (str, \"-created_at,title\"),  # Multiple fields\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        ordering = filters.get(\"ordering\", \"-created_at,title\")\n\n        # Parse ordering string\n        order_fields = ordering.split(',')\n\n        # Validate each field\n        valid_fields = {\n            \"created_at\", \"-created_at\",\n            \"title\", \"-title\",\n            \"views\", \"-views\",\n        }\n\n        validated_fields = [\n            field for field in order_fields\n            if field in valid_fields\n        ]\n\n        if validated_fields:\n            queryset = queryset.order_by(*validated_fields)\n\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># Order by date, then title\nGET /api/article/?ordering=-created_at,title\n\n# Order by views, then rating\nGET /api/article/?ordering=-views,-rating\n</code></pre>"},{"location":"tutorial/filtering/#advanced-filtering","title":"Advanced Filtering","text":""},{"location":"tutorial/filtering/#related-field-filters","title":"Related Field Filters","text":"Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"author_username\": (str, None),\n        \"category_slug\": (str, None),\n        \"tag_name\": (str, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        # Filter by author username\n        if filters.get(\"author_username\"):\n            queryset = queryset.filter(\n                author__username__iexact=filters[\"author_username\"]\n            )\n\n        # Filter by category slug\n        if filters.get(\"category_slug\"):\n            queryset = queryset.filter(\n                category__slug=filters[\"category_slug\"]\n            )\n\n        # Filter by tag name\n        if filters.get(\"tag_name\"):\n            queryset = queryset.filter(\n                tags__name__iexact=filters[\"tag_name\"]\n            )\n\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># By author username\nGET /api/article/?author_username=johndoe\n\n# By category slug\nGET /api/article/?category_slug=tutorials\n\n# By tag name\nGET /api/article/?tag_name=python\n</code></pre>"},{"location":"tutorial/filtering/#multiple-tags-filter","title":"Multiple Tags Filter","text":"Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"tags\": (str, None),  # Comma-separated tag IDs or names\n        \"tags_mode\": (str, \"any\"),  # \"any\" or \"all\"\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        if filters.get(\"tags\"):\n            tag_list = filters[\"tags\"].split(',')\n            mode = filters.get(\"tags_mode\", \"any\")\n\n            # Check if tags are IDs or names\n            if tag_list[0].isdigit():\n                # Filter by tag IDs\n                tag_ids = [int(t) for t in tag_list]\n\n                if mode == \"all\":\n                    # Must have ALL tags\n                    for tag_id in tag_ids:\n                        queryset = queryset.filter(tags__id=tag_id)\n                else:\n                    # Must have ANY tag\n                    queryset = queryset.filter(tags__id__in=tag_ids).distinct()\n            else:\n                # Filter by tag names\n                if mode == \"all\":\n                    for tag_name in tag_list:\n                        queryset = queryset.filter(tags__name__iexact=tag_name)\n                else:\n                    queryset = queryset.filter(\n                        tags__name__in=tag_list\n                    ).distinct()\n\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># Articles with ANY of these tags\nGET /api/article/?tags=1,2,3\n\n# Articles with ALL of these tags\nGET /api/article/?tags=python,django,tutorial&amp;tags_mode=all\n\n# Using tag IDs\nGET /api/article/?tags=1,2,3&amp;tags_mode=all\n</code></pre>"},{"location":"tutorial/filtering/#exclude-filters","title":"Exclude Filters","text":"Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"exclude_author\": (int, None),\n        \"exclude_category\": (int, None),\n        \"exclude_ids\": (str, None),  # Comma-separated IDs\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        # Exclude specific author\n        if filters.get(\"exclude_author\"):\n            queryset = queryset.exclude(author_id=filters[\"exclude_author\"])\n\n        # Exclude specific category\n        if filters.get(\"exclude_category\"):\n            queryset = queryset.exclude(category_id=filters[\"exclude_category\"])\n\n        # Exclude specific article IDs\n        if filters.get(\"exclude_ids\"):\n            ids = [int(id) for id in filters[\"exclude_ids\"].split(',')]\n            queryset = queryset.exclude(id__in=ids)\n\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># Exclude articles by specific author\nGET /api/article/?exclude_author=5\n\n# Exclude specific articles\nGET /api/article/?exclude_ids=1,2,3\n</code></pre>"},{"location":"tutorial/filtering/#pagination","title":"Pagination","text":""},{"location":"tutorial/filtering/#default-pagination","title":"Default Pagination","text":"<p>Django Ninja Aio CRUD uses page-number pagination by default:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    # Uses default PageNumberPagination\n</code></pre> <p>Usage:</p> Bash<pre><code># First page (10 items)\nGET /api/article/?page=1\n\n# Custom page size\nGET /api/article/?page=1&amp;page_size=20\n\n# Second page\nGET /api/article/?page=2&amp;page_size=20\n</code></pre> <p>Response:</p> JSON<pre><code>{\n  \"count\": 150,\n  \"next\": 3,\n  \"previous\": 1,\n  \"results\": [...]\n}\n</code></pre>"},{"location":"tutorial/filtering/#custom-pagination","title":"Custom Pagination","text":"Python<pre><code>from ninja.pagination import PageNumberPagination\n\n\nclass CustomPagination(PageNumberPagination):\n    page_size = 25  # Default items per page\n    max_page_size = 100  # Maximum allowed\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    pagination_class = CustomPagination\n</code></pre>"},{"location":"tutorial/filtering/#disable-pagination","title":"Disable Pagination","text":"Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    pagination_class = None  # Return all results\n\n\n# Or conditionally\nclass ConditionalPagination(PageNumberPagination):\n    async def apaginate_queryset(self, queryset, pagination, request=None, **params):\n        # Disable if 'all' parameter present\n        if params.get('all'):\n            items = []\n            async for item in queryset:\n                items.append(item)\n            return {\"results\": items}\n\n        return await super().apaginate_queryset(queryset, pagination, request, **params)\n</code></pre>"},{"location":"tutorial/filtering/#filter-presets","title":"Filter Presets","text":"<p>Create reusable filter combinations:</p> Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    query_params = {\n        \"preset\": (str, None),\n        # ... other filters\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        preset = filters.get(\"preset\")\n\n        # Apply preset filters\n        if preset == \"trending\":\n            # Popular recent articles\n            from django.utils import timezone\n            from datetime import timedelta\n\n            last_week = timezone.now() - timedelta(days=7)\n            queryset = queryset.filter(\n                created_at__gte=last_week,\n                is_published=True\n            ).order_by('-views', '-rating')\n\n        elif preset == \"featured\":\n            # Featured articles\n            queryset = queryset.filter(\n                is_published=True,\n                is_featured=True\n            ).order_by('-featured_at')\n\n        elif preset == \"recent\":\n            # Recently published\n            queryset = queryset.filter(\n                is_published=True\n            ).order_by('-published_at')[:20]\n\n        elif preset == \"popular\":\n            # All-time most viewed\n            queryset = queryset.filter(\n                is_published=True\n            ).order_by('-views')[:50]\n\n        # Apply other filters\n        # ...\n\n        return queryset\n</code></pre> <p>Usage:</p> Bash<pre><code># Get trending articles\nGET /api/article/?preset=trending\n\n# Get featured articles\nGET /api/article/?preset=featured\n\n# Combine with other filters\nGET /api/article/?preset=recent&amp;category=1\n</code></pre>"},{"location":"tutorial/filtering/#performance-optimization","title":"Performance Optimization","text":""},{"location":"tutorial/filtering/#select-related","title":"Select Related","text":"<p>Optimize queries with foreign keys:</p> Python<pre><code>class Article(ModelSerializer):\n    # ... fields ...\n\n    @classmethod\n    async def queryset_request(cls, request):\n        # Always include related objects\n        return cls.objects.select_related(\n            'author',\n            'category'\n        ).prefetch_related(\n            'tags',\n            'comments'\n        )\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    # Queries are now optimized automatically\n</code></pre>"},{"location":"tutorial/filtering/#index-database-fields","title":"Index Database Fields","text":"Python<pre><code># models.py\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200, db_index=True)\n    slug = models.SlugField(unique=True, db_index=True)\n    is_published = models.BooleanField(default=False, db_index=True)\n    created_at = models.DateTimeField(auto_now_add=True, db_index=True)\n\n    class Meta:\n        indexes = [\n            models.Index(fields=['-created_at']),\n            models.Index(fields=['is_published', '-created_at']),\n            models.Index(fields=['author', '-created_at']),\n            models.Index(fields=['category', '-created_at']),\n        ]\n</code></pre>"},{"location":"tutorial/filtering/#limit-query-results","title":"Limit Query Results","text":"Python<pre><code>class ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n\n    async def query_params_handler(self, queryset, filters):\n        # Apply filters\n        # ...\n\n        # Limit results for expensive queries\n        if filters.get(\"search\"):\n            queryset = queryset[:1000]  # Max 1000 results for search\n\n        return queryset\n</code></pre>"},{"location":"tutorial/filtering/#complete-example","title":"Complete Example","text":"<p>Here's a comprehensive filtering implementation:</p> Python<pre><code># views.py\nfrom ninja_aio import NinjaAIO\nfrom ninja_aio.views import APIViewSet\nfrom ninja.pagination import PageNumberPagination\nfrom django.db.models import Q\nfrom datetime import datetime\nfrom .models import Article\n\napi = NinjaAIO(title=\"Blog API\", version=\"1.0.0\")\n\n\nclass ArticlePagination(PageNumberPagination):\n    page_size = 20\n    max_page_size = 100\n\n\nclass ArticleViewSet(APIViewSet):\n    model = Article\n    api = api\n    pagination_class = ArticlePagination\n\n    query_params = {\n        # Basic filters\n        \"is_published\": (bool, None),\n        \"author\": (int, None),\n        \"category\": (int, None),\n\n        # Text search\n        \"search\": (str, None),\n\n        # Date range\n        \"created_after\": (str, None),\n        \"created_before\": (str, None),\n\n        # Numeric range\n        \"min_views\": (int, None),\n        \"max_views\": (int, None),\n\n        # Related filters\n        \"author_username\": (str, None),\n        \"category_slug\": (str, None),\n        \"tags\": (str, None),\n        \"tags_mode\": (str, \"any\"),\n\n        # Ordering\n        \"ordering\": (str, \"-created_at\"),\n\n        # Presets\n        \"preset\": (str, None),\n    }\n\n    async def query_params_handler(self, queryset, filters):\n        # Apply preset first\n        preset = filters.get(\"preset\")\n        if preset == \"trending\":\n            from django.utils import timezone\n            from datetime import timedelta\n            last_week = timezone.now() - timedelta(days=7)\n            queryset = queryset.filter(\n                created_at__gte=last_week,\n                is_published=True\n            )\n        elif preset == \"popular\":\n            queryset = queryset.filter(is_published=True)\n\n        # Published status\n        if filters.get(\"is_published\") is not None:\n            queryset = queryset.filter(is_published=filters[\"is_published\"])\n\n        # Author filter\n        if filters.get(\"author\"):\n            queryset = queryset.filter(author_id=filters[\"author\"])\n        elif filters.get(\"author_username\"):\n            queryset = queryset.filter(\n                author__username__iexact=filters[\"author_username\"]\n            )\n\n        # Category filter\n        if filters.get(\"category\"):\n            queryset = queryset.filter(category_id=filters[\"category\"])\n        elif filters.get(\"category_slug\"):\n            queryset = queryset.filter(category__slug=filters[\"category_slug\"])\n\n        # Tags filter\n        if filters.get(\"tags\"):\n            tag_list = filters[\"tags\"].split(',')\n            mode = filters.get(\"tags_mode\", \"any\")\n\n            if mode == \"all\":\n                for tag in tag_list:\n                    if tag.isdigit():\n                        queryset = queryset.filter(tags__id=int(tag))\n                    else:\n                        queryset = queryset.filter(tags__name__iexact=tag)\n            else:\n                if tag_list[0].isdigit():\n                    tag_ids = [int(t) for t in tag_list]\n                    queryset = queryset.filter(tags__id__in=tag_ids).distinct()\n                else:\n                    queryset = queryset.filter(tags__name__in=tag_list).distinct()\n\n        # Search\n        if filters.get(\"search\"):\n            search_term = filters[\"search\"]\n            queryset = queryset.filter(\n                Q(title__icontains=search_term) |\n                Q(content__icontains=search_term)\n            )\n\n        # Date range\n        if filters.get(\"created_after\"):\n            date = datetime.fromisoformat(filters[\"created_after\"])\n            queryset = queryset.filter(created_at__gte=date)\n\n        if filters.get(\"created_before\"):\n            date = datetime.fromisoformat(filters[\"created_before\"])\n            queryset = queryset.filter(created_at__lte=date)\n\n        # Views range\n        if filters.get(\"min_views\"):\n            queryset = queryset.filter(views__gte=filters[\"min_views\"])\n\n        if filters.get(\"max_views\"):\n            queryset = queryset.filter(views__lte=filters[\"max_views\"])\n\n        # Ordering\n        ordering = filters.get(\"ordering\", \"-created_at\")\n        valid_orderings = [\n            \"created_at\", \"-created_at\",\n            \"title\", \"-title\",\n            \"views\", \"-views\",\n            \"published_at\", \"-published_at\",\n        ]\n\n        if ordering in valid_orderings:\n            queryset = queryset.order_by(ordering)\n        elif preset == \"trending\":\n            queryset = queryset.order_by('-views', '-rating')\n        elif preset == \"popular\":\n            queryset = queryset.order_by('-views')\n\n        return queryset\n\n\nArticleViewSet().add_views_to_route()\n</code></pre>"},{"location":"tutorial/filtering/#testing-filters","title":"Testing Filters","text":"Bash<pre><code># Basic filtering\ncurl \"http://localhost:8000/api/article/?is_published=true\"\n\n# Search\ncurl \"http://localhost:8000/api/article/?search=django\"\n\n# Date range\ncurl \"http://localhost:8000/api/article/?created_after=2024-01-01&amp;created_before=2024-01-31\"\n\n# Multiple filters\ncurl \"http://localhost:8000/api/article/?is_published=true&amp;category=1&amp;min_views=100&amp;ordering=-views\"\n\n# Tags\ncurl \"http://localhost:8000/api/article/?tags=python,django&amp;tags_mode=all\"\n\n# Presets\ncurl \"http://localhost:8000/api/article/?preset=trending\"\n\n# Pagination\ncurl \"http://localhost:8000/api/article/?page=2&amp;page_size=50\"\n\n# Combined\ncurl \"http://localhost:8000/api/article/?search=tutorial&amp;category=1&amp;is_published=true&amp;min_views=1000&amp;ordering=-rating&amp;page=1&amp;page_size=20\"\n</code></pre>"},{"location":"tutorial/filtering/#congratulations","title":"Congratulations! \ud83c\udf89","text":"<p>You've completed all tutorial steps and built a complete, production-ready API with:</p> <ul> <li>\u2705 Models with automatic schema generation</li> <li>\u2705 Full CRUD operations</li> <li>\u2705 JWT authentication</li> <li>\u2705 Custom schemas and validation</li> <li>\u2705 Advanced filtering and search</li> <li>\u2705 Pagination</li> <li>\u2705 Performance optimization</li> </ul>"},{"location":"tutorial/filtering/#next-steps","title":"Next Steps","text":"<p>Explore advanced topics:</p> <ul> <li>API Reference - Complete API documentation</li> <li>Authentication - Advanced auth patterns</li> <li>Pagination - Custom pagination strategies</li> </ul>"},{"location":"tutorial/filtering/#see-also","title":"See Also","text":"<ul> <li>Pagination API Reference - Pagination classes</li> <li>ModelUtil - Query optimization</li> </ul>"},{"location":"tutorial/model/","title":"Step 1: Define Your Model","text":"<p>In this first step, you'll learn how to define Django models using <code>ModelSerializer</code>, which allows you to declare schemas directly on your models.</p>"},{"location":"tutorial/model/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>How to create a model with <code>ModelSerializer</code></li> <li>Defining serialization schemas (Create, Read, Update)</li> <li>Working with relationships</li> <li>Adding custom fields</li> <li>Implementing lifecycle hooks</li> </ul>"},{"location":"tutorial/model/#prerequisites","title":"Prerequisites","text":"<p>Make sure you have:</p> <ul> <li>Django 4.1+ installed</li> <li><code>django-ninja-aio-crud</code> installed</li> <li>A Django project set up</li> </ul>"},{"location":"tutorial/model/#basic-model-definition","title":"Basic Model Definition","text":"<p>Let's create a simple blog article model:</p> Python<pre><code># models.py\nfrom django.db import models\nfrom ninja_aio.models import ModelSerializer\n\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    is_published = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    def __str__(self):\n        return self.title\n</code></pre> <p>Why ModelSerializer?</p> <p><code>ModelSerializer</code> is a powerful mixin that combines Django's <code>Model</code> with automatic schema generation capabilities. Instead of creating separate serializer classes, you define everything on the model itself.</p>"},{"location":"tutorial/model/#adding-serializer-classes","title":"Adding Serializer Classes","text":"<p>Now let's add serialization schemas to control which fields are exposed in different operations:</p>"},{"location":"tutorial/model/#readserializer","title":"ReadSerializer","text":"<p>Defines which fields appear in API responses:</p> Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    is_published = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"content\", \"is_published\", \"created_at\", \"updated_at\"]\n\n    def __str__(self):\n        return self.title\n</code></pre> <p>Result: When you retrieve an article, the API will return:</p> JSON<pre><code>{\n  \"id\": 1,\n  \"title\": \"Getting Started with Django\",\n  \"content\": \"In this article...\",\n  \"is_published\": true,\n  \"created_at\": \"2024-01-15T10:30:00Z\",\n  \"updated_at\": \"2024-01-15T11:00:00Z\"\n}\n</code></pre>"},{"location":"tutorial/model/#createserializer","title":"CreateSerializer","text":"<p>Defines which fields are required/allowed when creating:</p> Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    is_published = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"content\", \"is_published\", \"created_at\", \"updated_at\"]\n\n    class CreateSerializer:\n        fields = [\"title\", \"content\"]\n        optionals = [\n            (\"is_published\", bool),\n        ]\n\n    def __str__(self):\n        return self.title\n</code></pre> <p>Usage: When creating an article:</p> JSON<pre><code>// Required fields\n{\n  \"title\": \"My New Article\",\n  \"content\": \"Article content here...\"\n}\n\n// With optional field\n{\n  \"title\": \"My New Article\",\n  \"content\": \"Article content here...\",\n  \"is_published\": true\n}\n</code></pre> <p>Auto-generated Fields</p> <p>Fields like <code>id</code>, <code>created_at</code>, and <code>updated_at</code> are automatically handled by Django and shouldn't be in <code>CreateSerializer.fields</code>.</p>"},{"location":"tutorial/model/#updateserializer","title":"UpdateSerializer","text":"<p>Defines which fields can be updated (usually all optional for PATCH):</p> Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    is_published = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"content\", \"is_published\", \"created_at\", \"updated_at\"]\n\n    class CreateSerializer:\n        fields = [\"title\", \"content\"]\n        optionals = [(\"is_published\", bool)]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"title\", str),\n            (\"content\", str),\n            (\"is_published\", bool),\n        ]\n        excludes = [\"created_at\", \"updated_at\"]\n\n    def __str__(self):\n        return self.title\n</code></pre> <p>Usage: Partial update (PATCH):</p> JSON<pre><code>// Update only title\n{\n  \"title\": \"Updated Title\"\n}\n\n// Update multiple fields\n{\n  \"title\": \"Updated Title\",\n  \"is_published\": true\n}\n</code></pre>"},{"location":"tutorial/model/#working-with-relationships","title":"Working with Relationships","text":""},{"location":"tutorial/model/#foreignkey-relationships","title":"ForeignKey Relationships","text":"<p>Let's add an author to our articles:</p> Python<pre><code>class Author(ModelSerializer):\n    name = models.CharField(max_length=200)\n    email = models.EmailField(unique=True)\n    bio = models.TextField(blank=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"email\", \"bio\"]\n\n    class CreateSerializer:\n        fields = [\"name\", \"email\"]\n        optionals = [(\"bio\", str)]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"name\", str),\n            (\"email\", str),\n            (\"bio\", str),\n        ]\n\n    def __str__(self):\n        return self.name\n\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"articles\")\n    is_published = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"content\", \"author\", \"is_published\", \"created_at\"]\n\n    class CreateSerializer:\n        fields = [\"title\", \"content\", \"author\"]\n        optionals = [(\"is_published\", bool)]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"title\", str),\n            (\"content\", str),\n            (\"is_published\", bool),\n        ]\n        excludes = [\"author\"]  # Can't change author after creation\n\n    def __str__(self):\n        return self.title\n</code></pre> <p>Creating an article with author:</p> JSON<pre><code>{\n  \"title\": \"My Article\",\n  \"content\": \"Content here...\",\n  \"author\": 5 // Author ID\n}\n</code></pre> <p>Response includes nested author data:</p> JSON<pre><code>{\n  \"id\": 1,\n  \"title\": \"My Article\",\n  \"content\": \"Content here...\",\n  \"author\": {\n    \"id\": 5,\n    \"name\": \"John Doe\",\n    \"email\": \"john@example.com\",\n    \"bio\": \"Software developer\"\n  },\n  \"is_published\": false,\n  \"created_at\": \"2024-01-15T10:30:00Z\"\n}\n</code></pre> <p>Automatic Nested Serialization</p> <p>When <code>Author</code> is also a <code>ModelSerializer</code>, Django Ninja Aio CRUD automatically serializes it in the response!</p>"},{"location":"tutorial/model/#manytomany-relationships","title":"ManyToMany Relationships","text":"<p>Let's add tags to articles:</p> Python<pre><code>class Tag(ModelSerializer):\n    name = models.CharField(max_length=50, unique=True)\n    slug = models.SlugField(unique=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"slug\"]\n\n    class CreateSerializer:\n        fields = [\"name\", \"slug\"]\n\n    def __str__(self):\n        return self.name\n\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"articles\")\n    tags = models.ManyToManyField(Tag, related_name=\"articles\", blank=True)\n    is_published = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"content\", \"author\", \"tags\", \"is_published\", \"created_at\"]\n\n    class CreateSerializer:\n        fields = [\"title\", \"content\", \"author\"]\n        optionals = [\n            (\"is_published\", bool),\n            (\"tags\", list[int]),  # List of tag IDs\n        ]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"title\", str),\n            (\"content\", str),\n            (\"is_published\", bool),\n            (\"tags\", list[int]),\n        ]\n\n    def __str__(self):\n        return self.title\n</code></pre> <p>Creating with tags:</p> JSON<pre><code>{\n  \"title\": \"My Article\",\n  \"content\": \"Content...\",\n  \"author\": 5,\n  \"tags\": [1, 2, 3] // Tag IDs\n}\n</code></pre> <p>Response:</p> JSON<pre><code>{\n  \"id\": 1,\n  \"title\": \"My Article\",\n  \"content\": \"Content...\",\n  \"author\": {...},\n  \"tags\": [\n    {\"id\": 1, \"name\": \"python\", \"slug\": \"python\"},\n    {\"id\": 2, \"name\": \"django\", \"slug\": \"django\"},\n    {\"id\": 3, \"name\": \"tutorial\", \"slug\": \"tutorial\"}\n  ],\n  \"is_published\": false,\n  \"created_at\": \"2024-01-15T10:30:00Z\"\n}\n</code></pre>"},{"location":"tutorial/model/#adding-custom-fields","title":"Adding Custom Fields","text":"<p>Sometimes you need computed or synthetic fields in your API responses:</p> Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"articles\")\n    views = models.IntegerField(default=0)\n    is_published = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"content\", \"author\", \"views\", \"is_published\", \"created_at\"]\n        customs = [\n            (\"word_count\", int, lambda obj: len(obj.content.split())),\n            (\"reading_time\", int, lambda obj: len(obj.content.split()) // 200),  # Assume 200 words/min\n            (\"author_name\", str, lambda obj: obj.author.name),\n        ]\n\n    class CreateSerializer:\n        fields = [\"title\", \"content\", \"author\"]\n        customs = [\n            (\"notify_subscribers\", bool, True),  # Custom action flag\n            (\"schedule_publish\", str, None),  # ISO datetime string\n        ]\n\n    def __str__(self):\n        return self.title\n</code></pre> <p>Response with custom fields:</p> JSON<pre><code>{\n  \"id\": 1,\n  \"title\": \"My Article\",\n  \"content\": \"...\",\n  \"author\": {...},\n  \"views\": 150,\n  \"is_published\": true,\n  \"created_at\": \"2024-01-15T10:30:00Z\",\n  \"word_count\": 842,\n  \"reading_time\": 4,\n  \"author_name\": \"John Doe\"\n}\n</code></pre> <p>Custom Fields in CreateSerializer</p> <p>Custom fields in <code>CreateSerializer</code> are used for instructions (like flags or metadata), not stored in the database. They're passed to <code>custom_actions()</code> hook.</p>"},{"location":"tutorial/model/#query-optimizations-queryset","title":"Query optimizations (QuerySet)","text":"<p>Configure select_related/prefetch_related for read and queryset_request hooks:</p> Python<pre><code>from ninja_aio.schemas.helpers import ModelQuerySetSchema, ModelQuerySetExtraSchema\n\nclass Article(ModelSerializer):\n    # ...existing fields...\n\n    class QuerySet:\n        read = ModelQuerySetSchema(\n            select_related=[\"author\", \"category\"],\n            prefetch_related=[\"tags\"],\n        )\n        queryset_request = ModelQuerySetSchema(\n            select_related=[],\n            prefetch_related=[\"tags\"],\n        )\n        extras = [\n            ModelQuerySetExtraSchema(\n                scope=\"cards\",\n                select_related=[\"author\"],\n                prefetch_related=[],\n            )\n        ]\n</code></pre> <p>Use the QueryUtil for custom scopes:</p> Python<pre><code>qs = Article.query_util.apply_queryset_optimizations(\n    Article.objects.all(),\n    Article.query_util.SCOPES.cards,  # from extras\n)\n</code></pre>"},{"location":"tutorial/model/#fetch-and-serialize-with-modelutil","title":"Fetch and serialize with ModelUtil","text":"Python<pre><code>from ninja_aio.models import ModelUtil\nfrom ninja_aio.schemas.helpers import ObjectsQuerySchema, ObjectQuerySchema\n\nutil = ModelUtil(Article)\n\n# List published with default read optimizations\nitems = await util.list_read_s(\n    Article.generate_read_s(),\n    request,\n    query_data=ObjectsQuerySchema(filters={\"is_published\": True}),\n    is_for_read=True,\n)\n\n# Retrieve by slug with getters\nitem = await util.read_s(\n    Article.generate_read_s(),\n    request,\n    query_data=ObjectQuerySchema(getters={\"slug\": \"my-article\"}),\n    is_for_read=True,\n)\n</code></pre>"},{"location":"tutorial/model/#lifecycle-hooks","title":"Lifecycle Hooks","text":"<p>Add behavior at key points in the model lifecycle:</p>"},{"location":"tutorial/model/#sync-hooks","title":"Sync Hooks","text":"Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    slug = models.SlugField(unique=True, blank=True)\n    is_published = models.BooleanField(default=False)\n    published_at = models.DateTimeField(null=True, blank=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"title\", \"slug\", \"is_published\", \"published_at\"]\n\n    def before_save(self):\n        \"\"\"Called before every save (create and update)\"\"\"\n        if not self.slug:\n            from django.utils.text import slugify\n            self.slug = slugify(self.title)\n\n    def on_create_before_save(self):\n        \"\"\"Called only on creation, before save\"\"\"\n        print(f\"Creating new article: {self.title}\")\n\n    def after_save(self):\n        \"\"\"Called after every save\"\"\"\n        from django.core.cache import cache\n        cache.delete(f\"article:{self.id}\")\n\n    def on_create_after_save(self):\n        \"\"\"Called only after creation\"\"\"\n        print(f\"Article created with ID: {self.id}\")\n\n    def on_delete(self):\n        \"\"\"Called after deletion\"\"\"\n        print(f\"Article deleted: {self.title}\")\n</code></pre>"},{"location":"tutorial/model/#async-hooks","title":"Async Hooks","text":"Python<pre><code>class Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    author = models.ForeignKey(Author, on_delete=models.CASCADE)\n    is_published = models.BooleanField(default=False)\n\n    class CreateSerializer:\n        fields = [\"title\", \"content\", \"author\"]\n        customs = [\n            (\"notify_subscribers\", bool, True),\n            (\"schedule_publish\", str, None),\n        ]\n\n    async def post_create(self):\n        \"\"\"Called after object creation (async)\"\"\"\n        # Send notification email\n        from myapp.tasks import send_new_article_notification\n        await send_new_article_notification(self.id)\n\n        # Create activity log\n        from myapp.models import ActivityLog\n        await ActivityLog.objects.acreate(\n            action=\"article_created\",\n            article_id=self.id,\n            user_id=self.author_id\n        )\n\n    async def custom_actions(self, payload: dict):\n        \"\"\"Process custom fields from CreateSerializer\"\"\"\n        if payload.get(\"notify_subscribers\"):\n            from myapp.tasks import notify_subscribers\n            await notify_subscribers(self.id)\n\n        if payload.get(\"schedule_publish\"):\n            from datetime import datetime\n            schedule_time = datetime.fromisoformat(payload[\"schedule_publish\"])\n            from myapp.tasks import schedule_publish_task\n            await schedule_publish_task(self.id, schedule_time)\n</code></pre> <p>Execution Order</p> <p>Create: <code>on_create_before_save()</code> \u2192 <code>before_save()</code> \u2192 <code>save()</code> \u2192 <code>on_create_after_save()</code> \u2192 <code>after_save()</code> \u2192 <code>custom_actions()</code> \u2192 <code>post_create()</code></p> Text Only<pre><code>**Update**: `before_save()` \u2192 `save()` \u2192 `after_save()` \u2192 `custom_actions()`\n</code></pre>"},{"location":"tutorial/model/#complete-example","title":"Complete Example","text":"<p>Here's a complete blog model with all features:</p> Python<pre><code># models.py\nfrom django.db import models\nfrom django.utils.text import slugify\nfrom ninja_aio.models import ModelSerializer\n\n\nclass Author(ModelSerializer):\n    name = models.CharField(max_length=200)\n    email = models.EmailField(unique=True)\n    bio = models.TextField(blank=True)\n    avatar = models.URLField(blank=True)\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"email\", \"bio\", \"avatar\", \"created_at\"]\n        customs = [\n            (\"article_count\", int, lambda obj: obj.articles.count()),\n        ]\n\n    class CreateSerializer:\n        fields = [\"name\", \"email\"]\n        optionals = [(\"bio\", str), (\"avatar\", str)]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"name\", str),\n            (\"bio\", str),\n            (\"avatar\", str),\n        ]\n        excludes = [\"email\", \"created_at\"]\n\n    def __str__(self):\n        return self.name\n\n\nclass Category(ModelSerializer):\n    name = models.CharField(max_length=100)\n    slug = models.SlugField(unique=True, blank=True)\n    description = models.TextField(blank=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"slug\", \"description\"]\n\n    class CreateSerializer:\n        fields = [\"name\"]\n        optionals = [(\"description\", str)]\n\n    def before_save(self):\n        if not self.slug:\n            self.slug = slugify(self.name)\n\n    def __str__(self):\n        return self.name\n\n\nclass Tag(ModelSerializer):\n    name = models.CharField(max_length=50, unique=True)\n    slug = models.SlugField(unique=True, blank=True)\n\n    class ReadSerializer:\n        fields = [\"id\", \"name\", \"slug\"]\n\n    class CreateSerializer:\n        fields = [\"name\"]\n\n    def before_save(self):\n        if not self.slug:\n            self.slug = slugify(self.name)\n\n    def __str__(self):\n        return self.name\n\n\nclass Article(ModelSerializer):\n    title = models.CharField(max_length=200)\n    slug = models.SlugField(unique=True, blank=True)\n    content = models.TextField()\n    excerpt = models.TextField(max_length=300, blank=True)\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=\"articles\")\n    category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True, related_name=\"articles\")\n    tags = models.ManyToManyField(Tag, related_name=\"articles\", blank=True)\n    cover_image = models.URLField(blank=True)\n    is_published = models.BooleanField(default=False)\n    published_at = models.DateTimeField(null=True, blank=True)\n    views = models.IntegerField(default=0)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    class ReadSerializer:\n        fields = [\n            \"id\", \"title\", \"slug\", \"content\", \"excerpt\",\n            \"author\", \"category\", \"tags\", \"cover_image\",\n            \"is_published\", \"published_at\", \"views\",\n            \"created_at\", \"updated_at\"\n        ]\n        customs = [\n            (\"word_count\", int, lambda obj: len(obj.content.split())),\n            (\"reading_time\", int, lambda obj: max(1, len(obj.content.split()) // 200)),\n        ]\n\n    class CreateSerializer:\n        fields = [\"title\", \"content\", \"author\", \"category\"]\n        optionals = [\n            (\"excerpt\", str),\n            (\"cover_image\", str),\n            (\"tags\", list[int]),\n            (\"is_published\", bool),\n        ]\n        customs = [\n            (\"notify_subscribers\", bool, True),\n        ]\n\n    class UpdateSerializer:\n        optionals = [\n            (\"title\", str),\n            (\"content\", str),\n            (\"excerpt\", str),\n            (\"category\", int),\n            (\"tags\", list[int]),\n            (\"cover_image\", str),\n            (\"is_published\", bool),\n        ]\n        excludes = [\"author\", \"created_at\", \"views\"]\n\n    def before_save(self):\n        # Generate slug from title\n        if not self.slug:\n            self.slug = slugify(self.title)\n\n        # Auto-generate excerpt\n        if not self.excerpt and self.content:\n            self.excerpt = self.content[:297] + \"...\"\n\n        # Set published_at when publishing\n        if self.is_published and not self.published_at:\n            from django.utils import timezone\n            self.published_at = timezone.now()\n\n    async def post_create(self):\n        # Log creation\n        from myapp.models import ActivityLog\n        await ActivityLog.objects.acreate(\n            action=\"article_created\",\n            article_id=self.id,\n            user_id=self.author_id\n        )\n\n    async def custom_actions(self, payload: dict):\n        if payload.get(\"notify_subscribers\"):\n            # Send notifications (implement your notification logic)\n            from myapp.tasks import notify_article_published\n            await notify_article_published(self.id)\n\n    def __str__(self):\n        return self.title\n</code></pre>"},{"location":"tutorial/model/#run-migrations","title":"Run Migrations","text":"<p>After defining your models, create and run migrations:</p> Bash<pre><code># Create migrations\npython manage.py makemigrations\n\n# Apply migrations\npython manage.py migrate\n</code></pre>"},{"location":"tutorial/model/#next-steps","title":"Next Steps","text":"<p>Now that you have your models defined, let's create CRUD views in Step 2: Create CRUD Views.</p> <p>!!! success \"What You've Learned\" - \u2705 Creating models with <code>ModelSerializer</code> - \u2705 Defining Read, Create, and Update serializers - \u2705 Working with ForeignKey and ManyToMany relationships - \u2705 Adding custom computed fields - \u2705 Implementing lifecycle hooks</p>"},{"location":"tutorial/model/#see-also","title":"See Also","text":"<ul> <li>ModelSerializer API Reference - Complete API documentation</li> <li>ModelUtil API Reference - Utility methods</li> </ul>"}]}